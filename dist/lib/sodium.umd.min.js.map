{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///sodium.umd.min.js","webpack:///webpack/bootstrap eadf33d06606958bd9c7","webpack:///./src/lib/Sodium.ts","webpack:///./src/lib/Lambda.ts","webpack:///./src/lib/Vertex.ts","webpack:///./src/lib/Stream.ts","webpack:///./src/lib/Transaction.ts","webpack:///./~/typescript-collections/dist/lib/index.js","webpack:///./~/typescript-collections/dist/lib/arrays.js","webpack:///./~/typescript-collections/dist/lib/util.js","webpack:///./~/typescript-collections/dist/lib/Bag.js","webpack:///./~/typescript-collections/dist/lib/Dictionary.js","webpack:///./~/typescript-collections/dist/lib/Set.js","webpack:///./~/typescript-collections/dist/lib/BSTree.js","webpack:///./~/typescript-collections/dist/lib/Queue.js","webpack:///./~/typescript-collections/dist/lib/LinkedList.js","webpack:///./~/typescript-collections/dist/lib/Heap.js","webpack:///./~/typescript-collections/dist/lib/LinkedDictionary.js","webpack:///./~/typescript-collections/dist/lib/MultiDictionary.js","webpack:///./~/typescript-collections/dist/lib/PriorityQueue.js","webpack:///./~/typescript-collections/dist/lib/Stack.js","webpack:///./src/lib/CoalesceHandler.ts","webpack:///./src/lib/Cell.ts","webpack:///./src/lib/Lazy.ts","webpack:///./src/lib/Operational.ts","webpack:///./src/lib/Unit.ts","webpack:///./src/lib/Listener.ts","webpack:///./src/lib/LazyCell.ts","webpack:///./src/lib/StreamSink.ts","webpack:///./src/lib/CellLoop.ts","webpack:///./src/lib/CellSink.ts","webpack:///./src/lib/Tuple2.ts","webpack:///./src/lib/TimerSystem.ts","webpack:///./src/lib/SecondsTimerSystem.ts","webpack:///./src/lib/MillisecondsTimerSystem.ts","webpack:///./src/lib/IOAction.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Lambda_1","lambda1","lambda2","lambda3","lambda4","lambda5","lambda6","Stream_1","Stream","StreamLoop","StreamSink_1","StreamSink","Cell_1","Cell","CellLoop_1","CellLoop","CellSink_1","CellSink","Transaction_1","transactionally","Tuple2_1","Tuple2","Unit_1","Unit","Operational_1","Operational","Vertex_1","getTotalRegistrations","Vertex","TimerSystem_1","TimerSystemImpl","TimerSystem","SecondsTimerSystem_1","SecondsTimerSystem","MillisecondsTimerSystem_1","MillisecondsTimerSystem","IOAction_1","IOAction","f","deps","Lambda1","Lambda1_deps","Lambda1_toFunction","Lambda2","Lambda2_deps","Lambda2_toFunction","Lambda3","Lambda3_deps","Lambda3_toFunction","Lambda4","Lambda4_deps","Lambda4_toFunction","Lambda5","Lambda5_deps","Lambda5_toFunction","Lambda6","Lambda6_deps","Lambda6_toFunction","toSources","ss","i","length","dep","push","Source","getVertex__","totalRegistrations","setVerbose","v","verbose","describeAll","visited","contains","console","log","descr","add","chs","children","origin","register_","registered","deregister_","Error","prototype","register","target","_this","increment","decrement","deregister","Color","roots","nextID","name","rank","sources","targets","childrn","color","black","buffered","refCountAdj","refCount","collectCycles","incRefCount","anyChanged","ensureBiggerThan","decRefCount","matched","splice","addSource","src","limit","colStr","gray","white","purple","str","referrer","release","possibleRoots","free","markRoots","scanRoots","collectRoots","newRoots","markGray","scan","collectWhite","scanBlack","NULL","__extends","d","b","__","constructor","hasOwnProperty","Object","create","CoalesceHandler_1","Listener_1","Lazy_1","LazyCell_1","vertex","listeners","firings","map","out","StreamWithSend","ff","listen_","a","send_","concat","mapTo","orElse","s","merge","left","right","merge_","coalesce__","coalescer","CoalesceHandler","filter","filterNotNull","gate","snapshot","pred","snapshot1","sampleNoTrans__","hold","initValue","holdLazy","LazyCell","collect","initState","collectLazy","Lazy","ea","es","ebs","eb","bs","es_out","loop","accum","accumLazy","once","me","listen","h","suppressEarlierFirings","currentTransaction","requestRegen","listener","Listener","firings_1","slice","prioritized","removed","_super","setVertex__","last","_loop_1","inCallback","err","assigned__","sa_out","transWas","runningOnStartHooks","onStartHooks","Transaction","close","typescript_collections_1","Entry","action","seq","nextSeq","toString","toRegen","prioritizedQ","PriorityQueue","entries","Set","lastQ","postQ","e","enqueue","post","childIx","existing","neu","checkRegen","clear","toArray","isEmpty","dequeue","remove","parent_1","onStart","r","_arrays","arrays","Bag_1","Bag","BSTree_1","BSTree","Dictionary_1","Dictionary","Heap_1","Heap","LinkedDictionary_1","LinkedDictionary","LinkedList_1","LinkedList","MultiDictionary_1","MultiDictionary","Queue_1","Queue","PriorityQueue_1","Set_1","Stack_1","Stack","_util","util","indexOf","array","item","equalsFunction","equals","defaultEquals","lastIndexOf","index","frequency","freq","array1","array2","copy","swap","j","temp","forEach","callback","_i","array_1","ele","defaultCompare","defaultToString","isUndefined","isString","makeString","join","toret","first","prop","has","isFunction","func","obj","reverseCompareFunction","compareFunction","compareToEquals","_hasOwnProperty","toStrFunction","toStrF","dictionary","nElements","element","nCopies","getValue","copies","node","value","setValue","count","containsKey","values","values_1","toSet","elements","elements_1","k","size","defineProperty","table","toStr","key","pair","ret","previousElement","undefined","keys","name_1","name_2","name_3","toStringFunction","intersection","otherSet","set","union","difference","isSubsetOf","isSub","compare","insertNode","createNode","searchNode","removeNode","inorderTraversal","inorderTraversalAux","stop","preorderTraversal","preorderTraversalAux","postorderTraversal","postorderTraversalAux","levelTraversal","levelTraversalAux","minimum","minimumAux","maximum","maximumAux","height","heightAux","cmp","leftCh","rightCh","transplant","n1","n2","parent","y","signal","queue","Math","max","position","list","elem","el","removeElementAtIndex","peek","firstNode","lastNode","newNode","next","prev","nodeAtIndex","elementAtIndex","equalsF","currentNode","previous","other","eqF","equalsAux","reverse","current","collections","data","leftChildIndex","nodeIndex","rightChildIndex","parentIndex","floor","minIndex","leftChild","rightChild","siftUp","siftDown","min","removeRoot","equF","LinkedDictionaryPair","unlink","head","tail","appendToTail","entry","getLinkedDictionaryPair","replace","oldPair","newPair","existingPair","crawlNode","valuesEqualsFunction","allowDuplicateValues","dict","allowDuplicate","_a","v_1","w","heap","pop","accumValid","LazySample","cell","hasValue","ApplyState","f_present","a_present","setStream","valueUpdate","lazyInitValue","getStream__","sample","sampleLazy","sampleLazyNoTrans__","updates","lift","fn0","fn","cf","aa","bb","apply","lift3","mf","cc","lift4","dd","lift5","ee","lift6","ca","state","cf_value","ca_value","src1","src2","l","switchC","cca","za","ba","last_ca","cca_value","kill2","kill1","switchS","csa","h2","sa","get","sSpark","UNIT","sInitial","defer","split","as","send","a_out","Event","t","sAlarm","impl","eventQueue","timeSnk","now","time","ev","mev","state_1","at","tAlarm","cancelCurrent","active","tAl","sampled","updateTimer","setTimer","kill","oAlarm","SecondsTimerSystemImpl","arguments","timeout","setTimeout","clearTimeout","Date","MillisecondsTimerSystemImpl","fromAsync","performIO"],"mappings":"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","file":"sodium.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Sodium\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sodium\"] = factory();\n\telse\n\t\troot[\"Sodium\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Sodium\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Sodium\"] = factory();\n\telse\n\t\troot[\"Sodium\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Lambda_1 = __webpack_require__(1);\r\n\texports.lambda1 = Lambda_1.lambda1;\r\n\texports.lambda2 = Lambda_1.lambda2;\r\n\texports.lambda3 = Lambda_1.lambda3;\r\n\texports.lambda4 = Lambda_1.lambda4;\r\n\texports.lambda5 = Lambda_1.lambda5;\r\n\texports.lambda6 = Lambda_1.lambda6;\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\texports.Stream = Stream_1.Stream;\r\n\texports.StreamLoop = Stream_1.StreamLoop;\r\n\tvar StreamSink_1 = __webpack_require__(26);\r\n\texports.StreamSink = StreamSink_1.StreamSink;\r\n\tvar Cell_1 = __webpack_require__(20);\r\n\texports.Cell = Cell_1.Cell;\r\n\tvar CellLoop_1 = __webpack_require__(27);\r\n\texports.CellLoop = CellLoop_1.CellLoop;\r\n\tvar CellSink_1 = __webpack_require__(28);\r\n\texports.CellSink = CellSink_1.CellSink;\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\texports.transactionally = Transaction_1.transactionally;\r\n\tvar Tuple2_1 = __webpack_require__(29);\r\n\texports.Tuple2 = Tuple2_1.Tuple2;\r\n\tvar Unit_1 = __webpack_require__(23);\r\n\texports.Unit = Unit_1.Unit;\r\n\tvar Operational_1 = __webpack_require__(22);\r\n\texports.Operational = Operational_1.Operational;\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\texports.getTotalRegistrations = Vertex_1.getTotalRegistrations;\r\n\texports.Vertex = Vertex_1.Vertex;\r\n\tvar TimerSystem_1 = __webpack_require__(30);\r\n\texports.TimerSystemImpl = TimerSystem_1.TimerSystemImpl;\r\n\texports.TimerSystem = TimerSystem_1.TimerSystem;\r\n\tvar SecondsTimerSystem_1 = __webpack_require__(31);\r\n\texports.SecondsTimerSystem = SecondsTimerSystem_1.SecondsTimerSystem;\r\n\tvar MillisecondsTimerSystem_1 = __webpack_require__(32);\r\n\texports.MillisecondsTimerSystem = MillisecondsTimerSystem_1.MillisecondsTimerSystem;\r\n\tvar IOAction_1 = __webpack_require__(33);\r\n\texports.IOAction = IOAction_1.IOAction;\r\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar Lambda1 = (function () {\r\n\t    function Lambda1(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda1;\r\n\t}());\r\n\texports.Lambda1 = Lambda1;\r\n\tfunction lambda1(f, deps) {\r\n\t    return new Lambda1(f, deps);\r\n\t}\r\n\texports.lambda1 = lambda1;\r\n\tfunction Lambda1_deps(f) {\r\n\t    if (f instanceof Lambda1)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda1_deps = Lambda1_deps;\r\n\tfunction Lambda1_toFunction(f) {\r\n\t    if (f instanceof Lambda1)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda1_toFunction = Lambda1_toFunction;\r\n\tvar Lambda2 = (function () {\r\n\t    function Lambda2(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda2;\r\n\t}());\r\n\texports.Lambda2 = Lambda2;\r\n\tfunction lambda2(f, deps) {\r\n\t    return new Lambda2(f, deps);\r\n\t}\r\n\texports.lambda2 = lambda2;\r\n\tfunction Lambda2_deps(f) {\r\n\t    if (f instanceof Lambda2)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda2_deps = Lambda2_deps;\r\n\tfunction Lambda2_toFunction(f) {\r\n\t    if (f instanceof Lambda2)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda2_toFunction = Lambda2_toFunction;\r\n\tvar Lambda3 = (function () {\r\n\t    function Lambda3(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda3;\r\n\t}());\r\n\texports.Lambda3 = Lambda3;\r\n\tfunction lambda3(f, deps) {\r\n\t    return new Lambda3(f, deps);\r\n\t}\r\n\texports.lambda3 = lambda3;\r\n\tfunction Lambda3_deps(f) {\r\n\t    if (f instanceof Lambda3)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda3_deps = Lambda3_deps;\r\n\tfunction Lambda3_toFunction(f) {\r\n\t    if (f instanceof Lambda3)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda3_toFunction = Lambda3_toFunction;\r\n\tvar Lambda4 = (function () {\r\n\t    function Lambda4(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda4;\r\n\t}());\r\n\texports.Lambda4 = Lambda4;\r\n\tfunction lambda4(f, deps) {\r\n\t    return new Lambda4(f, deps);\r\n\t}\r\n\texports.lambda4 = lambda4;\r\n\tfunction Lambda4_deps(f) {\r\n\t    if (f instanceof Lambda4)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda4_deps = Lambda4_deps;\r\n\tfunction Lambda4_toFunction(f) {\r\n\t    if (f instanceof Lambda4)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda4_toFunction = Lambda4_toFunction;\r\n\tvar Lambda5 = (function () {\r\n\t    function Lambda5(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda5;\r\n\t}());\r\n\texports.Lambda5 = Lambda5;\r\n\tfunction lambda5(f, deps) {\r\n\t    return new Lambda5(f, deps);\r\n\t}\r\n\texports.lambda5 = lambda5;\r\n\tfunction Lambda5_deps(f) {\r\n\t    if (f instanceof Lambda5)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda5_deps = Lambda5_deps;\r\n\tfunction Lambda5_toFunction(f) {\r\n\t    if (f instanceof Lambda5)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda5_toFunction = Lambda5_toFunction;\r\n\tvar Lambda6 = (function () {\r\n\t    function Lambda6(f, deps) {\r\n\t        this.f = f;\r\n\t        this.deps = deps;\r\n\t    }\r\n\t    return Lambda6;\r\n\t}());\r\n\texports.Lambda6 = Lambda6;\r\n\tfunction lambda6(f, deps) {\r\n\t    return new Lambda6(f, deps);\r\n\t}\r\n\texports.lambda6 = lambda6;\r\n\tfunction Lambda6_deps(f) {\r\n\t    if (f instanceof Lambda6)\r\n\t        return f.deps;\r\n\t    else\r\n\t        return [];\r\n\t}\r\n\texports.Lambda6_deps = Lambda6_deps;\r\n\tfunction Lambda6_toFunction(f) {\r\n\t    if (f instanceof Lambda6)\r\n\t        return f.f;\r\n\t    else\r\n\t        return f;\r\n\t}\r\n\texports.Lambda6_toFunction = Lambda6_toFunction;\r\n\tfunction toSources(deps) {\r\n\t    var ss = [];\r\n\t    for (var i = 0; i < deps.length; i++) {\r\n\t        var dep = deps[i];\r\n\t        ss.push(new Vertex_1.Source(dep.getVertex__(), null));\r\n\t    }\r\n\t    return ss;\r\n\t}\r\n\texports.toSources = toSources;\r\n\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar totalRegistrations = 0;\r\n\tfunction getTotalRegistrations() {\r\n\t    return totalRegistrations;\r\n\t}\r\n\texports.getTotalRegistrations = getTotalRegistrations;\r\n\tvar Source = (function () {\r\n\t    function Source(origin, register_) {\r\n\t        this.registered = false;\r\n\t        this.deregister_ = null;\r\n\t        if (origin === null)\r\n\t            throw new Error(\"null origin!\");\r\n\t        this.origin = origin;\r\n\t        this.register_ = register_;\r\n\t    }\r\n\t    Source.prototype.register = function (target) {\r\n\t        var _this = this;\r\n\t        if (!this.registered) {\r\n\t            this.registered = true;\r\n\t            if (this.register_ !== null)\r\n\t                this.deregister_ = this.register_();\r\n\t            else {\r\n\t                this.origin.increment(target);\r\n\t                this.deregister_ = function () { return _this.origin.decrement(target); };\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Source.prototype.deregister = function (target) {\r\n\t        if (this.registered) {\r\n\t            this.registered = false;\r\n\t            if (this.deregister_ !== null)\r\n\t                this.deregister_();\r\n\t        }\r\n\t    };\r\n\t    return Source;\r\n\t}());\r\n\texports.Source = Source;\r\n\t(function (Color) {\r\n\t    Color[Color[\"black\"] = 0] = \"black\";\r\n\t    Color[Color[\"gray\"] = 1] = \"gray\";\r\n\t    Color[Color[\"white\"] = 2] = \"white\";\r\n\t    Color[Color[\"purple\"] = 3] = \"purple\";\r\n\t})(exports.Color || (exports.Color = {}));\r\n\tvar Color = exports.Color;\r\n\t;\r\n\tvar roots = [];\r\n\tvar nextID = 0;\r\n\tvar verbose = false;\r\n\tfunction setVerbose(v) { verbose = v; }\r\n\texports.setVerbose = setVerbose;\r\n\tfunction describeAll(v, visited) {\r\n\t    if (visited.contains(v.id))\r\n\t        return;\r\n\t    console.log(v.descr());\r\n\t    visited.add(v.id);\r\n\t    var chs = v.children();\r\n\t    for (var i = 0; i < chs.length; i++)\r\n\t        describeAll(chs[i], visited);\r\n\t}\r\n\texports.describeAll = describeAll;\r\n\tvar Vertex = (function () {\r\n\t    function Vertex(name, rank, sources) {\r\n\t        this.targets = [];\r\n\t        this.childrn = [];\r\n\t        this.visited = false;\r\n\t        // --------------------------------------------------------\r\n\t        // Synchronous Cycle Collection algorithm presented in \"Concurrent\r\n\t        // Cycle Collection in Reference Counted Systems\" by David F. Bacon\r\n\t        // and V.T. Rajan.\r\n\t        this.color = Color.black;\r\n\t        this.buffered = false;\r\n\t        this.refCountAdj = 0;\r\n\t        this.name = name;\r\n\t        this.rank = rank;\r\n\t        this.sources = sources;\r\n\t        this.id = nextID++;\r\n\t    }\r\n\t    Vertex.prototype.refCount = function () { return this.targets.length; };\r\n\t    ;\r\n\t    Vertex.prototype.register = function (target) {\r\n\t        return this.increment(target);\r\n\t    };\r\n\t    Vertex.prototype.deregister = function (target) {\r\n\t        if (verbose)\r\n\t            console.log(\"deregister \" + this.descr() + \" => \" + target.descr());\r\n\t        this.decrement(target);\r\n\t        Vertex.collectCycles();\r\n\t    };\r\n\t    Vertex.prototype.incRefCount = function (target) {\r\n\t        var anyChanged = false;\r\n\t        if (this.refCount() == 0) {\r\n\t            for (var i = 0; i < this.sources.length; i++)\r\n\t                this.sources[i].register(this);\r\n\t        }\r\n\t        this.targets.push(target);\r\n\t        target.childrn.push(this);\r\n\t        if (target.ensureBiggerThan(this.rank))\r\n\t            anyChanged = true;\r\n\t        totalRegistrations++;\r\n\t        return anyChanged;\r\n\t    };\r\n\t    Vertex.prototype.decRefCount = function (target) {\r\n\t        if (verbose)\r\n\t            console.log(\"DEC \" + this.descr());\r\n\t        var matched = false;\r\n\t        for (var i = 0; i < target.childrn.length; i++)\r\n\t            if (target.childrn[i] === this) {\r\n\t                target.childrn.splice(i, 1);\r\n\t            }\r\n\t        for (var i = 0; i < this.targets.length; i++)\r\n\t            if (this.targets[i] === target) {\r\n\t                this.targets.splice(i, 1);\r\n\t                matched = true;\r\n\t                break;\r\n\t            }\r\n\t        if (matched) {\r\n\t            if (this.refCount() == 0) {\r\n\t                for (var i = 0; i < this.sources.length; i++)\r\n\t                    this.sources[i].deregister(this);\r\n\t            }\r\n\t            totalRegistrations--;\r\n\t        }\r\n\t    };\r\n\t    Vertex.prototype.addSource = function (src) {\r\n\t        this.sources.push(src);\r\n\t        if (this.refCount() > 0)\r\n\t            src.register(this);\r\n\t    };\r\n\t    Vertex.prototype.ensureBiggerThan = function (limit) {\r\n\t        if (this.rank > limit || this.visited)\r\n\t            return false;\r\n\t        this.visited = true;\r\n\t        this.rank = limit + 1;\r\n\t        for (var i = 0; i < this.targets.length; i++)\r\n\t            this.targets[i].ensureBiggerThan(this.rank);\r\n\t        this.visited = false;\r\n\t        return true;\r\n\t    };\r\n\t    Vertex.prototype.descr = function () {\r\n\t        var colStr = null;\r\n\t        switch (this.color) {\r\n\t            case Color.black:\r\n\t                colStr = \"black\";\r\n\t                break;\r\n\t            case Color.gray:\r\n\t                colStr = \"gray\";\r\n\t                break;\r\n\t            case Color.white:\r\n\t                colStr = \"white\";\r\n\t                break;\r\n\t            case Color.purple:\r\n\t                colStr = \"purple\";\r\n\t                break;\r\n\t        }\r\n\t        var str = this.id + \" \" + this.name + \" [\" + this.refCount() + \"/\" + this.refCountAdj + \"] \" + colStr + \" ->\";\r\n\t        var chs = this.children();\r\n\t        for (var i = 0; i < chs.length; i++) {\r\n\t            str = str + \" \" + chs[i].id;\r\n\t        }\r\n\t        return str;\r\n\t    };\r\n\t    Vertex.prototype.children = function () { return this.childrn; };\r\n\t    Vertex.prototype.increment = function (referrer) {\r\n\t        return this.incRefCount(referrer);\r\n\t    };\r\n\t    Vertex.prototype.decrement = function (referrer) {\r\n\t        this.decRefCount(referrer);\r\n\t        if (this.refCount() == 0)\r\n\t            this.release();\r\n\t        else\r\n\t            this.possibleRoots();\r\n\t    };\r\n\t    Vertex.prototype.release = function () {\r\n\t        this.color = Color.black;\r\n\t        if (!this.buffered)\r\n\t            this.free();\r\n\t    };\r\n\t    Vertex.prototype.free = function () {\r\n\t        while (this.targets.length > 0)\r\n\t            this.decRefCount(this.targets[0]);\r\n\t    };\r\n\t    Vertex.prototype.possibleRoots = function () {\r\n\t        if (this.color != Color.purple) {\r\n\t            this.color = Color.purple;\r\n\t            if (!this.buffered) {\r\n\t                this.buffered = true;\r\n\t                roots.push(this);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Vertex.collectCycles = function () {\r\n\t        Vertex.markRoots();\r\n\t        Vertex.scanRoots();\r\n\t        Vertex.collectRoots();\r\n\t    };\r\n\t    Vertex.markRoots = function () {\r\n\t        var newRoots = [];\r\n\t        for (var i = 0; i < roots.length; i++) {\r\n\t            if (verbose)\r\n\t                console.log(\"markRoots \" + roots[i].descr()); // ###\r\n\t            if (roots[i].color == Color.purple) {\r\n\t                roots[i].markGray();\r\n\t                newRoots.push(roots[i]);\r\n\t            }\r\n\t            else {\r\n\t                roots[i].buffered = false;\r\n\t                if (roots[i].color == Color.black && roots[i].refCount() == 0)\r\n\t                    roots[i].free();\r\n\t            }\r\n\t        }\r\n\t        roots = newRoots;\r\n\t    };\r\n\t    Vertex.scanRoots = function () {\r\n\t        for (var i = 0; i < roots.length; i++)\r\n\t            roots[i].scan();\r\n\t    };\r\n\t    Vertex.collectRoots = function () {\r\n\t        for (var i = 0; i < roots.length; i++) {\r\n\t            roots[i].buffered = false;\r\n\t            roots[i].collectWhite();\r\n\t        }\r\n\t        roots = [];\r\n\t    };\r\n\t    Vertex.prototype.markGray = function () {\r\n\t        if (this.color != Color.gray) {\r\n\t            this.color = Color.gray;\r\n\t            var chs = this.children();\r\n\t            for (var i = 0; i < chs.length; i++) {\r\n\t                chs[i].refCountAdj--;\r\n\t                if (verbose)\r\n\t                    console.log(\"markGray \" + this.descr());\r\n\t                chs[i].markGray();\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Vertex.prototype.scan = function () {\r\n\t        if (verbose)\r\n\t            console.log(\"scan \" + this.descr());\r\n\t        if (this.color == Color.gray) {\r\n\t            if (this.refCount() + this.refCountAdj > 0)\r\n\t                this.scanBlack();\r\n\t            else {\r\n\t                this.color = Color.white;\r\n\t                if (verbose)\r\n\t                    console.log(\"scan WHITE \" + this.descr());\r\n\t                var chs = this.children();\r\n\t                for (var i = 0; i < chs.length; i++)\r\n\t                    chs[i].scan();\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    Vertex.prototype.scanBlack = function () {\r\n\t        this.color = Color.black;\r\n\t        var chs = this.children();\r\n\t        for (var i = 0; i < chs.length; i++) {\r\n\t            chs[i].refCountAdj++;\r\n\t            if (verbose)\r\n\t                console.log(\"scanBlack \" + this.descr());\r\n\t            if (chs[i].color != Color.black)\r\n\t                chs[i].scanBlack();\r\n\t        }\r\n\t    };\r\n\t    Vertex.prototype.collectWhite = function () {\r\n\t        if (this.color == Color.white && !this.buffered) {\r\n\t            if (verbose)\r\n\t                console.log(\"collectWhite \" + this.descr());\r\n\t            this.color = Color.black;\r\n\t            this.refCountAdj = 0;\r\n\t            var chs = this.children();\r\n\t            for (var i = 0; i < chs.length; i++)\r\n\t                chs[i].collectWhite();\r\n\t            this.free();\r\n\t        }\r\n\t    };\r\n\t    Vertex.NULL = new Vertex(\"user\", 1e12, []);\r\n\t    return Vertex;\r\n\t}());\r\n\texports.Vertex = Vertex;\r\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Lambda_1 = __webpack_require__(1);\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar CoalesceHandler_1 = __webpack_require__(19);\r\n\tvar Cell_1 = __webpack_require__(20);\r\n\t//import { StreamLoop } from \"./StreamLoop\";\r\n\tvar Listener_1 = __webpack_require__(24);\r\n\tvar Lazy_1 = __webpack_require__(21);\r\n\tvar LazyCell_1 = __webpack_require__(25);\r\n\tvar Stream = (function () {\r\n\t    function Stream(vertex) {\r\n\t        this.listeners = [];\r\n\t        this.firings = [];\r\n\t        this.vertex = vertex ? vertex : new Vertex_1.Vertex(\"Stream\", 0, []);\r\n\t    }\r\n\t    Stream.prototype.getVertex__ = function () {\r\n\t        return this.vertex;\r\n\t    };\r\n\t    /**\r\n\t     * Transform the stream's event values according to the supplied function, so the returned\r\n\t     * Stream's event values reflect the value of the function applied to the input\r\n\t     * Stream's event values.\r\n\t     * @param f Function to apply to convert the values. It may construct FRP logic or use\r\n\t     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n\t     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Stream.prototype.map = function (f) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        var ff = Lambda_1.Lambda1_toFunction(f);\r\n\t        out.vertex = new Vertex_1.Vertex(\"map\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    out.send_(ff(a));\r\n\t                }, false);\r\n\t            })\r\n\t        ].concat(Lambda_1.toSources(Lambda_1.Lambda1_deps(f))));\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Transform the stream's event values into the specified constant value.\r\n\t     * @param b Constant value.\r\n\t     */\r\n\t    Stream.prototype.mapTo = function (b) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        out.vertex = new Vertex_1.Vertex(\"mapTo\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    out.send_(b);\r\n\t                }, false);\r\n\t            })\r\n\t        ]);\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\r\n\t     * in the simultaneous case.\r\n\t     * <p>\r\n\t     * In the case where two events are simultaneous (i.e. both\r\n\t     * within the same transaction), the event from <em>this</em> will take precedence, and\r\n\t     * the event from <em>s</em> will be dropped.\r\n\t     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\r\n\t     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\r\n\t     * <p>\r\n\t     * The name orElse() is used instead of merge() to make it really clear that care should\r\n\t     * be taken, because events can be dropped.\r\n\t     */\r\n\t    Stream.prototype.orElse = function (s) {\r\n\t        return this.merge(s, function (left, right) {\r\n\t            return left;\r\n\t        });\r\n\t    };\r\n\t    Stream.prototype.merge_ = function (s) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend();\r\n\t        var left = new Vertex_1.Vertex(\"merge\", 0, []);\r\n\t        left.sources.push(new Vertex_1.Source(this.vertex, function () {\r\n\t            return _this.listen_(left, function (a) {\r\n\t                out.send_(a);\r\n\t            }, false);\r\n\t        }));\r\n\t        out.vertex.sources = out.vertex.sources.concat([\r\n\t            new Vertex_1.Source(left, function () {\r\n\t                left.register(out.vertex);\r\n\t                return function () { left.deregister(out.vertex); };\r\n\t            }),\r\n\t            new Vertex_1.Source(s.vertex, function () {\r\n\t                return s.listen_(out.vertex, function (a) {\r\n\t                    out.send_(a);\r\n\t                }, false);\r\n\t            })\r\n\t        ]);\r\n\t        return out;\r\n\t    };\r\n\t    Stream.prototype.coalesce__ = function (f) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend();\r\n\t        var coalescer = new CoalesceHandler_1.CoalesceHandler(f, out);\r\n\t        out.vertex.sources = out.vertex.sources.concat([\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    coalescer.send_(a);\r\n\t                }, false);\r\n\t            })\r\n\t        ]).concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f)));\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Merge two streams of the same type into one, so that events on either input appear\r\n\t     * on the returned stream.\r\n\t     * <p>\r\n\t     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\r\n\t     * occurring in the same transaction), combine them into one using the specified combining function\r\n\t     * so that the returned stream is guaranteed only ever to have one event per transaction.\r\n\t     * The event from <em>this</em> will appear at the left input of the combining function, and\r\n\t     * the event from <em>s</em> will appear at the right.\r\n\t     * @param f Function to combine the values. It may construct FRP logic or use\r\n\t     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Stream.prototype.merge = function (s, f) {\r\n\t        var _this = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            return _this.merge_(s).coalesce__(f);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Return a stream that only outputs events for which the predicate returns true.\r\n\t     */\r\n\t    Stream.prototype.filter = function (f) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        var ff = Lambda_1.Lambda1_toFunction(f);\r\n\t        out.vertex = new Vertex_1.Vertex(\"filter\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    if (ff(a))\r\n\t                        out.send_(a);\r\n\t                }, false);\r\n\t            })\r\n\t        ].concat(Lambda_1.toSources(Lambda_1.Lambda1_deps(f))));\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Return a stream that only outputs events that have present\r\n\t     * values, discarding null values.\r\n\t     */\r\n\t    Stream.prototype.filterNotNull = function () {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        out.vertex = new Vertex_1.Vertex(\"filterNotNull\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    if (a !== null)\r\n\t                        out.send_(a);\r\n\t                }, false);\r\n\t            })\r\n\t        ]);\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Return a stream that only outputs events from the input stream\r\n\t     * when the specified cell's value is true.\r\n\t     */\r\n\t    Stream.prototype.gate = function (c) {\r\n\t        return this.snapshot(c, function (a, pred) {\r\n\t            return pred ? a : null;\r\n\t        }).filterNotNull();\r\n\t    };\r\n\t    /**\r\n\t     * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\r\n\t     * at the time of the event firing, ignoring the stream's value.\r\n\t     */\r\n\t    Stream.prototype.snapshot1 = function (c) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        out.vertex = new Vertex_1.Vertex(\"snapshot1\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    out.send_(c.sampleNoTrans__());\r\n\t                }, false);\r\n\t            }),\r\n\t            new Vertex_1.Source(c.getVertex__(), null)\r\n\t        ]);\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Return a stream whose events are the result of the combination using the specified\r\n\t     * function of the input stream's event value and the value of the cell at that time.\r\n\t     * <P>\r\n\t     * There is an implicit delay: State updates caused by event firings being held with\r\n\t     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\r\n\t     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\r\n\t     * always sees the value of a cell as it was before any state changes from the current\r\n\t     * transaction.\r\n\t     */\r\n\t    Stream.prototype.snapshot = function (c, f) {\r\n\t        var _this = this;\r\n\t        var out = new StreamWithSend(null);\r\n\t        var ff = Lambda_1.Lambda2_toFunction(f);\r\n\t        out.vertex = new Vertex_1.Vertex(\"snapshot\", 0, [\r\n\t            new Vertex_1.Source(this.vertex, function () {\r\n\t                return _this.listen_(out.vertex, function (a) {\r\n\t                    out.send_(ff(a, c.sampleNoTrans__()));\r\n\t                }, false);\r\n\t            }),\r\n\t            new Vertex_1.Source(c.getVertex__(), null)\r\n\t        ].concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f))));\r\n\t        return out;\r\n\t    };\r\n\t    /**\r\n\t     * Create a {@link Cell} with the specified initial value, that is updated\r\n\t     * by this stream's event values.\r\n\t     * <p>\r\n\t     * There is an implicit delay: State updates caused by event firings don't become\r\n\t     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\r\n\t     * until the following transaction. To put this another way,\r\n\t     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\r\n\t     * any state changes from the current transaction.\r\n\t     */\r\n\t    Stream.prototype.hold = function (initValue) {\r\n\t        return new Cell_1.Cell(initValue, this);\r\n\t    };\r\n\t    /**\r\n\t     * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\r\n\t     */\r\n\t    Stream.prototype.holdLazy = function (initValue) {\r\n\t        return new LazyCell_1.LazyCell(initValue, this);\r\n\t    };\r\n\t    /**\r\n\t     * Transform an event with a generalized state loop (a Mealy machine). The function\r\n\t     * is passed the input and the old state and returns the new state and output value.\r\n\t     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n\t     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n\t     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Stream.prototype.collect = function (initState, f) {\r\n\t        return this.collectLazy(new Lazy_1.Lazy(function () { return initState; }), f);\r\n\t    };\r\n\t    /**\r\n\t     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\r\n\t     * {@link Cell#sampleLazy()}.\r\n\t     */\r\n\t    Stream.prototype.collectLazy = function (initState, f) {\r\n\t        var ea = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var es = new StreamLoop(), s = es.holdLazy(initState), ebs = ea.snapshot(s, f), eb = ebs.map(function (bs) { return bs.a; }), es_out = ebs.map(function (bs) { return bs.b; });\r\n\t            es.loop(es_out);\r\n\t            return eb;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Accumulate on input event, outputting the new state each time.\r\n\t     * @param f Function to apply to update the state. It may construct FRP logic or use\r\n\t     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\r\n\t     *    cell. Apart from this the function must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Stream.prototype.accum = function (initState, f) {\r\n\t        return this.accumLazy(new Lazy_1.Lazy(function () { return initState; }), f);\r\n\t    };\r\n\t    /**\r\n\t     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\r\n\t     * {@link Cell#sampleLazy()}.\r\n\t     */\r\n\t    Stream.prototype.accumLazy = function (initState, f) {\r\n\t        var ea = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var es = new StreamLoop(), s = es.holdLazy(initState), es_out = ea.snapshot(s, f);\r\n\t            es.loop(es_out);\r\n\t            return es_out.holdLazy(initState);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Return a stream that outputs only one value: the next event of the\r\n\t     * input stream, starting from the transaction in which once() was invoked.\r\n\t     */\r\n\t    Stream.prototype.once = function () {\r\n\t        /*\r\n\t            return transactionally(() => {\r\n\t                const ev = this,\r\n\t                    out = new StreamWithSend<A>();\r\n\t                let la : () => void = null;\r\n\t                la = ev.listen_(out.vertex, (a : A) => {\r\n\t                    if (la !== null) {\r\n\t                        out.send_(a);\r\n\t                        la();\r\n\t                        la = null;\r\n\t                    }\r\n\t                }, false);\r\n\t                return out;\r\n\t            });\r\n\t            */\r\n\t        // We can't use the implementation above, beacuse deregistering\r\n\t        // listeners triggers the exception\r\n\t        // \"send() was invoked before listeners were registered\"\r\n\t        // We can revisit this another time. For now we will use the less\r\n\t        // efficient implementation below.\r\n\t        var me = this;\r\n\t        return Transaction_1.transactionally(function () { return me.gate(me.mapTo(false).hold(true)); });\r\n\t    };\r\n\t    Stream.prototype.listen = function (h) {\r\n\t        var _this = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            return _this.listen_(Vertex_1.Vertex.NULL, h, false);\r\n\t        });\r\n\t    };\r\n\t    Stream.prototype.listen_ = function (target, h, suppressEarlierFirings) {\r\n\t        var _this = this;\r\n\t        if (this.vertex.register(target))\r\n\t            Transaction_1.currentTransaction.requestRegen();\r\n\t        var listener = new Listener_1.Listener(h, target);\r\n\t        this.listeners.push(listener);\r\n\t        if (!suppressEarlierFirings && this.firings.length != 0) {\r\n\t            var firings_1 = this.firings.slice();\r\n\t            Transaction_1.currentTransaction.prioritized(target, function () {\r\n\t                // Anything sent already in this transaction must be sent now so that\r\n\t                // there's no order dependency between send and listen.\r\n\t                for (var i = 0; i < firings_1.length; i++)\r\n\t                    h(firings_1[i]);\r\n\t            });\r\n\t        }\r\n\t        return function () {\r\n\t            var removed = false;\r\n\t            for (var i = 0; i < _this.listeners.length; i++) {\r\n\t                if (_this.listeners[i] == listener) {\r\n\t                    _this.listeners.splice(i, 1);\r\n\t                    removed = true;\r\n\t                    break;\r\n\t                }\r\n\t            }\r\n\t            if (removed)\r\n\t                _this.vertex.deregister(target);\r\n\t        };\r\n\t    };\r\n\t    return Stream;\r\n\t}());\r\n\texports.Stream = Stream;\r\n\tvar StreamWithSend = (function (_super) {\r\n\t    __extends(StreamWithSend, _super);\r\n\t    function StreamWithSend(vertex) {\r\n\t        _super.call(this, vertex);\r\n\t    }\r\n\t    StreamWithSend.prototype.setVertex__ = function (vertex) {\r\n\t        this.vertex = vertex;\r\n\t    };\r\n\t    StreamWithSend.prototype.send_ = function (a) {\r\n\t        var _this = this;\r\n\t        // We throw this error if we send into FRP logic that has been constructed\r\n\t        // but nothing is listening to it yet. We need to do it this way because\r\n\t        // it's the only way to manage memory in a language with no finalizers.\r\n\t        if (this.vertex.refCount() == 0)\r\n\t            throw new Error(\"send() was invoked before listeners were registered\");\r\n\t        if (this.firings.length == 0)\r\n\t            Transaction_1.currentTransaction.last(function () {\r\n\t                _this.firings = [];\r\n\t            });\r\n\t        this.firings.push(a);\r\n\t        var listeners = this.listeners.slice();\r\n\t        var _loop_1 = function(i) {\r\n\t            var h = listeners[i].h;\r\n\t            Transaction_1.currentTransaction.prioritized(listeners[i].target, function () {\r\n\t                Transaction_1.currentTransaction.inCallback++;\r\n\t                try {\r\n\t                    h(a);\r\n\t                    Transaction_1.currentTransaction.inCallback--;\r\n\t                }\r\n\t                catch (err) {\r\n\t                    Transaction_1.currentTransaction.inCallback--;\r\n\t                    throw err;\r\n\t                }\r\n\t            });\r\n\t        };\r\n\t        for (var i = 0; i < listeners.length; i++) {\r\n\t            _loop_1(i);\r\n\t        }\r\n\t    };\r\n\t    return StreamWithSend;\r\n\t}(Stream));\r\n\texports.StreamWithSend = StreamWithSend;\r\n\t/**\r\n\t * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\r\n\t */\r\n\tvar StreamLoop = (function (_super) {\r\n\t    __extends(StreamLoop, _super);\r\n\t    function StreamLoop() {\r\n\t        _super.call(this);\r\n\t        this.assigned__ = false; // to do: Figure out how to hide this\r\n\t        this.vertex.name = \"StreamLoop\";\r\n\t        if (Transaction_1.currentTransaction === null)\r\n\t            throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\r\n\t    }\r\n\t    /**\r\n\t     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\r\n\t     * must be invoked inside the same transaction as the place where the StreamLoop is used.\r\n\t     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n\t     * or {@link Transaction#runVoid(Runnable)}.\r\n\t     */\r\n\t    StreamLoop.prototype.loop = function (sa_out) {\r\n\t        var _this = this;\r\n\t        if (this.assigned__)\r\n\t            throw new Error(\"StreamLoop looped more than once\");\r\n\t        this.assigned__ = true;\r\n\t        this.vertex.addSource(new Vertex_1.Source(sa_out.getVertex__(), function () {\r\n\t            return sa_out.listen_(_this.vertex, function (a) {\r\n\t                _this.send_(a);\r\n\t            }, false);\r\n\t        }));\r\n\t    };\r\n\t    return StreamLoop;\r\n\t}(StreamWithSend));\r\n\texports.StreamLoop = StreamLoop;\r\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar typescript_collections_1 = __webpack_require__(5);\r\n\tvar Entry = (function () {\r\n\t    function Entry(rank, action) {\r\n\t        this.rank = rank;\r\n\t        this.action = action;\r\n\t        this.seq = Entry.nextSeq++;\r\n\t    }\r\n\t    Entry.prototype.toString = function () {\r\n\t        return this.seq.toString();\r\n\t    };\r\n\t    Entry.nextSeq = 0;\r\n\t    return Entry;\r\n\t}());\r\n\texports.Entry = Entry;\r\n\tvar Transaction = (function () {\r\n\t    function Transaction() {\r\n\t        this.inCallback = 0;\r\n\t        this.toRegen = false;\r\n\t        this.prioritizedQ = new typescript_collections_1.PriorityQueue(function (a, b) {\r\n\t            // Note: Low priority numbers are treated as \"greater\" according to this\r\n\t            // comparison, so that the lowest numbers are highest priority and go first.\r\n\t            if (a.rank.rank < b.rank.rank)\r\n\t                return 1;\r\n\t            if (a.rank.rank > b.rank.rank)\r\n\t                return -1;\r\n\t            if (a.seq < b.seq)\r\n\t                return 1;\r\n\t            if (a.seq > b.seq)\r\n\t                return -1;\r\n\t            return 0;\r\n\t        });\r\n\t        this.entries = new typescript_collections_1.Set(function (a) { return a.toString(); });\r\n\t        this.lastQ = [];\r\n\t        this.postQ = null;\r\n\t    }\r\n\t    Transaction.prototype.requestRegen = function () { this.toRegen = true; };\r\n\t    Transaction.prototype.prioritized = function (target, f) {\r\n\t        var e = new Entry(target, f);\r\n\t        this.prioritizedQ.enqueue(e);\r\n\t        this.entries.add(e);\r\n\t    };\r\n\t    Transaction.prototype.last = function (h) {\r\n\t        this.lastQ.push(h);\r\n\t    };\r\n\t    /**\r\n\t     * Add an action to run after all last() actions.\r\n\t     */\r\n\t    Transaction.prototype.post = function (childIx, action) {\r\n\t        if (this.postQ == null)\r\n\t            this.postQ = [];\r\n\t        // If an entry exists already, combine the old one with the new one.\r\n\t        while (this.postQ.length <= childIx)\r\n\t            this.postQ.push(null);\r\n\t        var existing = this.postQ[childIx], neu = existing === null ? action\r\n\t            : function () {\r\n\t                existing();\r\n\t                action();\r\n\t            };\r\n\t        this.postQ[childIx] = neu;\r\n\t    };\r\n\t    // If the priority queue has entries in it when we modify any of the nodes'\r\n\t    // ranks, then we need to re-generate it to make sure it's up-to-date.\r\n\t    Transaction.prototype.checkRegen = function () {\r\n\t        if (this.toRegen) {\r\n\t            this.toRegen = false;\r\n\t            this.prioritizedQ.clear();\r\n\t            var es = this.entries.toArray();\r\n\t            for (var i = 0; i < es.length; i++)\r\n\t                this.prioritizedQ.enqueue(es[i]);\r\n\t        }\r\n\t    };\r\n\t    Transaction.prototype.close = function () {\r\n\t        while (true) {\r\n\t            this.checkRegen();\r\n\t            if (this.prioritizedQ.isEmpty())\r\n\t                break;\r\n\t            var e = this.prioritizedQ.dequeue();\r\n\t            this.entries.remove(e);\r\n\t            e.action();\r\n\t        }\r\n\t        for (var i = 0; i < this.lastQ.length; i++)\r\n\t            this.lastQ[i]();\r\n\t        this.lastQ = [];\r\n\t        if (this.postQ != null) {\r\n\t            for (var i = 0; i < this.postQ.length; i++) {\r\n\t                if (this.postQ[i] != null) {\r\n\t                    var parent_1 = exports.currentTransaction;\r\n\t                    try {\r\n\t                        if (i > 0) {\r\n\t                            exports.currentTransaction = new Transaction();\r\n\t                            try {\r\n\t                                this.postQ[i]();\r\n\t                                exports.currentTransaction.close();\r\n\t                            }\r\n\t                            catch (err) {\r\n\t                                exports.currentTransaction.close();\r\n\t                                throw err;\r\n\t                            }\r\n\t                        }\r\n\t                        else {\r\n\t                            exports.currentTransaction = null;\r\n\t                            this.postQ[i]();\r\n\t                        }\r\n\t                        exports.currentTransaction = parent_1;\r\n\t                    }\r\n\t                    catch (err) {\r\n\t                        exports.currentTransaction = parent_1;\r\n\t                        throw err;\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t            this.postQ = null;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Add a runnable that will be executed whenever a transaction is started.\r\n\t     * That runnable may start transactions itself, which will not cause the\r\n\t     * hooks to be run recursively.\r\n\t     *\r\n\t     * The main use case of this is the implementation of a time/alarm system.\r\n\t     */\r\n\t    Transaction.onStart = function (r) {\r\n\t        onStartHooks.push(r);\r\n\t    };\r\n\t    return Transaction;\r\n\t}());\r\n\texports.Transaction = Transaction;\r\n\texports.currentTransaction = null;\r\n\tvar onStartHooks = [], runningOnStartHooks = false;\r\n\tfunction transactionally(f) {\r\n\t    var transWas = exports.currentTransaction;\r\n\t    if (transWas === null) {\r\n\t        if (!runningOnStartHooks) {\r\n\t            runningOnStartHooks = true;\r\n\t            try {\r\n\t                for (var i = 0; i < onStartHooks.length; i++)\r\n\t                    onStartHooks[i]();\r\n\t            }\r\n\t            finally {\r\n\t                runningOnStartHooks = false;\r\n\t            }\r\n\t        }\r\n\t        exports.currentTransaction = new Transaction();\r\n\t    }\r\n\t    try {\r\n\t        var a = f();\r\n\t        if (transWas === null) {\r\n\t            exports.currentTransaction.close();\r\n\t            exports.currentTransaction = null;\r\n\t        }\r\n\t        return a;\r\n\t    }\r\n\t    catch (err) {\r\n\t        if (transWas === null) {\r\n\t            exports.currentTransaction.close();\r\n\t            exports.currentTransaction = null;\r\n\t        }\r\n\t        throw err;\r\n\t    }\r\n\t}\r\n\texports.transactionally = transactionally;\r\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t// Copyright 2013 Basarat Ali Syed. All Rights Reserved.\r\n\t//\r\n\t// Licensed under MIT open source license http://opensource.org/licenses/MIT\r\n\t//\r\n\t// Orginal javascript code was by Mauricio Santos\r\n\t//\r\n\tvar _arrays = __webpack_require__(6);\r\n\texports.arrays = _arrays;\r\n\tvar Bag_1 = __webpack_require__(8);\r\n\texports.Bag = Bag_1.default;\r\n\tvar BSTree_1 = __webpack_require__(11);\r\n\texports.BSTree = BSTree_1.default;\r\n\tvar Dictionary_1 = __webpack_require__(9);\r\n\texports.Dictionary = Dictionary_1.default;\r\n\tvar Heap_1 = __webpack_require__(14);\r\n\texports.Heap = Heap_1.default;\r\n\tvar LinkedDictionary_1 = __webpack_require__(15);\r\n\texports.LinkedDictionary = LinkedDictionary_1.default;\r\n\tvar LinkedList_1 = __webpack_require__(13);\r\n\texports.LinkedList = LinkedList_1.default;\r\n\tvar MultiDictionary_1 = __webpack_require__(16);\r\n\texports.MultiDictionary = MultiDictionary_1.default;\r\n\tvar Queue_1 = __webpack_require__(12);\r\n\texports.Queue = Queue_1.default;\r\n\tvar PriorityQueue_1 = __webpack_require__(17);\r\n\texports.PriorityQueue = PriorityQueue_1.default;\r\n\tvar Set_1 = __webpack_require__(10);\r\n\texports.Set = Set_1.default;\r\n\tvar Stack_1 = __webpack_require__(18);\r\n\texports.Stack = Stack_1.default;\r\n\tvar _util = __webpack_require__(7);\r\n\texports.util = _util;\r\n\t//# sourceMappingURL=index.js.map\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\t/**\r\n\t * Returns the position of the first occurrence of the specified item\r\n\t * within the specified array.4\r\n\t * @param {*} array the array in which to search the element.\r\n\t * @param {Object} item the element to search.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n\t * check equality between 2 elements.\r\n\t * @return {number} the position of the first occurrence of the specified element\r\n\t * within the specified array, or -1 if not found.\r\n\t */\r\n\tfunction indexOf(array, item, equalsFunction) {\r\n\t    var equals = equalsFunction || util.defaultEquals;\r\n\t    var length = array.length;\r\n\t    for (var i = 0; i < length; i++) {\r\n\t        if (equals(array[i], item)) {\r\n\t            return i;\r\n\t        }\r\n\t    }\r\n\t    return -1;\r\n\t}\r\n\texports.indexOf = indexOf;\r\n\t/**\r\n\t * Returns the position of the last occurrence of the specified element\r\n\t * within the specified array.\r\n\t * @param {*} array the array in which to search the element.\r\n\t * @param {Object} item the element to search.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n\t * check equality between 2 elements.\r\n\t * @return {number} the position of the last occurrence of the specified element\r\n\t * within the specified array or -1 if not found.\r\n\t */\r\n\tfunction lastIndexOf(array, item, equalsFunction) {\r\n\t    var equals = equalsFunction || util.defaultEquals;\r\n\t    var length = array.length;\r\n\t    for (var i = length - 1; i >= 0; i--) {\r\n\t        if (equals(array[i], item)) {\r\n\t            return i;\r\n\t        }\r\n\t    }\r\n\t    return -1;\r\n\t}\r\n\texports.lastIndexOf = lastIndexOf;\r\n\t/**\r\n\t * Returns true if the specified array contains the specified element.\r\n\t * @param {*} array the array in which to search the element.\r\n\t * @param {Object} item the element to search.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function to\r\n\t * check equality between 2 elements.\r\n\t * @return {boolean} true if the specified array contains the specified element.\r\n\t */\r\n\tfunction contains(array, item, equalsFunction) {\r\n\t    return indexOf(array, item, equalsFunction) >= 0;\r\n\t}\r\n\texports.contains = contains;\r\n\t/**\r\n\t * Removes the first ocurrence of the specified element from the specified array.\r\n\t * @param {*} array the array in which to search element.\r\n\t * @param {Object} item the element to search.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function to\r\n\t * check equality between 2 elements.\r\n\t * @return {boolean} true if the array changed after this call.\r\n\t */\r\n\tfunction remove(array, item, equalsFunction) {\r\n\t    var index = indexOf(array, item, equalsFunction);\r\n\t    if (index < 0) {\r\n\t        return false;\r\n\t    }\r\n\t    array.splice(index, 1);\r\n\t    return true;\r\n\t}\r\n\texports.remove = remove;\r\n\t/**\r\n\t * Returns the number of elements in the specified array equal\r\n\t * to the specified object.\r\n\t * @param {Array} array the array in which to determine the frequency of the element.\r\n\t * @param {Object} item the element whose frequency is to be determined.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n\t * check equality between 2 elements.\r\n\t * @return {number} the number of elements in the specified array\r\n\t * equal to the specified object.\r\n\t */\r\n\tfunction frequency(array, item, equalsFunction) {\r\n\t    var equals = equalsFunction || util.defaultEquals;\r\n\t    var length = array.length;\r\n\t    var freq = 0;\r\n\t    for (var i = 0; i < length; i++) {\r\n\t        if (equals(array[i], item)) {\r\n\t            freq++;\r\n\t        }\r\n\t    }\r\n\t    return freq;\r\n\t}\r\n\texports.frequency = frequency;\r\n\t/**\r\n\t * Returns true if the two specified arrays are equal to one another.\r\n\t * Two arrays are considered equal if both arrays contain the same number\r\n\t * of elements, and all corresponding pairs of elements in the two\r\n\t * arrays are equal and are in the same order.\r\n\t * @param {Array} array1 one array to be tested for equality.\r\n\t * @param {Array} array2 the other array to be tested for equality.\r\n\t * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n\t * check equality between elemements in the arrays.\r\n\t * @return {boolean} true if the two arrays are equal\r\n\t */\r\n\tfunction equals(array1, array2, equalsFunction) {\r\n\t    var equals = equalsFunction || util.defaultEquals;\r\n\t    if (array1.length !== array2.length) {\r\n\t        return false;\r\n\t    }\r\n\t    var length = array1.length;\r\n\t    for (var i = 0; i < length; i++) {\r\n\t        if (!equals(array1[i], array2[i])) {\r\n\t            return false;\r\n\t        }\r\n\t    }\r\n\t    return true;\r\n\t}\r\n\texports.equals = equals;\r\n\t/**\r\n\t * Returns shallow a copy of the specified array.\r\n\t * @param {*} array the array to copy.\r\n\t * @return {Array} a copy of the specified array\r\n\t */\r\n\tfunction copy(array) {\r\n\t    return array.concat();\r\n\t}\r\n\texports.copy = copy;\r\n\t/**\r\n\t * Swaps the elements at the specified positions in the specified array.\r\n\t * @param {Array} array The array in which to swap elements.\r\n\t * @param {number} i the index of one element to be swapped.\r\n\t * @param {number} j the index of the other element to be swapped.\r\n\t * @return {boolean} true if the array is defined and the indexes are valid.\r\n\t */\r\n\tfunction swap(array, i, j) {\r\n\t    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\r\n\t        return false;\r\n\t    }\r\n\t    var temp = array[i];\r\n\t    array[i] = array[j];\r\n\t    array[j] = temp;\r\n\t    return true;\r\n\t}\r\n\texports.swap = swap;\r\n\tfunction toString(array) {\r\n\t    return '[' + array.toString() + ']';\r\n\t}\r\n\texports.toString = toString;\r\n\t/**\r\n\t * Executes the provided function once for each element present in this array\r\n\t * starting from index 0 to length - 1.\r\n\t * @param {Array} array The array in which to iterate.\r\n\t * @param {function(Object):*} callback function to execute, it is\r\n\t * invoked with one argument: the element value, to break the iteration you can\r\n\t * optionally return false.\r\n\t */\r\n\tfunction forEach(array, callback) {\r\n\t    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n\t        var ele = array_1[_i];\r\n\t        if (callback(ele) === false) {\r\n\t            return;\r\n\t        }\r\n\t    }\r\n\t}\r\n\texports.forEach = forEach;\r\n\t//# sourceMappingURL=arrays.js.map\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\n\texports.has = function (obj, prop) {\r\n\t    return _hasOwnProperty.call(obj, prop);\r\n\t};\r\n\t/**\r\n\t * Default function to compare element order.\r\n\t * @function\r\n\t */\r\n\tfunction defaultCompare(a, b) {\r\n\t    if (a < b) {\r\n\t        return -1;\r\n\t    }\r\n\t    else if (a === b) {\r\n\t        return 0;\r\n\t    }\r\n\t    else {\r\n\t        return 1;\r\n\t    }\r\n\t}\r\n\texports.defaultCompare = defaultCompare;\r\n\t/**\r\n\t * Default function to test equality.\r\n\t * @function\r\n\t */\r\n\tfunction defaultEquals(a, b) {\r\n\t    return a === b;\r\n\t}\r\n\texports.defaultEquals = defaultEquals;\r\n\t/**\r\n\t * Default function to convert an object to a string.\r\n\t * @function\r\n\t */\r\n\tfunction defaultToString(item) {\r\n\t    if (item === null) {\r\n\t        return 'COLLECTION_NULL';\r\n\t    }\r\n\t    else if (isUndefined(item)) {\r\n\t        return 'COLLECTION_UNDEFINED';\r\n\t    }\r\n\t    else if (isString(item)) {\r\n\t        return '$s' + item;\r\n\t    }\r\n\t    else {\r\n\t        return '$o' + item.toString();\r\n\t    }\r\n\t}\r\n\texports.defaultToString = defaultToString;\r\n\t/**\r\n\t* Joins all the properies of the object using the provided join string\r\n\t*/\r\n\tfunction makeString(item, join) {\r\n\t    if (join === void 0) { join = ','; }\r\n\t    if (item === null) {\r\n\t        return 'COLLECTION_NULL';\r\n\t    }\r\n\t    else if (isUndefined(item)) {\r\n\t        return 'COLLECTION_UNDEFINED';\r\n\t    }\r\n\t    else if (isString(item)) {\r\n\t        return item.toString();\r\n\t    }\r\n\t    else {\r\n\t        var toret = '{';\r\n\t        var first = true;\r\n\t        for (var prop in item) {\r\n\t            if (exports.has(item, prop)) {\r\n\t                if (first) {\r\n\t                    first = false;\r\n\t                }\r\n\t                else {\r\n\t                    toret = toret + join;\r\n\t                }\r\n\t                toret = toret + prop + ':' + item[prop];\r\n\t            }\r\n\t        }\r\n\t        return toret + '}';\r\n\t    }\r\n\t}\r\n\texports.makeString = makeString;\r\n\t/**\r\n\t * Checks if the given argument is a function.\r\n\t * @function\r\n\t */\r\n\tfunction isFunction(func) {\r\n\t    return (typeof func) === 'function';\r\n\t}\r\n\texports.isFunction = isFunction;\r\n\t/**\r\n\t * Checks if the given argument is undefined.\r\n\t * @function\r\n\t */\r\n\tfunction isUndefined(obj) {\r\n\t    return (typeof obj) === 'undefined';\r\n\t}\r\n\texports.isUndefined = isUndefined;\r\n\t/**\r\n\t * Checks if the given argument is a string.\r\n\t * @function\r\n\t */\r\n\tfunction isString(obj) {\r\n\t    return Object.prototype.toString.call(obj) === '[object String]';\r\n\t}\r\n\texports.isString = isString;\r\n\t/**\r\n\t * Reverses a compare function.\r\n\t * @function\r\n\t */\r\n\tfunction reverseCompareFunction(compareFunction) {\r\n\t    if (!isFunction(compareFunction)) {\r\n\t        return function (a, b) {\r\n\t            if (a < b) {\r\n\t                return 1;\r\n\t            }\r\n\t            else if (a === b) {\r\n\t                return 0;\r\n\t            }\r\n\t            else {\r\n\t                return -1;\r\n\t            }\r\n\t        };\r\n\t    }\r\n\t    else {\r\n\t        return function (d, v) {\r\n\t            return compareFunction(d, v) * -1;\r\n\t        };\r\n\t    }\r\n\t}\r\n\texports.reverseCompareFunction = reverseCompareFunction;\r\n\t/**\r\n\t * Returns an equal function given a compare function.\r\n\t * @function\r\n\t */\r\n\tfunction compareToEquals(compareFunction) {\r\n\t    return function (a, b) {\r\n\t        return compareFunction(a, b) === 0;\r\n\t    };\r\n\t}\r\n\texports.compareToEquals = compareToEquals;\r\n\t//# sourceMappingURL=util.js.map\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar Dictionary_1 = __webpack_require__(9);\r\n\tvar Set_1 = __webpack_require__(10);\r\n\tvar Bag = (function () {\r\n\t    /**\r\n\t     * Creates an empty bag.\r\n\t     * @class <p>A bag is a special kind of set in which members are\r\n\t     * allowed to appear more than once.</p>\r\n\t     * <p>If the inserted elements are custom objects a function\r\n\t     * which converts elements to unique strings must be provided. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function petToString(pet) {\r\n\t     *  return pet.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     *\r\n\t     * @constructor\r\n\t     * @param {function(Object):string=} toStrFunction optional function used\r\n\t     * to convert elements to strings. If the elements aren't strings or if toString()\r\n\t     * is not appropriate, a custom function which receives an object and returns a\r\n\t     * unique string must be provided.\r\n\t     */\r\n\t    function Bag(toStrFunction) {\r\n\t        this.toStrF = toStrFunction || util.defaultToString;\r\n\t        this.dictionary = new Dictionary_1.default(this.toStrF);\r\n\t        this.nElements = 0;\r\n\t    }\r\n\t    /**\r\n\t    * Adds nCopies of the specified object to this bag.\r\n\t    * @param {Object} element element to add.\r\n\t    * @param {number=} nCopies the number of copies to add, if this argument is\r\n\t    * undefined 1 copy is added.\r\n\t    * @return {boolean} true unless element is undefined.\r\n\t    */\r\n\t    Bag.prototype.add = function (element, nCopies) {\r\n\t        if (nCopies === void 0) { nCopies = 1; }\r\n\t        if (util.isUndefined(element) || nCopies <= 0) {\r\n\t            return false;\r\n\t        }\r\n\t        if (!this.contains(element)) {\r\n\t            var node = {\r\n\t                value: element,\r\n\t                copies: nCopies\r\n\t            };\r\n\t            this.dictionary.setValue(element, node);\r\n\t        }\r\n\t        else {\r\n\t            this.dictionary.getValue(element).copies += nCopies;\r\n\t        }\r\n\t        this.nElements += nCopies;\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t    * Counts the number of copies of the specified object in this bag.\r\n\t    * @param {Object} element the object to search for..\r\n\t    * @return {number} the number of copies of the object, 0 if not found\r\n\t    */\r\n\t    Bag.prototype.count = function (element) {\r\n\t        if (!this.contains(element)) {\r\n\t            return 0;\r\n\t        }\r\n\t        else {\r\n\t            return this.dictionary.getValue(element).copies;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this bag contains the specified element.\r\n\t     * @param {Object} element element to search for.\r\n\t     * @return {boolean} true if this bag contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    Bag.prototype.contains = function (element) {\r\n\t        return this.dictionary.containsKey(element);\r\n\t    };\r\n\t    /**\r\n\t    * Removes nCopies of the specified object to this bag.\r\n\t    * If the number of copies to remove is greater than the actual number\r\n\t    * of copies in the Bag, all copies are removed.\r\n\t    * @param {Object} element element to remove.\r\n\t    * @param {number=} nCopies the number of copies to remove, if this argument is\r\n\t    * undefined 1 copy is removed.\r\n\t    * @return {boolean} true if at least 1 element was removed.\r\n\t    */\r\n\t    Bag.prototype.remove = function (element, nCopies) {\r\n\t        if (nCopies === void 0) { nCopies = 1; }\r\n\t        if (util.isUndefined(element) || nCopies <= 0) {\r\n\t            return false;\r\n\t        }\r\n\t        if (!this.contains(element)) {\r\n\t            return false;\r\n\t        }\r\n\t        else {\r\n\t            var node = this.dictionary.getValue(element);\r\n\t            if (nCopies > node.copies) {\r\n\t                this.nElements -= node.copies;\r\n\t            }\r\n\t            else {\r\n\t                this.nElements -= nCopies;\r\n\t            }\r\n\t            node.copies -= nCopies;\r\n\t            if (node.copies <= 0) {\r\n\t                this.dictionary.remove(element);\r\n\t            }\r\n\t            return true;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the elements in this big in arbitrary order,\r\n\t     * including multiple copies.\r\n\t     * @return {Array} an array containing all of the elements in this bag.\r\n\t     */\r\n\t    Bag.prototype.toArray = function () {\r\n\t        var a = [];\r\n\t        var values = this.dictionary.values();\r\n\t        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\r\n\t            var node = values_1[_i];\r\n\t            var element = node.value;\r\n\t            var copies = node.copies;\r\n\t            for (var j = 0; j < copies; j++) {\r\n\t                a.push(element);\r\n\t            }\r\n\t        }\r\n\t        return a;\r\n\t    };\r\n\t    /**\r\n\t     * Returns a set of unique elements in this bag.\r\n\t     * @return {collections.Set<T>} a set of unique elements in this bag.\r\n\t     */\r\n\t    Bag.prototype.toSet = function () {\r\n\t        var toret = new Set_1.default(this.toStrF);\r\n\t        var elements = this.dictionary.values();\r\n\t        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\r\n\t            var ele = elements_1[_i];\r\n\t            var value = ele.value;\r\n\t            toret.add(value);\r\n\t        }\r\n\t        return toret;\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element\r\n\t     * present in this bag, including multiple copies.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element. To break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    Bag.prototype.forEach = function (callback) {\r\n\t        this.dictionary.forEach(function (k, v) {\r\n\t            var value = v.value;\r\n\t            var copies = v.copies;\r\n\t            for (var i = 0; i < copies; i++) {\r\n\t                if (callback(value) === false) {\r\n\t                    return false;\r\n\t                }\r\n\t            }\r\n\t            return true;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this bag.\r\n\t     * @return {number} the number of elements in this bag.\r\n\t     */\r\n\t    Bag.prototype.size = function () {\r\n\t        return this.nElements;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this bag contains no elements.\r\n\t     * @return {boolean} true if this bag contains no elements.\r\n\t     */\r\n\t    Bag.prototype.isEmpty = function () {\r\n\t        return this.nElements === 0;\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this bag.\r\n\t     */\r\n\t    Bag.prototype.clear = function () {\r\n\t        this.nElements = 0;\r\n\t        this.dictionary.clear();\r\n\t    };\r\n\t    return Bag;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Bag; // End of bag\r\n\t//# sourceMappingURL=Bag.js.map\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar Dictionary = (function () {\r\n\t    /**\r\n\t     * Creates an empty dictionary.\r\n\t     * @class <p>Dictionaries map keys to values; each key can map to at most one value.\r\n\t     * This implementation accepts any kind of objects as keys.</p>\r\n\t     *\r\n\t     * <p>If the keys are custom objects a function which converts keys to unique\r\n\t     * strings must be provided. Example:</p>\r\n\t     * <pre>\r\n\t     * function petToString(pet) {\r\n\t     *  return pet.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @constructor\r\n\t     * @param {function(Object):string=} toStrFunction optional function used\r\n\t     * to convert keys to strings. If the keys aren't strings or if toString()\r\n\t     * is not appropriate, a custom function which receives a key and returns a\r\n\t     * unique string must be provided.\r\n\t     */\r\n\t    function Dictionary(toStrFunction) {\r\n\t        this.table = {};\r\n\t        this.nElements = 0;\r\n\t        this.toStr = toStrFunction || util.defaultToString;\r\n\t    }\r\n\t    /**\r\n\t     * Returns the value to which this dictionary maps the specified key.\r\n\t     * Returns undefined if this dictionary contains no mapping for this key.\r\n\t     * @param {Object} key key whose associated value is to be returned.\r\n\t     * @return {*} the value to which this dictionary maps the specified key or\r\n\t     * undefined if the map contains no mapping for this key.\r\n\t     */\r\n\t    Dictionary.prototype.getValue = function (key) {\r\n\t        var pair = this.table['$' + this.toStr(key)];\r\n\t        if (util.isUndefined(pair)) {\r\n\t            return undefined;\r\n\t        }\r\n\t        return pair.value;\r\n\t    };\r\n\t    /**\r\n\t     * Associates the specified value with the specified key in this dictionary.\r\n\t     * If the dictionary previously contained a mapping for this key, the old\r\n\t     * value is replaced by the specified value.\r\n\t     * @param {Object} key key with which the specified value is to be\r\n\t     * associated.\r\n\t     * @param {Object} value value to be associated with the specified key.\r\n\t     * @return {*} previous value associated with the specified key, or undefined if\r\n\t     * there was no mapping for the key or if the key/value are undefined.\r\n\t     */\r\n\t    Dictionary.prototype.setValue = function (key, value) {\r\n\t        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n\t            return undefined;\r\n\t        }\r\n\t        var ret;\r\n\t        var k = '$' + this.toStr(key);\r\n\t        var previousElement = this.table[k];\r\n\t        if (util.isUndefined(previousElement)) {\r\n\t            this.nElements++;\r\n\t            ret = undefined;\r\n\t        }\r\n\t        else {\r\n\t            ret = previousElement.value;\r\n\t        }\r\n\t        this.table[k] = {\r\n\t            key: key,\r\n\t            value: value\r\n\t        };\r\n\t        return ret;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the mapping for this key from this dictionary if it is present.\r\n\t     * @param {Object} key key whose mapping is to be removed from the\r\n\t     * dictionary.\r\n\t     * @return {*} previous value associated with specified key, or undefined if\r\n\t     * there was no mapping for key.\r\n\t     */\r\n\t    Dictionary.prototype.remove = function (key) {\r\n\t        var k = '$' + this.toStr(key);\r\n\t        var previousElement = this.table[k];\r\n\t        if (!util.isUndefined(previousElement)) {\r\n\t            delete this.table[k];\r\n\t            this.nElements--;\r\n\t            return previousElement.value;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the keys in this dictionary.\r\n\t     * @return {Array} an array containing all of the keys in this dictionary.\r\n\t     */\r\n\t    Dictionary.prototype.keys = function () {\r\n\t        var array = [];\r\n\t        for (var name_1 in this.table) {\r\n\t            if (util.has(this.table, name_1)) {\r\n\t                var pair = this.table[name_1];\r\n\t                array.push(pair.key);\r\n\t            }\r\n\t        }\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the values in this dictionary.\r\n\t     * @return {Array} an array containing all of the values in this dictionary.\r\n\t     */\r\n\t    Dictionary.prototype.values = function () {\r\n\t        var array = [];\r\n\t        for (var name_2 in this.table) {\r\n\t            if (util.has(this.table, name_2)) {\r\n\t                var pair = this.table[name_2];\r\n\t                array.push(pair.value);\r\n\t            }\r\n\t        }\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t    * Executes the provided function once for each key-value pair\r\n\t    * present in this dictionary.\r\n\t    * @param {function(Object,Object):*} callback function to execute, it is\r\n\t    * invoked with two arguments: key and value. To break the iteration you can\r\n\t    * optionally return false.\r\n\t    */\r\n\t    Dictionary.prototype.forEach = function (callback) {\r\n\t        for (var name_3 in this.table) {\r\n\t            if (util.has(this.table, name_3)) {\r\n\t                var pair = this.table[name_3];\r\n\t                var ret = callback(pair.key, pair.value);\r\n\t                if (ret === false) {\r\n\t                    return;\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this dictionary contains a mapping for the specified key.\r\n\t     * @param {Object} key key whose presence in this dictionary is to be\r\n\t     * tested.\r\n\t     * @return {boolean} true if this dictionary contains a mapping for the\r\n\t     * specified key.\r\n\t     */\r\n\t    Dictionary.prototype.containsKey = function (key) {\r\n\t        return !util.isUndefined(this.getValue(key));\r\n\t    };\r\n\t    /**\r\n\t    * Removes all mappings from this dictionary.\r\n\t    * @this {collections.Dictionary}\r\n\t    */\r\n\t    Dictionary.prototype.clear = function () {\r\n\t        this.table = {};\r\n\t        this.nElements = 0;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of keys in this dictionary.\r\n\t     * @return {number} the number of key-value mappings in this dictionary.\r\n\t     */\r\n\t    Dictionary.prototype.size = function () {\r\n\t        return this.nElements;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this dictionary contains no mappings.\r\n\t     * @return {boolean} true if this dictionary contains no mappings.\r\n\t     */\r\n\t    Dictionary.prototype.isEmpty = function () {\r\n\t        return this.nElements <= 0;\r\n\t    };\r\n\t    Dictionary.prototype.toString = function () {\r\n\t        var toret = '{';\r\n\t        this.forEach(function (k, v) {\r\n\t            toret += \"\\n\\t\" + k + \" : \" + v;\r\n\t        });\r\n\t        return toret + '\\n}';\r\n\t    };\r\n\t    return Dictionary;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Dictionary; // End of dictionary\r\n\t//# sourceMappingURL=Dictionary.js.map\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar arrays = __webpack_require__(6);\r\n\tvar Dictionary_1 = __webpack_require__(9);\r\n\tvar Set = (function () {\r\n\t    /**\r\n\t     * Creates an empty set.\r\n\t     * @class <p>A set is a data structure that contains no duplicate items.</p>\r\n\t     * <p>If the inserted elements are custom objects a function\r\n\t     * which converts elements to strings must be provided. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function petToString(pet) {\r\n\t     *  return pet.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     *\r\n\t     * @constructor\r\n\t     * @param {function(Object):string=} toStringFunction optional function used\r\n\t     * to convert elements to strings. If the elements aren't strings or if toString()\r\n\t     * is not appropriate, a custom function which receives a onject and returns a\r\n\t     * unique string must be provided.\r\n\t     */\r\n\t    function Set(toStringFunction) {\r\n\t        this.dictionary = new Dictionary_1.default(toStringFunction);\r\n\t    }\r\n\t    /**\r\n\t     * Returns true if this set contains the specified element.\r\n\t     * @param {Object} element element to search for.\r\n\t     * @return {boolean} true if this set contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    Set.prototype.contains = function (element) {\r\n\t        return this.dictionary.containsKey(element);\r\n\t    };\r\n\t    /**\r\n\t     * Adds the specified element to this set if it is not already present.\r\n\t     * @param {Object} element the element to insert.\r\n\t     * @return {boolean} true if this set did not already contain the specified element.\r\n\t     */\r\n\t    Set.prototype.add = function (element) {\r\n\t        if (this.contains(element) || util.isUndefined(element)) {\r\n\t            return false;\r\n\t        }\r\n\t        else {\r\n\t            this.dictionary.setValue(element, element);\r\n\t            return true;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Performs an intersecion between this an another set.\r\n\t     * Removes all values that are not present this set and the given set.\r\n\t     * @param {collections.Set} otherSet other set.\r\n\t     */\r\n\t    Set.prototype.intersection = function (otherSet) {\r\n\t        var set = this;\r\n\t        this.forEach(function (element) {\r\n\t            if (!otherSet.contains(element)) {\r\n\t                set.remove(element);\r\n\t            }\r\n\t            return true;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Performs a union between this an another set.\r\n\t     * Adds all values from the given set to this set.\r\n\t     * @param {collections.Set} otherSet other set.\r\n\t     */\r\n\t    Set.prototype.union = function (otherSet) {\r\n\t        var set = this;\r\n\t        otherSet.forEach(function (element) {\r\n\t            set.add(element);\r\n\t            return true;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Performs a difference between this an another set.\r\n\t     * Removes from this set all the values that are present in the given set.\r\n\t     * @param {collections.Set} otherSet other set.\r\n\t     */\r\n\t    Set.prototype.difference = function (otherSet) {\r\n\t        var set = this;\r\n\t        otherSet.forEach(function (element) {\r\n\t            set.remove(element);\r\n\t            return true;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Checks whether the given set contains all the elements in this set.\r\n\t     * @param {collections.Set} otherSet other set.\r\n\t     * @return {boolean} true if this set is a subset of the given set.\r\n\t     */\r\n\t    Set.prototype.isSubsetOf = function (otherSet) {\r\n\t        if (this.size() > otherSet.size()) {\r\n\t            return false;\r\n\t        }\r\n\t        var isSub = true;\r\n\t        this.forEach(function (element) {\r\n\t            if (!otherSet.contains(element)) {\r\n\t                isSub = false;\r\n\t                return false;\r\n\t            }\r\n\t            return true;\r\n\t        });\r\n\t        return isSub;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the specified element from this set if it is present.\r\n\t     * @return {boolean} true if this set contained the specified element.\r\n\t     */\r\n\t    Set.prototype.remove = function (element) {\r\n\t        if (!this.contains(element)) {\r\n\t            return false;\r\n\t        }\r\n\t        else {\r\n\t            this.dictionary.remove(element);\r\n\t            return true;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element\r\n\t     * present in this set.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one arguments: the element. To break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    Set.prototype.forEach = function (callback) {\r\n\t        this.dictionary.forEach(function (k, v) {\r\n\t            return callback(v);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the elements in this set in arbitrary order.\r\n\t     * @return {Array} an array containing all of the elements in this set.\r\n\t     */\r\n\t    Set.prototype.toArray = function () {\r\n\t        return this.dictionary.values();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this set contains no elements.\r\n\t     * @return {boolean} true if this set contains no elements.\r\n\t     */\r\n\t    Set.prototype.isEmpty = function () {\r\n\t        return this.dictionary.isEmpty();\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this set.\r\n\t     * @return {number} the number of elements in this set.\r\n\t     */\r\n\t    Set.prototype.size = function () {\r\n\t        return this.dictionary.size();\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this set.\r\n\t     */\r\n\t    Set.prototype.clear = function () {\r\n\t        this.dictionary.clear();\r\n\t    };\r\n\t    /*\r\n\t    * Provides a string representation for display\r\n\t    */\r\n\t    Set.prototype.toString = function () {\r\n\t        return arrays.toString(this.toArray());\r\n\t    };\r\n\t    return Set;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Set; // end of Set\r\n\t//# sourceMappingURL=Set.js.map\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar Queue_1 = __webpack_require__(12);\r\n\tvar BSTree = (function () {\r\n\t    /**\r\n\t     * Creates an empty binary search tree.\r\n\t     * @class <p>A binary search tree is a binary tree in which each\r\n\t     * internal node stores an element such that the elements stored in the\r\n\t     * left subtree are less than it and the elements\r\n\t     * stored in the right subtree are greater.</p>\r\n\t     * <p>Formally, a binary search tree is a node-based binary tree data structure which\r\n\t     * has the following properties:</p>\r\n\t     * <ul>\r\n\t     * <li>The left subtree of a node contains only nodes with elements less\r\n\t     * than the node's element</li>\r\n\t     * <li>The right subtree of a node contains only nodes with elements greater\r\n\t     * than the node's element</li>\r\n\t     * <li>Both the left and right subtrees must also be binary search trees.</li>\r\n\t     * </ul>\r\n\t     * <p>If the inserted elements are custom objects a compare function must\r\n\t     * be provided at construction time, otherwise the <=, === and >= operators are\r\n\t     * used to compare elements. Example:</p>\r\n\t     * <pre>\r\n\t     * function compare(a, b) {\r\n\t     *  if (a is less than b by some ordering criterion) {\r\n\t     *     return -1;\r\n\t     *  } if (a is greater than b by the ordering criterion) {\r\n\t     *     return 1;\r\n\t     *  }\r\n\t     *  // a must be equal to b\r\n\t     *  return 0;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @constructor\r\n\t     * @param {function(Object,Object):number=} compareFunction optional\r\n\t     * function used to compare two elements. Must return a negative integer,\r\n\t     * zero, or a positive integer as the first argument is less than, equal to,\r\n\t     * or greater than the second.\r\n\t     */\r\n\t    function BSTree(compareFunction) {\r\n\t        this.root = null;\r\n\t        this.compare = compareFunction || util.defaultCompare;\r\n\t        this.nElements = 0;\r\n\t    }\r\n\t    /**\r\n\t     * Adds the specified element to this tree if it is not already present.\r\n\t     * @param {Object} element the element to insert.\r\n\t     * @return {boolean} true if this tree did not already contain the specified element.\r\n\t     */\r\n\t    BSTree.prototype.add = function (element) {\r\n\t        if (util.isUndefined(element)) {\r\n\t            return false;\r\n\t        }\r\n\t        if (this.insertNode(this.createNode(element)) !== null) {\r\n\t            this.nElements++;\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this tree.\r\n\t     */\r\n\t    BSTree.prototype.clear = function () {\r\n\t        this.root = null;\r\n\t        this.nElements = 0;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this tree contains no elements.\r\n\t     * @return {boolean} true if this tree contains no elements.\r\n\t     */\r\n\t    BSTree.prototype.isEmpty = function () {\r\n\t        return this.nElements === 0;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this tree.\r\n\t     * @return {number} the number of elements in this tree.\r\n\t     */\r\n\t    BSTree.prototype.size = function () {\r\n\t        return this.nElements;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this tree contains the specified element.\r\n\t     * @param {Object} element element to search for.\r\n\t     * @return {boolean} true if this tree contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    BSTree.prototype.contains = function (element) {\r\n\t        if (util.isUndefined(element)) {\r\n\t            return false;\r\n\t        }\r\n\t        return this.searchNode(this.root, element) !== null;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the specified element from this tree if it is present.\r\n\t     * @return {boolean} true if this tree contained the specified element.\r\n\t     */\r\n\t    BSTree.prototype.remove = function (element) {\r\n\t        var node = this.searchNode(this.root, element);\r\n\t        if (node === null) {\r\n\t            return false;\r\n\t        }\r\n\t        this.removeNode(node);\r\n\t        this.nElements--;\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this tree in\r\n\t     * in-order.\r\n\t     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n\t     * argument: the element value, to break the iteration you can optionally return false.\r\n\t     */\r\n\t    BSTree.prototype.inorderTraversal = function (callback) {\r\n\t        this.inorderTraversalAux(this.root, callback, {\r\n\t            stop: false\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this tree in pre-order.\r\n\t     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n\t     * argument: the element value, to break the iteration you can optionally return false.\r\n\t     */\r\n\t    BSTree.prototype.preorderTraversal = function (callback) {\r\n\t        this.preorderTraversalAux(this.root, callback, {\r\n\t            stop: false\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this tree in post-order.\r\n\t     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n\t     * argument: the element value, to break the iteration you can optionally return false.\r\n\t     */\r\n\t    BSTree.prototype.postorderTraversal = function (callback) {\r\n\t        this.postorderTraversalAux(this.root, callback, {\r\n\t            stop: false\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this tree in\r\n\t     * level-order.\r\n\t     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n\t     * argument: the element value, to break the iteration you can optionally return false.\r\n\t     */\r\n\t    BSTree.prototype.levelTraversal = function (callback) {\r\n\t        this.levelTraversalAux(this.root, callback);\r\n\t    };\r\n\t    /**\r\n\t     * Returns the minimum element of this tree.\r\n\t     * @return {*} the minimum element of this tree or undefined if this tree is\r\n\t     * is empty.\r\n\t     */\r\n\t    BSTree.prototype.minimum = function () {\r\n\t        if (this.isEmpty()) {\r\n\t            return undefined;\r\n\t        }\r\n\t        return this.minimumAux(this.root).element;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the maximum element of this tree.\r\n\t     * @return {*} the maximum element of this tree or undefined if this tree is\r\n\t     * is empty.\r\n\t     */\r\n\t    BSTree.prototype.maximum = function () {\r\n\t        if (this.isEmpty()) {\r\n\t            return undefined;\r\n\t        }\r\n\t        return this.maximumAux(this.root).element;\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this tree in inorder.\r\n\t     * Equivalent to inorderTraversal.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    BSTree.prototype.forEach = function (callback) {\r\n\t        this.inorderTraversal(callback);\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the elements in this tree in in-order.\r\n\t     * @return {Array} an array containing all of the elements in this tree in in-order.\r\n\t     */\r\n\t    BSTree.prototype.toArray = function () {\r\n\t        var array = [];\r\n\t        this.inorderTraversal(function (element) {\r\n\t            array.push(element);\r\n\t            return true;\r\n\t        });\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the height of this tree.\r\n\t     * @return {number} the height of this tree or -1 if is empty.\r\n\t     */\r\n\t    BSTree.prototype.height = function () {\r\n\t        return this.heightAux(this.root);\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.searchNode = function (node, element) {\r\n\t        var cmp = null;\r\n\t        while (node !== null && cmp !== 0) {\r\n\t            cmp = this.compare(element, node.element);\r\n\t            if (cmp < 0) {\r\n\t                node = node.leftCh;\r\n\t            }\r\n\t            else if (cmp > 0) {\r\n\t                node = node.rightCh;\r\n\t            }\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.transplant = function (n1, n2) {\r\n\t        if (n1.parent === null) {\r\n\t            this.root = n2;\r\n\t        }\r\n\t        else if (n1 === n1.parent.leftCh) {\r\n\t            n1.parent.leftCh = n2;\r\n\t        }\r\n\t        else {\r\n\t            n1.parent.rightCh = n2;\r\n\t        }\r\n\t        if (n2 !== null) {\r\n\t            n2.parent = n1.parent;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.removeNode = function (node) {\r\n\t        if (node.leftCh === null) {\r\n\t            this.transplant(node, node.rightCh);\r\n\t        }\r\n\t        else if (node.rightCh === null) {\r\n\t            this.transplant(node, node.leftCh);\r\n\t        }\r\n\t        else {\r\n\t            var y = this.minimumAux(node.rightCh);\r\n\t            if (y.parent !== node) {\r\n\t                this.transplant(y, y.rightCh);\r\n\t                y.rightCh = node.rightCh;\r\n\t                y.rightCh.parent = y;\r\n\t            }\r\n\t            this.transplant(node, y);\r\n\t            y.leftCh = node.leftCh;\r\n\t            y.leftCh.parent = y;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.inorderTraversalAux = function (node, callback, signal) {\r\n\t        if (node === null || signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.inorderTraversalAux(node.leftCh, callback, signal);\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        signal.stop = callback(node.element) === false;\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.inorderTraversalAux(node.rightCh, callback, signal);\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.levelTraversalAux = function (node, callback) {\r\n\t        var queue = new Queue_1.default();\r\n\t        if (node !== null) {\r\n\t            queue.enqueue(node);\r\n\t        }\r\n\t        while (!queue.isEmpty()) {\r\n\t            node = queue.dequeue();\r\n\t            if (callback(node.element) === false) {\r\n\t                return;\r\n\t            }\r\n\t            if (node.leftCh !== null) {\r\n\t                queue.enqueue(node.leftCh);\r\n\t            }\r\n\t            if (node.rightCh !== null) {\r\n\t                queue.enqueue(node.rightCh);\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.preorderTraversalAux = function (node, callback, signal) {\r\n\t        if (node === null || signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        signal.stop = callback(node.element) === false;\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.preorderTraversalAux(node.leftCh, callback, signal);\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.preorderTraversalAux(node.rightCh, callback, signal);\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.postorderTraversalAux = function (node, callback, signal) {\r\n\t        if (node === null || signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.postorderTraversalAux(node.leftCh, callback, signal);\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        this.postorderTraversalAux(node.rightCh, callback, signal);\r\n\t        if (signal.stop) {\r\n\t            return;\r\n\t        }\r\n\t        signal.stop = callback(node.element) === false;\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.minimumAux = function (node) {\r\n\t        while (node.leftCh !== null) {\r\n\t            node = node.leftCh;\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.maximumAux = function (node) {\r\n\t        while (node.rightCh !== null) {\r\n\t            node = node.rightCh;\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t      * @private\r\n\t      */\r\n\t    BSTree.prototype.heightAux = function (node) {\r\n\t        if (node === null) {\r\n\t            return -1;\r\n\t        }\r\n\t        return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;\r\n\t    };\r\n\t    /*\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.insertNode = function (node) {\r\n\t        var parent = null;\r\n\t        var position = this.root;\r\n\t        var cmp = null;\r\n\t        while (position !== null) {\r\n\t            cmp = this.compare(node.element, position.element);\r\n\t            if (cmp === 0) {\r\n\t                return null;\r\n\t            }\r\n\t            else if (cmp < 0) {\r\n\t                parent = position;\r\n\t                position = position.leftCh;\r\n\t            }\r\n\t            else {\r\n\t                parent = position;\r\n\t                position = position.rightCh;\r\n\t            }\r\n\t        }\r\n\t        node.parent = parent;\r\n\t        if (parent === null) {\r\n\t            // tree is empty\r\n\t            this.root = node;\r\n\t        }\r\n\t        else if (this.compare(node.element, parent.element) < 0) {\r\n\t            parent.leftCh = node;\r\n\t        }\r\n\t        else {\r\n\t            parent.rightCh = node;\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    BSTree.prototype.createNode = function (element) {\r\n\t        return {\r\n\t            element: element,\r\n\t            leftCh: null,\r\n\t            rightCh: null,\r\n\t            parent: null\r\n\t        };\r\n\t    };\r\n\t    return BSTree;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = BSTree;\r\n\t//# sourceMappingURL=BSTree.js.map\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar LinkedList_1 = __webpack_require__(13);\r\n\tvar Queue = (function () {\r\n\t    /**\r\n\t     * Creates an empty queue.\r\n\t     * @class A queue is a First-In-First-Out (FIFO) data structure, the first\r\n\t     * element added to the queue will be the first one to be removed. This\r\n\t     * implementation uses a linked list as a container.\r\n\t     * @constructor\r\n\t     */\r\n\t    function Queue() {\r\n\t        this.list = new LinkedList_1.default();\r\n\t    }\r\n\t    /**\r\n\t     * Inserts the specified element into the end of this queue.\r\n\t     * @param {Object} elem the element to insert.\r\n\t     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n\t     */\r\n\t    Queue.prototype.enqueue = function (elem) {\r\n\t        return this.list.add(elem);\r\n\t    };\r\n\t    /**\r\n\t     * Inserts the specified element into the end of this queue.\r\n\t     * @param {Object} elem the element to insert.\r\n\t     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n\t     */\r\n\t    Queue.prototype.add = function (elem) {\r\n\t        return this.list.add(elem);\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves and removes the head of this queue.\r\n\t     * @return {*} the head of this queue, or undefined if this queue is empty.\r\n\t     */\r\n\t    Queue.prototype.dequeue = function () {\r\n\t        if (this.list.size() !== 0) {\r\n\t            var el = this.list.first();\r\n\t            this.list.removeElementAtIndex(0);\r\n\t            return el;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves, but does not remove, the head of this queue.\r\n\t     * @return {*} the head of this queue, or undefined if this queue is empty.\r\n\t     */\r\n\t    Queue.prototype.peek = function () {\r\n\t        if (this.list.size() !== 0) {\r\n\t            return this.list.first();\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this queue.\r\n\t     * @return {number} the number of elements in this queue.\r\n\t     */\r\n\t    Queue.prototype.size = function () {\r\n\t        return this.list.size();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this queue contains the specified element.\r\n\t     * <p>If the elements inside this stack are\r\n\t     * not comparable with the === operator, a custom equals function should be\r\n\t     * provided to perform searches, the function must receive two arguments and\r\n\t     * return true if they are equal, false otherwise. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * const petsAreEqualByName (pet1, pet2) {\r\n\t     *  return pet1.name === pet2.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @param {Object} elem element to search for.\r\n\t     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n\t     * function to check if two elements are equal.\r\n\t     * @return {boolean} true if this queue contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    Queue.prototype.contains = function (elem, equalsFunction) {\r\n\t        return this.list.contains(elem, equalsFunction);\r\n\t    };\r\n\t    /**\r\n\t     * Checks if this queue is empty.\r\n\t     * @return {boolean} true if and only if this queue contains no items; false\r\n\t     * otherwise.\r\n\t     */\r\n\t    Queue.prototype.isEmpty = function () {\r\n\t        return this.list.size() <= 0;\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this queue.\r\n\t     */\r\n\t    Queue.prototype.clear = function () {\r\n\t        this.list.clear();\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this queue in\r\n\t     * FIFO order.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    Queue.prototype.forEach = function (callback) {\r\n\t        this.list.forEach(callback);\r\n\t    };\r\n\t    return Queue;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Queue; // End of queue\r\n\t//# sourceMappingURL=Queue.js.map\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar arrays = __webpack_require__(6);\r\n\tvar LinkedList = (function () {\r\n\t    /**\r\n\t    * Creates an empty Linked List.\r\n\t    * @class A linked list is a data structure consisting of a group of nodes\r\n\t    * which together represent a sequence.\r\n\t    * @constructor\r\n\t    */\r\n\t    function LinkedList() {\r\n\t        /**\r\n\t        * First node in the list\r\n\t        * @type {Object}\r\n\t        * @private\r\n\t        */\r\n\t        this.firstNode = null;\r\n\t        /**\r\n\t        * Last node in the list\r\n\t        * @type {Object}\r\n\t        * @private\r\n\t        */\r\n\t        this.lastNode = null;\r\n\t        /**\r\n\t        * Number of elements in the list\r\n\t        * @type {number}\r\n\t        * @private\r\n\t        */\r\n\t        this.nElements = 0;\r\n\t    }\r\n\t    /**\r\n\t    * Adds an element to this list.\r\n\t    * @param {Object} item element to be added.\r\n\t    * @param {number=} index optional index to add the element. If no index is specified\r\n\t    * the element is added to the end of this list.\r\n\t    * @return {boolean} true if the element was added or false if the index is invalid\r\n\t    * or if the element is undefined.\r\n\t    */\r\n\t    LinkedList.prototype.add = function (item, index) {\r\n\t        if (util.isUndefined(index)) {\r\n\t            index = this.nElements;\r\n\t        }\r\n\t        if (index < 0 || index > this.nElements || util.isUndefined(item)) {\r\n\t            return false;\r\n\t        }\r\n\t        var newNode = this.createNode(item);\r\n\t        if (this.nElements === 0) {\r\n\t            // First node in the list.\r\n\t            this.firstNode = newNode;\r\n\t            this.lastNode = newNode;\r\n\t        }\r\n\t        else if (index === this.nElements) {\r\n\t            // Insert at the end.\r\n\t            this.lastNode.next = newNode;\r\n\t            this.lastNode = newNode;\r\n\t        }\r\n\t        else if (index === 0) {\r\n\t            // Change first node.\r\n\t            newNode.next = this.firstNode;\r\n\t            this.firstNode = newNode;\r\n\t        }\r\n\t        else {\r\n\t            var prev = this.nodeAtIndex(index - 1);\r\n\t            newNode.next = prev.next;\r\n\t            prev.next = newNode;\r\n\t        }\r\n\t        this.nElements++;\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t    * Returns the first element in this list.\r\n\t    * @return {*} the first element of the list or undefined if the list is\r\n\t    * empty.\r\n\t    */\r\n\t    LinkedList.prototype.first = function () {\r\n\t        if (this.firstNode !== null) {\r\n\t            return this.firstNode.element;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t    * Returns the last element in this list.\r\n\t    * @return {*} the last element in the list or undefined if the list is\r\n\t    * empty.\r\n\t    */\r\n\t    LinkedList.prototype.last = function () {\r\n\t        if (this.lastNode !== null) {\r\n\t            return this.lastNode.element;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the element at the specified position in this list.\r\n\t     * @param {number} index desired index.\r\n\t     * @return {*} the element at the given index or undefined if the index is\r\n\t     * out of bounds.\r\n\t     */\r\n\t    LinkedList.prototype.elementAtIndex = function (index) {\r\n\t        var node = this.nodeAtIndex(index);\r\n\t        if (node === null) {\r\n\t            return undefined;\r\n\t        }\r\n\t        return node.element;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the index in this list of the first occurrence of the\r\n\t     * specified element, or -1 if the List does not contain this element.\r\n\t     * <p>If the elements inside this list are\r\n\t     * not comparable with the === operator a custom equals function should be\r\n\t     * provided to perform searches, the function must receive two arguments and\r\n\t     * return true if they are equal, false otherwise. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * const petsAreEqualByName = function(pet1, pet2) {\r\n\t     *  return pet1.name === pet2.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @param {Object} item element to search for.\r\n\t     * @param {function(Object,Object):boolean=} equalsFunction Optional\r\n\t     * function used to check if two elements are equal.\r\n\t     * @return {number} the index in this list of the first occurrence\r\n\t     * of the specified element, or -1 if this list does not contain the\r\n\t     * element.\r\n\t     */\r\n\t    LinkedList.prototype.indexOf = function (item, equalsFunction) {\r\n\t        var equalsF = equalsFunction || util.defaultEquals;\r\n\t        if (util.isUndefined(item)) {\r\n\t            return -1;\r\n\t        }\r\n\t        var currentNode = this.firstNode;\r\n\t        var index = 0;\r\n\t        while (currentNode !== null) {\r\n\t            if (equalsF(currentNode.element, item)) {\r\n\t                return index;\r\n\t            }\r\n\t            index++;\r\n\t            currentNode = currentNode.next;\r\n\t        }\r\n\t        return -1;\r\n\t    };\r\n\t    /**\r\n\t       * Returns true if this list contains the specified element.\r\n\t       * <p>If the elements inside the list are\r\n\t       * not comparable with the === operator a custom equals function should be\r\n\t       * provided to perform searches, the function must receive two arguments and\r\n\t       * return true if they are equal, false otherwise. Example:</p>\r\n\t       *\r\n\t       * <pre>\r\n\t       * const petsAreEqualByName = function(pet1, pet2) {\r\n\t       *  return pet1.name === pet2.name;\r\n\t       * }\r\n\t       * </pre>\r\n\t       * @param {Object} item element to search for.\r\n\t       * @param {function(Object,Object):boolean=} equalsFunction Optional\r\n\t       * function used to check if two elements are equal.\r\n\t       * @return {boolean} true if this list contains the specified element, false\r\n\t       * otherwise.\r\n\t       */\r\n\t    LinkedList.prototype.contains = function (item, equalsFunction) {\r\n\t        return (this.indexOf(item, equalsFunction) >= 0);\r\n\t    };\r\n\t    /**\r\n\t     * Removes the first occurrence of the specified element in this list.\r\n\t     * <p>If the elements inside the list are\r\n\t     * not comparable with the === operator a custom equals function should be\r\n\t     * provided to perform searches, the function must receive two arguments and\r\n\t     * return true if they are equal, false otherwise. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * const petsAreEqualByName = function(pet1, pet2) {\r\n\t     *  return pet1.name === pet2.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @param {Object} item element to be removed from this list, if present.\r\n\t     * @return {boolean} true if the list contained the specified element.\r\n\t     */\r\n\t    LinkedList.prototype.remove = function (item, equalsFunction) {\r\n\t        var equalsF = equalsFunction || util.defaultEquals;\r\n\t        if (this.nElements < 1 || util.isUndefined(item)) {\r\n\t            return false;\r\n\t        }\r\n\t        var previous = null;\r\n\t        var currentNode = this.firstNode;\r\n\t        while (currentNode !== null) {\r\n\t            if (equalsF(currentNode.element, item)) {\r\n\t                if (currentNode === this.firstNode) {\r\n\t                    this.firstNode = this.firstNode.next;\r\n\t                    if (currentNode === this.lastNode) {\r\n\t                        this.lastNode = null;\r\n\t                    }\r\n\t                }\r\n\t                else if (currentNode === this.lastNode) {\r\n\t                    this.lastNode = previous;\r\n\t                    previous.next = currentNode.next;\r\n\t                    currentNode.next = null;\r\n\t                }\r\n\t                else {\r\n\t                    previous.next = currentNode.next;\r\n\t                    currentNode.next = null;\r\n\t                }\r\n\t                this.nElements--;\r\n\t                return true;\r\n\t            }\r\n\t            previous = currentNode;\r\n\t            currentNode = currentNode.next;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this list.\r\n\t     */\r\n\t    LinkedList.prototype.clear = function () {\r\n\t        this.firstNode = null;\r\n\t        this.lastNode = null;\r\n\t        this.nElements = 0;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this list is equal to the given list.\r\n\t     * Two lists are equal if they have the same elements in the same order.\r\n\t     * @param {LinkedList} other the other list.\r\n\t     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n\t     * function used to check if two elements are equal. If the elements in the lists\r\n\t     * are custom objects you should provide a function, otherwise\r\n\t     * the === operator is used to check equality between elements.\r\n\t     * @return {boolean} true if this list is equal to the given list.\r\n\t     */\r\n\t    LinkedList.prototype.equals = function (other, equalsFunction) {\r\n\t        var eqF = equalsFunction || util.defaultEquals;\r\n\t        if (!(other instanceof LinkedList)) {\r\n\t            return false;\r\n\t        }\r\n\t        if (this.size() !== other.size()) {\r\n\t            return false;\r\n\t        }\r\n\t        return this.equalsAux(this.firstNode, other.firstNode, eqF);\r\n\t    };\r\n\t    /**\r\n\t    * @private\r\n\t    */\r\n\t    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {\r\n\t        while (n1 !== null) {\r\n\t            if (!eqF(n1.element, n2.element)) {\r\n\t                return false;\r\n\t            }\r\n\t            n1 = n1.next;\r\n\t            n2 = n2.next;\r\n\t        }\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the element at the specified position in this list.\r\n\t     * @param {number} index given index.\r\n\t     * @return {*} removed element or undefined if the index is out of bounds.\r\n\t     */\r\n\t    LinkedList.prototype.removeElementAtIndex = function (index) {\r\n\t        if (index < 0 || index >= this.nElements) {\r\n\t            return undefined;\r\n\t        }\r\n\t        var element;\r\n\t        if (this.nElements === 1) {\r\n\t            //First node in the list.\r\n\t            element = this.firstNode.element;\r\n\t            this.firstNode = null;\r\n\t            this.lastNode = null;\r\n\t        }\r\n\t        else {\r\n\t            var previous = this.nodeAtIndex(index - 1);\r\n\t            if (previous === null) {\r\n\t                element = this.firstNode.element;\r\n\t                this.firstNode = this.firstNode.next;\r\n\t            }\r\n\t            else if (previous.next === this.lastNode) {\r\n\t                element = this.lastNode.element;\r\n\t                this.lastNode = previous;\r\n\t            }\r\n\t            if (previous !== null) {\r\n\t                element = previous.next.element;\r\n\t                previous.next = previous.next.next;\r\n\t            }\r\n\t        }\r\n\t        this.nElements--;\r\n\t        return element;\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this list in order.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    LinkedList.prototype.forEach = function (callback) {\r\n\t        var currentNode = this.firstNode;\r\n\t        while (currentNode !== null) {\r\n\t            if (callback(currentNode.element) === false) {\r\n\t                break;\r\n\t            }\r\n\t            currentNode = currentNode.next;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Reverses the order of the elements in this linked list (makes the last\r\n\t     * element first, and the first element last).\r\n\t     */\r\n\t    LinkedList.prototype.reverse = function () {\r\n\t        var previous = null;\r\n\t        var current = this.firstNode;\r\n\t        var temp = null;\r\n\t        while (current !== null) {\r\n\t            temp = current.next;\r\n\t            current.next = previous;\r\n\t            previous = current;\r\n\t            current = temp;\r\n\t        }\r\n\t        temp = this.firstNode;\r\n\t        this.firstNode = this.lastNode;\r\n\t        this.lastNode = temp;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the elements in this list in proper\r\n\t     * sequence.\r\n\t     * @return {Array.<*>} an array containing all of the elements in this list,\r\n\t     * in proper sequence.\r\n\t     */\r\n\t    LinkedList.prototype.toArray = function () {\r\n\t        var array = [];\r\n\t        var currentNode = this.firstNode;\r\n\t        while (currentNode !== null) {\r\n\t            array.push(currentNode.element);\r\n\t            currentNode = currentNode.next;\r\n\t        }\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this list.\r\n\t     * @return {number} the number of elements in this list.\r\n\t     */\r\n\t    LinkedList.prototype.size = function () {\r\n\t        return this.nElements;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this list contains no elements.\r\n\t     * @return {boolean} true if this list contains no elements.\r\n\t     */\r\n\t    LinkedList.prototype.isEmpty = function () {\r\n\t        return this.nElements <= 0;\r\n\t    };\r\n\t    LinkedList.prototype.toString = function () {\r\n\t        return arrays.toString(this.toArray());\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    LinkedList.prototype.nodeAtIndex = function (index) {\r\n\t        if (index < 0 || index >= this.nElements) {\r\n\t            return null;\r\n\t        }\r\n\t        if (index === (this.nElements - 1)) {\r\n\t            return this.lastNode;\r\n\t        }\r\n\t        var node = this.firstNode;\r\n\t        for (var i = 0; i < index; i++) {\r\n\t            node = node.next;\r\n\t        }\r\n\t        return node;\r\n\t    };\r\n\t    /**\r\n\t     * @private\r\n\t     */\r\n\t    LinkedList.prototype.createNode = function (item) {\r\n\t        return {\r\n\t            element: item,\r\n\t            next: null\r\n\t        };\r\n\t    };\r\n\t    return LinkedList;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = LinkedList; // End of linked list\r\n\t//# sourceMappingURL=LinkedList.js.map\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar collections = __webpack_require__(7);\r\n\tvar arrays = __webpack_require__(6);\r\n\tvar Heap = (function () {\r\n\t    /**\r\n\t     * Creates an empty Heap.\r\n\t     * @class\r\n\t     * <p>A heap is a binary tree, where the nodes maintain the heap property:\r\n\t     * each node is smaller than each of its children and therefore a MinHeap\r\n\t     * This implementation uses an array to store elements.</p>\r\n\t     * <p>If the inserted elements are custom objects a compare function must be provided,\r\n\t     *  at construction time, otherwise the <=, === and >= operators are\r\n\t     * used to compare elements. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function compare(a, b) {\r\n\t     *  if (a is less than b by some ordering criterion) {\r\n\t     *     return -1;\r\n\t     *  } if (a is greater than b by the ordering criterion) {\r\n\t     *     return 1;\r\n\t     *  }\r\n\t     *  // a must be equal to b\r\n\t     *  return 0;\r\n\t     * }\r\n\t     * </pre>\r\n\t     *\r\n\t     * <p>If a Max-Heap is wanted (greater elements on top) you can a provide a\r\n\t     * reverse compare function to accomplish that behavior. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function reverseCompare(a, b) {\r\n\t     *  if (a is less than b by some ordering criterion) {\r\n\t     *     return 1;\r\n\t     *  } if (a is greater than b by the ordering criterion) {\r\n\t     *     return -1;\r\n\t     *  }\r\n\t     *  // a must be equal to b\r\n\t     *  return 0;\r\n\t     * }\r\n\t     * </pre>\r\n\t     *\r\n\t     * @constructor\r\n\t     * @param {function(Object,Object):number=} compareFunction optional\r\n\t     * function used to compare two elements. Must return a negative integer,\r\n\t     * zero, or a positive integer as the first argument is less than, equal to,\r\n\t     * or greater than the second.\r\n\t     */\r\n\t    function Heap(compareFunction) {\r\n\t        /**\r\n\t         * Array used to store the elements od the heap.\r\n\t         * @type {Array.<Object>}\r\n\t         * @private\r\n\t         */\r\n\t        this.data = [];\r\n\t        this.compare = compareFunction || collections.defaultCompare;\r\n\t    }\r\n\t    /**\r\n\t     * Returns the index of the left child of the node at the given index.\r\n\t     * @param {number} nodeIndex The index of the node to get the left child\r\n\t     * for.\r\n\t     * @return {number} The index of the left child.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.leftChildIndex = function (nodeIndex) {\r\n\t        return (2 * nodeIndex) + 1;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the index of the right child of the node at the given index.\r\n\t     * @param {number} nodeIndex The index of the node to get the right child\r\n\t     * for.\r\n\t     * @return {number} The index of the right child.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.rightChildIndex = function (nodeIndex) {\r\n\t        return (2 * nodeIndex) + 2;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the index of the parent of the node at the given index.\r\n\t     * @param {number} nodeIndex The index of the node to get the parent for.\r\n\t     * @return {number} The index of the parent.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.parentIndex = function (nodeIndex) {\r\n\t        return Math.floor((nodeIndex - 1) / 2);\r\n\t    };\r\n\t    /**\r\n\t     * Returns the index of the smaller child node (if it exists).\r\n\t     * @param {number} leftChild left child index.\r\n\t     * @param {number} rightChild right child index.\r\n\t     * @return {number} the index with the minimum value or -1 if it doesn't\r\n\t     * exists.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.minIndex = function (leftChild, rightChild) {\r\n\t        if (rightChild >= this.data.length) {\r\n\t            if (leftChild >= this.data.length) {\r\n\t                return -1;\r\n\t            }\r\n\t            else {\r\n\t                return leftChild;\r\n\t            }\r\n\t        }\r\n\t        else {\r\n\t            if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {\r\n\t                return leftChild;\r\n\t            }\r\n\t            else {\r\n\t                return rightChild;\r\n\t            }\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Moves the node at the given index up to its proper place in the heap.\r\n\t     * @param {number} index The index of the node to move up.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.siftUp = function (index) {\r\n\t        var parent = this.parentIndex(index);\r\n\t        while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {\r\n\t            arrays.swap(this.data, parent, index);\r\n\t            index = parent;\r\n\t            parent = this.parentIndex(index);\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Moves the node at the given index down to its proper place in the heap.\r\n\t     * @param {number} nodeIndex The index of the node to move down.\r\n\t     * @private\r\n\t     */\r\n\t    Heap.prototype.siftDown = function (nodeIndex) {\r\n\t        //smaller child index\r\n\t        var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\r\n\t        while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {\r\n\t            arrays.swap(this.data, min, nodeIndex);\r\n\t            nodeIndex = min;\r\n\t            min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves but does not remove the root element of this heap.\r\n\t     * @return {*} The value at the root of the heap. Returns undefined if the\r\n\t     * heap is empty.\r\n\t     */\r\n\t    Heap.prototype.peek = function () {\r\n\t        if (this.data.length > 0) {\r\n\t            return this.data[0];\r\n\t        }\r\n\t        else {\r\n\t            return undefined;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Adds the given element into the heap.\r\n\t     * @param {*} element the element.\r\n\t     * @return true if the element was added or fals if it is undefined.\r\n\t     */\r\n\t    Heap.prototype.add = function (element) {\r\n\t        if (collections.isUndefined(element)) {\r\n\t            return undefined;\r\n\t        }\r\n\t        this.data.push(element);\r\n\t        this.siftUp(this.data.length - 1);\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves and removes the root element of this heap.\r\n\t     * @return {*} The value removed from the root of the heap. Returns\r\n\t     * undefined if the heap is empty.\r\n\t     */\r\n\t    Heap.prototype.removeRoot = function () {\r\n\t        if (this.data.length > 0) {\r\n\t            var obj = this.data[0];\r\n\t            this.data[0] = this.data[this.data.length - 1];\r\n\t            this.data.splice(this.data.length - 1, 1);\r\n\t            if (this.data.length > 0) {\r\n\t                this.siftDown(0);\r\n\t            }\r\n\t            return obj;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this heap contains the specified element.\r\n\t     * @param {Object} element element to search for.\r\n\t     * @return {boolean} true if this Heap contains the specified element, false\r\n\t     * otherwise.\r\n\t     */\r\n\t    Heap.prototype.contains = function (element) {\r\n\t        var equF = collections.compareToEquals(this.compare);\r\n\t        return arrays.contains(this.data, element, equF);\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this heap.\r\n\t     * @return {number} the number of elements in this heap.\r\n\t     */\r\n\t    Heap.prototype.size = function () {\r\n\t        return this.data.length;\r\n\t    };\r\n\t    /**\r\n\t     * Checks if this heap is empty.\r\n\t     * @return {boolean} true if and only if this heap contains no items; false\r\n\t     * otherwise.\r\n\t     */\r\n\t    Heap.prototype.isEmpty = function () {\r\n\t        return this.data.length <= 0;\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this heap.\r\n\t     */\r\n\t    Heap.prototype.clear = function () {\r\n\t        this.data.length = 0;\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this heap in\r\n\t     * no particular order.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    Heap.prototype.forEach = function (callback) {\r\n\t        arrays.forEach(this.data, callback);\r\n\t    };\r\n\t    return Heap;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Heap;\r\n\t//# sourceMappingURL=Heap.js.map\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Dictionary_1 = __webpack_require__(9);\r\n\tvar util = __webpack_require__(7);\r\n\t/**\r\n\t * This class is used by the LinkedDictionary Internally\r\n\t * Has to be a class, not an interface, because it needs to have\r\n\t * the 'unlink' function defined.\r\n\t */\r\n\tvar LinkedDictionaryPair = (function () {\r\n\t    function LinkedDictionaryPair(key, value) {\r\n\t        this.key = key;\r\n\t        this.value = value;\r\n\t    }\r\n\t    LinkedDictionaryPair.prototype.unlink = function () {\r\n\t        this.prev.next = this.next;\r\n\t        this.next.prev = this.prev;\r\n\t    };\r\n\t    return LinkedDictionaryPair;\r\n\t}());\r\n\tvar LinkedDictionary = (function (_super) {\r\n\t    __extends(LinkedDictionary, _super);\r\n\t    function LinkedDictionary(toStrFunction) {\r\n\t        _super.call(this, toStrFunction);\r\n\t        this.head = new LinkedDictionaryPair(null, null);\r\n\t        this.tail = new LinkedDictionaryPair(null, null);\r\n\t        this.head.next = this.tail;\r\n\t        this.tail.prev = this.head;\r\n\t    }\r\n\t    /**\r\n\t     * Inserts the new node to the 'tail' of the list, updating the\r\n\t     * neighbors, and moving 'this.tail' (the End of List indicator) that\r\n\t     * to the end.\r\n\t     */\r\n\t    LinkedDictionary.prototype.appendToTail = function (entry) {\r\n\t        var lastNode = this.tail.prev;\r\n\t        lastNode.next = entry;\r\n\t        entry.prev = lastNode;\r\n\t        entry.next = this.tail;\r\n\t        this.tail.prev = entry;\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves a linked dictionary from the table internally\r\n\t     */\r\n\t    LinkedDictionary.prototype.getLinkedDictionaryPair = function (key) {\r\n\t        if (util.isUndefined(key)) {\r\n\t            return undefined;\r\n\t        }\r\n\t        var k = '$' + this.toStr(key);\r\n\t        var pair = (this.table[k]);\r\n\t        return pair;\r\n\t    };\r\n\t    /**\r\n\t     * Returns the value to which this dictionary maps the specified key.\r\n\t     * Returns undefined if this dictionary contains no mapping for this key.\r\n\t     * @param {Object} key key whose associated value is to be returned.\r\n\t     * @return {*} the value to which this dictionary maps the specified key or\r\n\t     * undefined if the map contains no mapping for this key.\r\n\t     */\r\n\t    LinkedDictionary.prototype.getValue = function (key) {\r\n\t        var pair = this.getLinkedDictionaryPair(key);\r\n\t        if (!util.isUndefined(pair)) {\r\n\t            return pair.value;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the mapping for this key from this dictionary if it is present.\r\n\t     * Also, if a value is present for this key, the entry is removed from the\r\n\t     * insertion ordering.\r\n\t     * @param {Object} key key whose mapping is to be removed from the\r\n\t     * dictionary.\r\n\t     * @return {*} previous value associated with specified key, or undefined if\r\n\t     * there was no mapping for key.\r\n\t     */\r\n\t    LinkedDictionary.prototype.remove = function (key) {\r\n\t        var pair = this.getLinkedDictionaryPair(key);\r\n\t        if (!util.isUndefined(pair)) {\r\n\t            _super.prototype.remove.call(this, key); // This will remove it from the table\r\n\t            pair.unlink(); // This will unlink it from the chain\r\n\t            return pair.value;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t    * Removes all mappings from this LinkedDictionary.\r\n\t    * @this {collections.LinkedDictionary}\r\n\t    */\r\n\t    LinkedDictionary.prototype.clear = function () {\r\n\t        _super.prototype.clear.call(this);\r\n\t        this.head.next = this.tail;\r\n\t        this.tail.prev = this.head;\r\n\t    };\r\n\t    /**\r\n\t     * Internal function used when updating an existing KeyValue pair.\r\n\t     * It places the new value indexed by key into the table, but maintains\r\n\t     * its place in the linked ordering.\r\n\t     */\r\n\t    LinkedDictionary.prototype.replace = function (oldPair, newPair) {\r\n\t        var k = '$' + this.toStr(newPair.key);\r\n\t        // set the new Pair's links to existingPair's links\r\n\t        newPair.next = oldPair.next;\r\n\t        newPair.prev = oldPair.prev;\r\n\t        // Delete Existing Pair from the table, unlink it from chain.\r\n\t        // As a result, the nElements gets decremented by this operation\r\n\t        this.remove(oldPair.key);\r\n\t        // Link new Pair in place of where oldPair was,\r\n\t        // by pointing the old pair's neighbors to it.\r\n\t        newPair.prev.next = newPair;\r\n\t        newPair.next.prev = newPair;\r\n\t        this.table[k] = newPair;\r\n\t        // To make up for the fact that the number of elements was decremented,\r\n\t        // We need to increase it by one.\r\n\t        ++this.nElements;\r\n\t    };\r\n\t    /**\r\n\t     * Associates the specified value with the specified key in this dictionary.\r\n\t     * If the dictionary previously contained a mapping for this key, the old\r\n\t     * value is replaced by the specified value.\r\n\t     * Updating of a key that already exists maintains its place in the\r\n\t     * insertion order into the map.\r\n\t     * @param {Object} key key with which the specified value is to be\r\n\t     * associated.\r\n\t     * @param {Object} value value to be associated with the specified key.\r\n\t     * @return {*} previous value associated with the specified key, or undefined if\r\n\t     * there was no mapping for the key or if the key/value are undefined.\r\n\t     */\r\n\t    LinkedDictionary.prototype.setValue = function (key, value) {\r\n\t        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n\t            return undefined;\r\n\t        }\r\n\t        var existingPair = this.getLinkedDictionaryPair(key);\r\n\t        var newPair = new LinkedDictionaryPair(key, value);\r\n\t        var k = '$' + this.toStr(key);\r\n\t        // If there is already an element for that key, we\r\n\t        // keep it's place in the LinkedList\r\n\t        if (!util.isUndefined(existingPair)) {\r\n\t            this.replace(existingPair, newPair);\r\n\t            return existingPair.value;\r\n\t        }\r\n\t        else {\r\n\t            this.appendToTail(newPair);\r\n\t            this.table[k] = newPair;\r\n\t            ++this.nElements;\r\n\t            return undefined;\r\n\t        }\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the keys in this LinkedDictionary, ordered\r\n\t     * by insertion order.\r\n\t     * @return {Array} an array containing all of the keys in this LinkedDictionary,\r\n\t     * ordered by insertion order.\r\n\t     */\r\n\t    LinkedDictionary.prototype.keys = function () {\r\n\t        var array = [];\r\n\t        this.forEach(function (key, value) {\r\n\t            array.push(key);\r\n\t        });\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the values in this LinkedDictionary, ordered by\r\n\t     * insertion order.\r\n\t     * @return {Array} an array containing all of the values in this LinkedDictionary,\r\n\t     * ordered by insertion order.\r\n\t     */\r\n\t    LinkedDictionary.prototype.values = function () {\r\n\t        var array = [];\r\n\t        this.forEach(function (key, value) {\r\n\t            array.push(value);\r\n\t        });\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t    * Executes the provided function once for each key-value pair\r\n\t    * present in this LinkedDictionary. It is done in the order of insertion\r\n\t    * into the LinkedDictionary\r\n\t    * @param {function(Object,Object):*} callback function to execute, it is\r\n\t    * invoked with two arguments: key and value. To break the iteration you can\r\n\t    * optionally return false.\r\n\t    */\r\n\t    LinkedDictionary.prototype.forEach = function (callback) {\r\n\t        var crawlNode = this.head.next;\r\n\t        while (crawlNode.next != null) {\r\n\t            var ret = callback(crawlNode.key, crawlNode.value);\r\n\t            if (ret === false) {\r\n\t                return;\r\n\t            }\r\n\t            crawlNode = crawlNode.next;\r\n\t        }\r\n\t    };\r\n\t    return LinkedDictionary;\r\n\t}(Dictionary_1.default));\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = LinkedDictionary; // End of LinkedDictionary\r\n\t// /**\r\n\t//  * Returns true if this dictionary is equal to the given dictionary.\r\n\t//  * Two dictionaries are equal if they contain the same mappings.\r\n\t//  * @param {collections.Dictionary} other the other dictionary.\r\n\t//  * @param {function(Object,Object):boolean=} valuesEqualFunction optional\r\n\t//  * function used to check if two values are equal.\r\n\t//  * @return {boolean} true if this dictionary is equal to the given dictionary.\r\n\t//  */\r\n\t// collections.Dictionary.prototype.equals = function(other,valuesEqualFunction) {\r\n\t// \tconst eqF = valuesEqualFunction || collections.defaultEquals;\r\n\t// \tif(!(other instanceof collections.Dictionary)){\r\n\t// \t\treturn false;\r\n\t// \t}\r\n\t// \tif(this.size() !== other.size()){\r\n\t// \t\treturn false;\r\n\t// \t}\r\n\t// \treturn this.equalsAux(this.firstNode,other.firstNode,eqF);\r\n\t// }\r\n\t//# sourceMappingURL=LinkedDictionary.js.map\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar Dictionary_1 = __webpack_require__(9);\r\n\tvar arrays = __webpack_require__(6);\r\n\tvar MultiDictionary = (function () {\r\n\t    /**\r\n\t     * Creates an empty multi dictionary.\r\n\t     * @class <p>A multi dictionary is a special kind of dictionary that holds\r\n\t     * multiple values against each key. Setting a value into the dictionary will\r\n\t     * add the value to an array at that key. Getting a key will return an array,\r\n\t     * holding all the values set to that key.\r\n\t     * You can configure to allow duplicates in the values.\r\n\t     * This implementation accepts any kind of objects as keys.</p>\r\n\t     *\r\n\t     * <p>If the keys are custom objects a function which converts keys to strings must be\r\n\t     * provided. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function petToString(pet) {\r\n\t       *  return pet.name;\r\n\t       * }\r\n\t     * </pre>\r\n\t     * <p>If the values are custom objects a function to check equality between values\r\n\t     * must be provided. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * function petsAreEqualByAge(pet1,pet2) {\r\n\t       *  return pet1.age===pet2.age;\r\n\t       * }\r\n\t     * </pre>\r\n\t     * @constructor\r\n\t     * @param {function(Object):string=} toStrFunction optional function\r\n\t     * to convert keys to strings. If the keys aren't strings or if toString()\r\n\t     * is not appropriate, a custom function which receives a key and returns a\r\n\t     * unique string must be provided.\r\n\t     * @param {function(Object,Object):boolean=} valuesEqualsFunction optional\r\n\t     * function to check if two values are equal.\r\n\t     *\r\n\t     * @param allowDuplicateValues\r\n\t     */\r\n\t    function MultiDictionary(toStrFunction, valuesEqualsFunction, allowDuplicateValues) {\r\n\t        if (allowDuplicateValues === void 0) { allowDuplicateValues = false; }\r\n\t        this.dict = new Dictionary_1.default(toStrFunction);\r\n\t        this.equalsF = valuesEqualsFunction || util.defaultEquals;\r\n\t        this.allowDuplicate = allowDuplicateValues;\r\n\t    }\r\n\t    /**\r\n\t    * Returns an array holding the values to which this dictionary maps\r\n\t    * the specified key.\r\n\t    * Returns an empty array if this dictionary contains no mappings for this key.\r\n\t    * @param {Object} key key whose associated values are to be returned.\r\n\t    * @return {Array} an array holding the values to which this dictionary maps\r\n\t    * the specified key.\r\n\t    */\r\n\t    MultiDictionary.prototype.getValue = function (key) {\r\n\t        var values = this.dict.getValue(key);\r\n\t        if (util.isUndefined(values)) {\r\n\t            return [];\r\n\t        }\r\n\t        return arrays.copy(values);\r\n\t    };\r\n\t    /**\r\n\t     * Adds the value to the array associated with the specified key, if\r\n\t     * it is not already present.\r\n\t     * @param {Object} key key with which the specified value is to be\r\n\t     * associated.\r\n\t     * @param {Object} value the value to add to the array at the key\r\n\t     * @return {boolean} true if the value was not already associated with that key.\r\n\t     */\r\n\t    MultiDictionary.prototype.setValue = function (key, value) {\r\n\t        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n\t            return false;\r\n\t        }\r\n\t        if (!this.containsKey(key)) {\r\n\t            this.dict.setValue(key, [value]);\r\n\t            return true;\r\n\t        }\r\n\t        var array = this.dict.getValue(key);\r\n\t        if (!this.allowDuplicate) {\r\n\t            if (arrays.contains(array, value, this.equalsF)) {\r\n\t                return false;\r\n\t            }\r\n\t        }\r\n\t        array.push(value);\r\n\t        return true;\r\n\t    };\r\n\t    /**\r\n\t     * Removes the specified values from the array of values associated with the\r\n\t     * specified key. If a value isn't given, all values associated with the specified\r\n\t     * key are removed.\r\n\t     * @param {Object} key key whose mapping is to be removed from the\r\n\t     * dictionary.\r\n\t     * @param {Object=} value optional argument to specify the value to remove\r\n\t     * from the array associated with the specified key.\r\n\t     * @return {*} true if the dictionary changed, false if the key doesn't exist or\r\n\t     * if the specified value isn't associated with the specified key.\r\n\t     */\r\n\t    MultiDictionary.prototype.remove = function (key, value) {\r\n\t        if (util.isUndefined(value)) {\r\n\t            var v = this.dict.remove(key);\r\n\t            return !util.isUndefined(v);\r\n\t        }\r\n\t        var array = this.dict.getValue(key);\r\n\t        if (arrays.remove(array, value, this.equalsF)) {\r\n\t            if (array.length === 0) {\r\n\t                this.dict.remove(key);\r\n\t            }\r\n\t            return true;\r\n\t        }\r\n\t        return false;\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the keys in this dictionary.\r\n\t     * @return {Array} an array containing all of the keys in this dictionary.\r\n\t     */\r\n\t    MultiDictionary.prototype.keys = function () {\r\n\t        return this.dict.keys();\r\n\t    };\r\n\t    /**\r\n\t     * Returns an array containing all of the values in this dictionary.\r\n\t     * @return {Array} an array containing all of the values in this dictionary.\r\n\t     */\r\n\t    MultiDictionary.prototype.values = function () {\r\n\t        var values = this.dict.values();\r\n\t        var array = [];\r\n\t        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\r\n\t            var v = values_1[_i];\r\n\t            for (var _a = 0, v_1 = v; _a < v_1.length; _a++) {\r\n\t                var w = v_1[_a];\r\n\t                array.push(w);\r\n\t            }\r\n\t        }\r\n\t        return array;\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this dictionary at least one value associatted the specified key.\r\n\t     * @param {Object} key key whose presence in this dictionary is to be\r\n\t     * tested.\r\n\t     * @return {boolean} true if this dictionary at least one value associatted\r\n\t     * the specified key.\r\n\t     */\r\n\t    MultiDictionary.prototype.containsKey = function (key) {\r\n\t        return this.dict.containsKey(key);\r\n\t    };\r\n\t    /**\r\n\t     * Removes all mappings from this dictionary.\r\n\t     */\r\n\t    MultiDictionary.prototype.clear = function () {\r\n\t        this.dict.clear();\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of keys in this dictionary.\r\n\t     * @return {number} the number of key-value mappings in this dictionary.\r\n\t     */\r\n\t    MultiDictionary.prototype.size = function () {\r\n\t        return this.dict.size();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this dictionary contains no mappings.\r\n\t     * @return {boolean} true if this dictionary contains no mappings.\r\n\t     */\r\n\t    MultiDictionary.prototype.isEmpty = function () {\r\n\t        return this.dict.isEmpty();\r\n\t    };\r\n\t    return MultiDictionary;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = MultiDictionary; // end of multi dictionary\r\n\t//# sourceMappingURL=MultiDictionary.js.map\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar util = __webpack_require__(7);\r\n\tvar Heap_1 = __webpack_require__(14);\r\n\tvar PriorityQueue = (function () {\r\n\t    /**\r\n\t     * Creates an empty priority queue.\r\n\t     * @class <p>In a priority queue each element is associated with a \"priority\",\r\n\t     * elements are dequeued in highest-priority-first order (the elements with the\r\n\t     * highest priority are dequeued first). Priority Queues are implemented as heaps.\r\n\t     * If the inserted elements are custom objects a compare function must be provided,\r\n\t     * otherwise the <=, === and >= operators are used to compare object priority.</p>\r\n\t     * <pre>\r\n\t     * function compare(a, b) {\r\n\t     *  if (a is less than b by some ordering criterion) {\r\n\t     *     return -1;\r\n\t     *  } if (a is greater than b by the ordering criterion) {\r\n\t     *     return 1;\r\n\t     *  }\r\n\t     *  // a must be equal to b\r\n\t     *  return 0;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @constructor\r\n\t     * @param {function(Object,Object):number=} compareFunction optional\r\n\t     * function used to compare two element priorities. Must return a negative integer,\r\n\t     * zero, or a positive integer as the first argument is less than, equal to,\r\n\t     * or greater than the second.\r\n\t     */\r\n\t    function PriorityQueue(compareFunction) {\r\n\t        this.heap = new Heap_1.default(util.reverseCompareFunction(compareFunction));\r\n\t    }\r\n\t    /**\r\n\t     * Inserts the specified element into this priority queue.\r\n\t     * @param {Object} element the element to insert.\r\n\t     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n\t     */\r\n\t    PriorityQueue.prototype.enqueue = function (element) {\r\n\t        return this.heap.add(element);\r\n\t    };\r\n\t    /**\r\n\t     * Inserts the specified element into this priority queue.\r\n\t     * @param {Object} element the element to insert.\r\n\t     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n\t     */\r\n\t    PriorityQueue.prototype.add = function (element) {\r\n\t        return this.heap.add(element);\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves and removes the highest priority element of this queue.\r\n\t     * @return {*} the the highest priority element of this queue,\r\n\t     *  or undefined if this queue is empty.\r\n\t     */\r\n\t    PriorityQueue.prototype.dequeue = function () {\r\n\t        if (this.heap.size() !== 0) {\r\n\t            var el = this.heap.peek();\r\n\t            this.heap.removeRoot();\r\n\t            return el;\r\n\t        }\r\n\t        return undefined;\r\n\t    };\r\n\t    /**\r\n\t     * Retrieves, but does not remove, the highest priority element of this queue.\r\n\t     * @return {*} the highest priority element of this queue, or undefined if this queue is empty.\r\n\t     */\r\n\t    PriorityQueue.prototype.peek = function () {\r\n\t        return this.heap.peek();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this priority queue contains the specified element.\r\n\t     * @param {Object} element element to search for.\r\n\t     * @return {boolean} true if this priority queue contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    PriorityQueue.prototype.contains = function (element) {\r\n\t        return this.heap.contains(element);\r\n\t    };\r\n\t    /**\r\n\t     * Checks if this priority queue is empty.\r\n\t     * @return {boolean} true if and only if this priority queue contains no items; false\r\n\t     * otherwise.\r\n\t     */\r\n\t    PriorityQueue.prototype.isEmpty = function () {\r\n\t        return this.heap.isEmpty();\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this priority queue.\r\n\t     * @return {number} the number of elements in this priority queue.\r\n\t     */\r\n\t    PriorityQueue.prototype.size = function () {\r\n\t        return this.heap.size();\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this priority queue.\r\n\t     */\r\n\t    PriorityQueue.prototype.clear = function () {\r\n\t        this.heap.clear();\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this queue in\r\n\t     * no particular order.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    PriorityQueue.prototype.forEach = function (callback) {\r\n\t        this.heap.forEach(callback);\r\n\t    };\r\n\t    return PriorityQueue;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = PriorityQueue; // end of priority queue\r\n\t//# sourceMappingURL=PriorityQueue.js.map\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar LinkedList_1 = __webpack_require__(13);\r\n\tvar Stack = (function () {\r\n\t    /**\r\n\t     * Creates an empty Stack.\r\n\t     * @class A Stack is a Last-In-First-Out (LIFO) data structure, the last\r\n\t     * element added to the stack will be the first one to be removed. This\r\n\t     * implementation uses a linked list as a container.\r\n\t     * @constructor\r\n\t     */\r\n\t    function Stack() {\r\n\t        this.list = new LinkedList_1.default();\r\n\t    }\r\n\t    /**\r\n\t     * Pushes an item onto the top of this stack.\r\n\t     * @param {Object} elem the element to be pushed onto this stack.\r\n\t     * @return {boolean} true if the element was pushed or false if it is undefined.\r\n\t     */\r\n\t    Stack.prototype.push = function (elem) {\r\n\t        return this.list.add(elem, 0);\r\n\t    };\r\n\t    /**\r\n\t     * Pushes an item onto the top of this stack.\r\n\t     * @param {Object} elem the element to be pushed onto this stack.\r\n\t     * @return {boolean} true if the element was pushed or false if it is undefined.\r\n\t     */\r\n\t    Stack.prototype.add = function (elem) {\r\n\t        return this.list.add(elem, 0);\r\n\t    };\r\n\t    /**\r\n\t     * Removes the object at the top of this stack and returns that object.\r\n\t     * @return {*} the object at the top of this stack or undefined if the\r\n\t     * stack is empty.\r\n\t     */\r\n\t    Stack.prototype.pop = function () {\r\n\t        return this.list.removeElementAtIndex(0);\r\n\t    };\r\n\t    /**\r\n\t     * Looks at the object at the top of this stack without removing it from the\r\n\t     * stack.\r\n\t     * @return {*} the object at the top of this stack or undefined if the\r\n\t     * stack is empty.\r\n\t     */\r\n\t    Stack.prototype.peek = function () {\r\n\t        return this.list.first();\r\n\t    };\r\n\t    /**\r\n\t     * Returns the number of elements in this stack.\r\n\t     * @return {number} the number of elements in this stack.\r\n\t     */\r\n\t    Stack.prototype.size = function () {\r\n\t        return this.list.size();\r\n\t    };\r\n\t    /**\r\n\t     * Returns true if this stack contains the specified element.\r\n\t     * <p>If the elements inside this stack are\r\n\t     * not comparable with the === operator, a custom equals function should be\r\n\t     * provided to perform searches, the function must receive two arguments and\r\n\t     * return true if they are equal, false otherwise. Example:</p>\r\n\t     *\r\n\t     * <pre>\r\n\t     * const petsAreEqualByName (pet1, pet2) {\r\n\t     *  return pet1.name === pet2.name;\r\n\t     * }\r\n\t     * </pre>\r\n\t     * @param {Object} elem element to search for.\r\n\t     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n\t     * function to check if two elements are equal.\r\n\t     * @return {boolean} true if this stack contains the specified element,\r\n\t     * false otherwise.\r\n\t     */\r\n\t    Stack.prototype.contains = function (elem, equalsFunction) {\r\n\t        return this.list.contains(elem, equalsFunction);\r\n\t    };\r\n\t    /**\r\n\t     * Checks if this stack is empty.\r\n\t     * @return {boolean} true if and only if this stack contains no items; false\r\n\t     * otherwise.\r\n\t     */\r\n\t    Stack.prototype.isEmpty = function () {\r\n\t        return this.list.isEmpty();\r\n\t    };\r\n\t    /**\r\n\t     * Removes all of the elements from this stack.\r\n\t     */\r\n\t    Stack.prototype.clear = function () {\r\n\t        this.list.clear();\r\n\t    };\r\n\t    /**\r\n\t     * Executes the provided function once for each element present in this stack in\r\n\t     * LIFO order.\r\n\t     * @param {function(Object):*} callback function to execute, it is\r\n\t     * invoked with one argument: the element value, to break the iteration you can\r\n\t     * optionally return false.\r\n\t     */\r\n\t    Stack.prototype.forEach = function (callback) {\r\n\t        this.list.forEach(callback);\r\n\t    };\r\n\t    return Stack;\r\n\t}());\r\n\tObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\texports.default = Stack; // End of stack\r\n\t//# sourceMappingURL=Stack.js.map\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Lambda_1 = __webpack_require__(1);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar CoalesceHandler = (function () {\r\n\t    function CoalesceHandler(f, out) {\r\n\t        this.f = Lambda_1.Lambda2_toFunction(f);\r\n\t        this.out = out;\r\n\t        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(Lambda_1.toSources(Lambda_1.Lambda2_deps(f)));\r\n\t        this.accumValid = false;\r\n\t    }\r\n\t    CoalesceHandler.prototype.send_ = function (a) {\r\n\t        var _this = this;\r\n\t        if (this.accumValid)\r\n\t            this.accum = this.f(this.accum, a);\r\n\t        else {\r\n\t            Transaction_1.currentTransaction.prioritized(this.out.getVertex__(), function () {\r\n\t                _this.out.send_(_this.accum);\r\n\t                _this.accumValid = false;\r\n\t                _this.accum = null;\r\n\t            });\r\n\t            this.accum = a;\r\n\t            this.accumValid = true;\r\n\t        }\r\n\t    };\r\n\t    return CoalesceHandler;\r\n\t}());\r\n\texports.CoalesceHandler = CoalesceHandler;\r\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Lambda_1 = __webpack_require__(1);\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar Lazy_1 = __webpack_require__(21);\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\tvar Operational_1 = __webpack_require__(22);\r\n\tvar LazySample = (function () {\r\n\t    function LazySample(cell) {\r\n\t        this.hasValue = false;\r\n\t        this.value = null;\r\n\t        this.cell = cell;\r\n\t    }\r\n\t    return LazySample;\r\n\t}());\r\n\tvar ApplyState = (function () {\r\n\t    function ApplyState() {\r\n\t        this.f = null;\r\n\t        this.f_present = false;\r\n\t        this.a = null;\r\n\t        this.a_present = false;\r\n\t    }\r\n\t    return ApplyState;\r\n\t}());\r\n\tvar Cell = (function () {\r\n\t    function Cell(initValue, str) {\r\n\t        var _this = this;\r\n\t        this.value = initValue;\r\n\t        if (!str) {\r\n\t            this.str = new Stream_1.Stream();\r\n\t            this.vertex = new Vertex_1.Vertex(\"ConstCell\", 0, []);\r\n\t        }\r\n\t        else\r\n\t            Transaction_1.transactionally(function () { return _this.setStream(str); });\r\n\t    }\r\n\t    Cell.prototype.setStream = function (str) {\r\n\t        var _this = this;\r\n\t        this.str = str;\r\n\t        var me = this, src = new Vertex_1.Source(str.getVertex__(), function () {\r\n\t            return str.listen_(me.vertex, function (a) {\r\n\t                if (me.valueUpdate == null) {\r\n\t                    Transaction_1.currentTransaction.last(function () {\r\n\t                        me.value = me.valueUpdate;\r\n\t                        me.lazyInitValue = null;\r\n\t                        me.valueUpdate = null;\r\n\t                    });\r\n\t                }\r\n\t                me.valueUpdate = a;\r\n\t            }, false);\r\n\t        });\r\n\t        this.vertex = new Vertex_1.Vertex(\"Cell\", 0, [src]);\r\n\t        // We do a trick here of registering the source for the duration of the current\r\n\t        // transaction so that we are guaranteed to catch any stream events that\r\n\t        // occur in the same transaction.\r\n\t        this.vertex.register(Vertex_1.Vertex.NULL);\r\n\t        Transaction_1.currentTransaction.last(function () {\r\n\t            _this.vertex.deregister(Vertex_1.Vertex.NULL);\r\n\t        });\r\n\t    };\r\n\t    Cell.prototype.getVertex__ = function () {\r\n\t        return this.vertex;\r\n\t    };\r\n\t    Cell.prototype.getStream__ = function () {\r\n\t        return this.str;\r\n\t    };\r\n\t    /**\r\n\t     * Sample the cell's current value.\r\n\t     * <p>\r\n\t     * It may be used inside the functions passed to primitives that apply them to {@link Stream}s,\r\n\t     * including {@link Stream#map(Lambda1)} in which case it is equivalent to snapshotting the cell,\r\n\t     * {@link Stream#snapshot(Cell, Lambda2)}, {@link Stream#filter(Lambda1)} and\r\n\t     * {@link Stream#merge(Stream, Lambda2)}.\r\n\t     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\r\n\t     * miss any updates, but in many circumstances it makes sense.\r\n\t     */\r\n\t    Cell.prototype.sample = function () {\r\n\t        var _this = this;\r\n\t        return Transaction_1.transactionally(function () { return _this.sampleNoTrans__(); });\r\n\t    };\r\n\t    Cell.prototype.sampleNoTrans__ = function () {\r\n\t        return this.value;\r\n\t    };\r\n\t    /**\r\n\t     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\r\n\t     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\r\n\t     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\r\n\t     */\r\n\t    Cell.prototype.sampleLazy = function () {\r\n\t        var me = this;\r\n\t        return Transaction_1.transactionally(function () { return me.sampleLazyNoTrans__(); });\r\n\t    };\r\n\t    Cell.prototype.sampleLazyNoTrans__ = function () {\r\n\t        var me = this, s = new LazySample(me);\r\n\t        Transaction_1.currentTransaction.last(function () {\r\n\t            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\r\n\t            s.hasValue = true;\r\n\t            s.cell = null;\r\n\t        });\r\n\t        return new Lazy_1.Lazy(function () {\r\n\t            if (s.hasValue)\r\n\t                return s.value;\r\n\t            else\r\n\t                return s.cell.sample();\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Transform the cell's value according to the supplied function, so the returned Cell\r\n\t     * always reflects the value of the function applied to the input Cell's value.\r\n\t     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.map = function (f) {\r\n\t        var c = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            return Operational_1.Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda_1.Lambda1_toFunction(f)));\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Lift a binary function into cells, so the returned Cell always reflects the specified\r\n\t     * function applied to the input cells' values.\r\n\t     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.lift = function (b, fn0) {\r\n\t        var fn = Lambda_1.Lambda2_toFunction(fn0), cf = this.map(function (aa) { return function (bb) { return fn(aa, bb); }; });\r\n\t        return Cell.apply(cf, b, Lambda_1.toSources(Lambda_1.Lambda2_deps(fn0)));\r\n\t    };\r\n\t    /**\r\n\t     * Lift a ternary function into cells, so the returned Cell always reflects the specified\r\n\t     * function applied to the input cells' values.\r\n\t     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.lift3 = function (b, c, fn0) {\r\n\t        var fn = Lambda_1.Lambda3_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return fn(aa, bb, cc); }; }; }, cf = this.map(mf);\r\n\t        return Cell.apply(Cell.apply(cf, b), c, Lambda_1.toSources(Lambda_1.Lambda3_deps(fn0)));\r\n\t    };\r\n\t    /**\r\n\t     * Lift a quaternary function into cells, so the returned Cell always reflects the specified\r\n\t     * function applied to the input cells' values.\r\n\t     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.lift4 = function (b, c, d, fn0) {\r\n\t        var fn = Lambda_1.Lambda4_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return fn(aa, bb, cc, dd); }; }; }; }, cf = this.map(mf);\r\n\t        return Cell.apply(Cell.apply(Cell.apply(cf, b), c), d, Lambda_1.toSources(Lambda_1.Lambda4_deps(fn0)));\r\n\t    };\r\n\t    /**\r\n\t     * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\r\n\t     * function applied to the input cells' values.\r\n\t     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.lift5 = function (b, c, d, e, fn0) {\r\n\t        var fn = Lambda_1.Lambda5_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return function (ee) { return fn(aa, bb, cc, dd, ee); }; }; }; }; }, cf = this.map(mf);\r\n\t        return Cell.apply(Cell.apply(Cell.apply(Cell.apply(cf, b), c), d), e, Lambda_1.toSources(Lambda_1.Lambda5_deps(fn0)));\r\n\t    };\r\n\t    /**\r\n\t     * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\r\n\t     * function applied to the input cells' values.\r\n\t     * @param fn Function to apply. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Cell.prototype.lift6 = function (b, c, d, e, f, fn0) {\r\n\t        var fn = Lambda_1.Lambda6_toFunction(fn0), mf = function (aa) { return function (bb) { return function (cc) { return function (dd) { return function (ee) { return function (ff) { return fn(aa, bb, cc, dd, ee, ff); }; }; }; }; }; }, cf = this.map(mf);\r\n\t        return Cell.apply(Cell.apply(Cell.apply(Cell.apply(Cell.apply(cf, b), c), d), e), f, Lambda_1.toSources(Lambda_1.Lambda6_deps(fn0)));\r\n\t    };\r\n\t    /**\r\n\t     * Apply a value inside a cell to a function inside a cell. This is the\r\n\t     * primitive for all function lifting.\r\n\t     */\r\n\t    Cell.apply = function (cf, ca, sources) {\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var state = new ApplyState(), out = new Stream_1.StreamWithSend(), cf_value = Operational_1.Operational.value(cf), ca_value = Operational_1.Operational.value(ca), src1 = new Vertex_1.Source(cf_value.getVertex__(), function () {\r\n\t                return cf_value.listen_(out.getVertex__(), function (f) {\r\n\t                    state.f = f;\r\n\t                    state.f_present = true;\r\n\t                    if (state.a_present)\r\n\t                        out.send_(state.f(state.a));\r\n\t                }, false);\r\n\t            }), src2 = new Vertex_1.Source(ca_value.getVertex__(), function () {\r\n\t                return ca_value.listen_(out.getVertex__(), function (a) {\r\n\t                    state.a = a;\r\n\t                    state.a_present = true;\r\n\t                    if (state.f_present)\r\n\t                        out.send_(state.f(state.a));\r\n\t                }, false);\r\n\t            });\r\n\t            out.setVertex__(new Vertex_1.Vertex(\"apply\", 0, [src1, src2].concat(sources ? sources : [])));\r\n\t            return out.coalesce__(function (l, r) { return r; }).holdLazy(new Lazy_1.Lazy(function () {\r\n\t                return cf.sampleNoTrans__()(ca.sampleNoTrans__());\r\n\t            }));\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Unwrap a cell inside another cell to give a time-varying cell implementation.\r\n\t     */\r\n\t    Cell.switchC = function (cca) {\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var za = cca.sampleLazy().map(function (ba) { return ba.sample(); }), out = new Stream_1.StreamWithSend();\r\n\t            var last_ca = null;\r\n\t            var cca_value = Operational_1.Operational.value(cca), src = new Vertex_1.Source(cca_value.getVertex__(), function () {\r\n\t                var kill2 = last_ca === null ? null :\r\n\t                    Operational_1.Operational.value(last_ca).listen_(out.getVertex__(), function (a) { return out.send_(a); }, false);\r\n\t                var kill1 = cca_value.listen_(out.getVertex__(), function (ca) {\r\n\t                    // Note: If any switch takes place during a transaction, then the\r\n\t                    // coalesce__() below will always cause a sample to be fetched\r\n\t                    // from the one we just switched to. So anything from the old input cell\r\n\t                    // that might have happened during this transaction will be suppressed.\r\n\t                    last_ca = ca;\r\n\t                    if (kill2 !== null)\r\n\t                        kill2();\r\n\t                    kill2 = Operational_1.Operational.value(ca).listen_(out.getVertex__(), function (a) { return out.send_(a); }, false);\r\n\t                }, false);\r\n\t                return function () { kill1(); kill2(); };\r\n\t            });\r\n\t            out.setVertex__(new Vertex_1.Vertex(\"switchC\", 0, [src]));\r\n\t            return out.coalesce__(function (l, r) { return r; }).holdLazy(za);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Unwrap a stream inside a cell to give a time-varying stream implementation.\r\n\t     */\r\n\t    Cell.switchS = function (csa) {\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var out = new Stream_1.StreamWithSend(), h2 = function (a) {\r\n\t                out.send_(a);\r\n\t            }, src = new Vertex_1.Source(csa.getVertex__(), function () {\r\n\t                var kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\r\n\t                var kill1 = csa.getStream__().listen_(out.getVertex__(), function (sa) {\r\n\t                    kill2();\r\n\t                    kill2 = sa.listen_(out.getVertex__(), h2, true);\r\n\t                }, false);\r\n\t                return function () { kill1(); kill2(); };\r\n\t            });\r\n\t            out.setVertex__(new Vertex_1.Vertex(\"switchS\", 0, [src]));\r\n\t            return out;\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Listen for updates to the value of this cell. This is the observer pattern. The\r\n\t     * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\r\n\t     * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\r\n\t     * the world of I/O and for FRP.\r\n\t     * @param h The handler to execute when there's a new value.\r\n\t     *   You should make no assumptions about what thread you are called on, and the\r\n\t     *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\r\n\t     *   or {@link StreamSink#send(Object)} in the handler.\r\n\t     *   An exception will be thrown, because you are not meant to use this to create\r\n\t     *   your own primitives.\r\n\t     */\r\n\t    Cell.prototype.listen = function (h) {\r\n\t        var _this = this;\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            return Operational_1.Operational.value(_this).listen(h);\r\n\t        });\r\n\t    };\r\n\t    return Cell;\r\n\t}());\r\n\texports.Cell = Cell;\r\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\t/**\r\n\t * A representation for a value that may not be available until the current\r\n\t * transaction is closed.\r\n\t */\r\n\tvar Lazy = (function () {\r\n\t    function Lazy(f) {\r\n\t        this.f = f;\r\n\t    }\r\n\t    /**\r\n\t     * Get the value if available, throwing an exception if not.\r\n\t     * In the general case this should only be used in subsequent transactions to\r\n\t     * when the Lazy was obtained.\r\n\t     */\r\n\t    Lazy.prototype.get = function () {\r\n\t        return this.f();\r\n\t    };\r\n\t    /**\r\n\t     * Map the lazy value according to the specified function, so the returned Lazy reflects\r\n\t     * the value of the function applied to the input Lazy's value.\r\n\t     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\r\n\t     */\r\n\t    Lazy.prototype.map = function (f) {\r\n\t        var _this = this;\r\n\t        return new Lazy(function () { return f(_this.f()); });\r\n\t    };\r\n\t    /**\r\n\t     * Lift a binary function into lazy values, so the returned Lazy reflects\r\n\t     * the value of the function applied to the input Lazys' values.\r\n\t     */\r\n\t    Lazy.prototype.lift = function (b, f) {\r\n\t        var _this = this;\r\n\t        return new Lazy(function () { return f(_this.f(), b.f()); });\r\n\t    };\r\n\t    /**\r\n\t     * Lift a ternary function into lazy values, so the returned Lazy reflects\r\n\t     * the value of the function applied to the input Lazys' values.\r\n\t     */\r\n\t    Lazy.prototype.lift3 = function (b, c, f) {\r\n\t        var _this = this;\r\n\t        return new Lazy(function () { return f(_this.f(), b.f(), c.f()); });\r\n\t    };\r\n\t    /**\r\n\t     * Lift a quaternary function into lazy values, so the returned Lazy reflects\r\n\t     * the value of the function applied to the input Lazys' values.\r\n\t     */\r\n\t    Lazy.prototype.lift4 = function (b, c, d, f) {\r\n\t        var _this = this;\r\n\t        return new Lazy(function () { return f(_this.f(), b.f(), c.f(), d.f()); });\r\n\t    };\r\n\t    return Lazy;\r\n\t}());\r\n\texports.Lazy = Lazy;\r\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar Unit_1 = __webpack_require__(23);\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar Operational = (function () {\r\n\t    function Operational() {\r\n\t    }\r\n\t    /**\r\n\t     * A stream that gives the updates/steps for a {@link Cell}.\r\n\t     * <P>\r\n\t     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n\t     * API. It breaks the property of non-detectability of cell steps/updates.\r\n\t     * The rule with this primitive is that you should only use it in functions\r\n\t     * that do not allow the caller to detect the cell updates.\r\n\t     */\r\n\t    Operational.updates = function (c) {\r\n\t        /*  Don't think this is needed\r\n\t        const out = new StreamWithSend<A>(null);\r\n\t        out.setVertex__(new Vertex(\"updates\", 0, [\r\n\t                new Source(\r\n\t                    c.getStream__().getVertex__(),\r\n\t                    () => {\r\n\t                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\r\n\t                            out.send_(a);\r\n\t                        }, false);\r\n\t                    }\r\n\t                ),\r\n\t                new Source(\r\n\t                    c.getVertex__(),\r\n\t                    () => {\r\n\t                        return () => { };\r\n\t                    }\r\n\t                )\r\n\t            ]\r\n\t        ));\r\n\t        return out;\r\n\t        */\r\n\t        return c.getStream__();\r\n\t    };\r\n\t    /**\r\n\t     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\r\n\t     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\r\n\t     * firing for each update/step of the cell's value.\r\n\t     * <P>\r\n\t     * This is an OPERATIONAL primitive, which is not part of the main Sodium\r\n\t     * API. It breaks the property of non-detectability of cell steps/updates.\r\n\t     * The rule with this primitive is that you should only use it in functions\r\n\t     * that do not allow the caller to detect the cell updates.\r\n\t     */\r\n\t    Operational.value = function (c) {\r\n\t        return Transaction_1.transactionally(function () {\r\n\t            var sSpark = new Stream_1.StreamWithSend();\r\n\t            Transaction_1.currentTransaction.prioritized(sSpark.getVertex__(), function () {\r\n\t                sSpark.send_(Unit_1.Unit.UNIT);\r\n\t            });\r\n\t            var sInitial = sSpark.snapshot1(c);\r\n\t            return Operational.updates(c).orElse(sInitial);\r\n\t        });\r\n\t    };\r\n\t    /**\r\n\t     * Push each event onto a new transaction guaranteed to come before the next externally\r\n\t     * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\r\n\t     */\r\n\t    Operational.defer = function (s) {\r\n\t        return Operational.split(s.map(function (a) {\r\n\t            return [a];\r\n\t        }));\r\n\t    };\r\n\t    /**\r\n\t     * Push each event in the list onto a newly created transaction guaranteed\r\n\t     * to come before the next externally initiated transaction. Note that the semantics\r\n\t     * are such that two different invocations of split() can put events into the same\r\n\t     * new transaction, so the resulting stream's events could be simultaneous with\r\n\t     * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\r\n\t     */\r\n\t    Operational.split = function (s) {\r\n\t        var out = new Stream_1.StreamWithSend(null);\r\n\t        out.setVertex__(new Vertex_1.Vertex(\"split\", 0, [\r\n\t            new Vertex_1.Source(s.getVertex__(), function () {\r\n\t                return s.listen_(out.getVertex__(), function (as) {\r\n\t                    var _loop_1 = function(i) {\r\n\t                        Transaction_1.currentTransaction.post(i, function () {\r\n\t                            Transaction_1.transactionally(function () {\r\n\t                                out.send_(as[i]);\r\n\t                            });\r\n\t                        });\r\n\t                    };\r\n\t                    for (var i = 0; i < as.length; i++) {\r\n\t                        _loop_1(i);\r\n\t                    }\r\n\t                }, false);\r\n\t            })\r\n\t        ]));\r\n\t        return out;\r\n\t    };\r\n\t    return Operational;\r\n\t}());\r\n\texports.Operational = Operational;\r\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Unit = (function () {\r\n\t    function Unit() {\r\n\t    }\r\n\t    Unit.UNIT = new Unit();\r\n\t    return Unit;\r\n\t}());\r\n\texports.Unit = Unit;\r\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Listener = (function () {\r\n\t    function Listener(h, target) {\r\n\t        this.h = h;\r\n\t        this.target = target;\r\n\t    }\r\n\t    return Listener;\r\n\t}());\r\n\texports.Listener = Listener;\r\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Cell_1 = __webpack_require__(20);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar LazyCell = (function (_super) {\r\n\t    __extends(LazyCell, _super);\r\n\t    function LazyCell(lazyInitValue, str) {\r\n\t        var _this = this;\r\n\t        _super.call(this, null, null);\r\n\t        Transaction_1.transactionally(function () {\r\n\t            if (str)\r\n\t                _this.setStream(str);\r\n\t            _this.lazyInitValue = lazyInitValue;\r\n\t        });\r\n\t    }\r\n\t    LazyCell.prototype.sampleNoTrans__ = function () {\r\n\t        if (this.value == null && this.lazyInitValue != null) {\r\n\t            this.value = this.lazyInitValue.get();\r\n\t            this.lazyInitValue = null;\r\n\t        }\r\n\t        return this.value;\r\n\t    };\r\n\t    return LazyCell;\r\n\t}(Cell_1.Cell));\r\n\texports.LazyCell = LazyCell;\r\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\tvar CoalesceHandler_1 = __webpack_require__(19);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\t/**\r\n\t * A stream that allows values to be pushed into it, acting as an interface between the\r\n\t * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\r\n\t * should downcast to {@link Stream}.\r\n\t */\r\n\tvar StreamSink = (function (_super) {\r\n\t    __extends(StreamSink, _super);\r\n\t    function StreamSink(f) {\r\n\t        _super.call(this);\r\n\t        if (!f)\r\n\t            f = (function (l, r) {\r\n\t                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\r\n\t            });\r\n\t        this.coalescer = new CoalesceHandler_1.CoalesceHandler(f, this);\r\n\t    }\r\n\t    StreamSink.prototype.send = function (a) {\r\n\t        var _this = this;\r\n\t        Transaction_1.transactionally(function () {\r\n\t            if (Transaction_1.currentTransaction.inCallback > 0)\r\n\t                throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\r\n\t            _this.coalescer.send_(a);\r\n\t        });\r\n\t    };\r\n\t    return StreamSink;\r\n\t}(Stream_1.StreamWithSend));\r\n\texports.StreamSink = StreamSink;\r\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar LazyCell_1 = __webpack_require__(25);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\t/**\r\n\t * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\r\n\t */\r\n\tvar CellLoop = (function (_super) {\r\n\t    __extends(CellLoop, _super);\r\n\t    function CellLoop() {\r\n\t        _super.call(this, null, new Stream_1.StreamLoop());\r\n\t    }\r\n\t    /**\r\n\t     * Resolve the loop to specify what the CellLoop was a forward reference to. It\r\n\t     * must be invoked inside the same transaction as the place where the CellLoop is used.\r\n\t     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\r\n\t     * or {@link Transaction#runVoid(Runnable)}.\r\n\t     */\r\n\t    CellLoop.prototype.loop = function (a_out) {\r\n\t        var me = this;\r\n\t        Transaction_1.transactionally(function () {\r\n\t            me.getStream__().loop(a_out.getStream__());\r\n\t            me.lazyInitValue = a_out.sampleLazy();\r\n\t        });\r\n\t    };\r\n\t    CellLoop.prototype.sampleNoTrans__ = function () {\r\n\t        if (!this.getStream__().assigned__)\r\n\t            throw new Error(\"CellLoop sampled before it was looped\");\r\n\t        return _super.prototype.sampleNoTrans__.call(this);\r\n\t    };\r\n\t    return CellLoop;\r\n\t}(LazyCell_1.LazyCell));\r\n\texports.CellLoop = CellLoop;\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar Cell_1 = __webpack_require__(20);\r\n\tvar StreamSink_1 = __webpack_require__(26);\r\n\t/**\r\n\t * A cell that allows values to be pushed into it, acting as an interface between the\r\n\t * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\r\n\t * should downcast to {@link Cell}.\r\n\t */\r\n\tvar CellSink = (function (_super) {\r\n\t    __extends(CellSink, _super);\r\n\t    /**\r\n\t     * Construct a writable cell with the specified initial value. If multiple values are\r\n\t     * sent in the same transaction, the specified function is used to combine them.\r\n\t     *\r\n\t     * If the function is not supplied, then an exception will be thrown in this case.\r\n\t     */\r\n\t    function CellSink(initValue, f) {\r\n\t        _super.call(this, initValue, new StreamSink_1.StreamSink(f));\r\n\t    }\r\n\t    /**\r\n\t     * Send a value, modifying the value of the cell. send(A) may not be used inside\r\n\t     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\r\n\t     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\r\n\t     * You are not meant to use this to define your own primitives.\r\n\t     * @param a Value to push into the cell.\r\n\t     */\r\n\t    CellSink.prototype.send = function (a) {\r\n\t        this.getStream__().send(a);\r\n\t    };\r\n\t    return CellSink;\r\n\t}(Cell_1.Cell));\r\n\texports.CellSink = CellSink;\r\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\r\n\tvar Tuple2 = (function () {\r\n\t    function Tuple2(a, b) {\r\n\t        this.a = a;\r\n\t        this.b = b;\r\n\t    }\r\n\t    return Tuple2;\r\n\t}());\r\n\texports.Tuple2 = Tuple2;\r\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar typescript_collections_1 = __webpack_require__(5);\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\tvar CellSink_1 = __webpack_require__(28);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\t/**\r\n\t * An interface for implementations of FRP timer systems.\r\n\t */\r\n\tvar TimerSystemImpl = (function () {\r\n\t    function TimerSystemImpl() {\r\n\t    }\r\n\t    return TimerSystemImpl;\r\n\t}());\r\n\texports.TimerSystemImpl = TimerSystemImpl;\r\n\tvar nextSeq = 0;\r\n\tvar Event = (function () {\r\n\t    function Event(t, sAlarm) {\r\n\t        this.t = t;\r\n\t        this.sAlarm = sAlarm;\r\n\t        this.seq = ++nextSeq;\r\n\t    }\r\n\t    return Event;\r\n\t}());\r\n\tvar TimerSystem = (function () {\r\n\t    function TimerSystem(impl) {\r\n\t        var _this = this;\r\n\t        this.eventQueue = new typescript_collections_1.BSTree(function (a, b) {\r\n\t            if (a.t < b.t)\r\n\t                return -1;\r\n\t            if (a.t > b.t)\r\n\t                return 1;\r\n\t            if (a.seq < b.seq)\r\n\t                return -1;\r\n\t            if (a.seq > b.seq)\r\n\t                return 1;\r\n\t            return 0;\r\n\t        });\r\n\t        Transaction_1.transactionally(function () {\r\n\t            _this.impl = impl;\r\n\t            var timeSnk = new CellSink_1.CellSink(impl.now());\r\n\t            _this.time = timeSnk;\r\n\t            // A dummy listener to time to keep it alive even when there are no other listeners.\r\n\t            _this.time.listen(function (t) { });\r\n\t            Transaction_1.Transaction.onStart(function () {\r\n\t                var t = impl.now();\r\n\t                // Pop and execute all events earlier than or equal to t (the current time).\r\n\t                var _loop_1 = function() {\r\n\t                    var ev = null;\r\n\t                    if (!_this.eventQueue.isEmpty()) {\r\n\t                        var mev = _this.eventQueue.minimum();\r\n\t                        if (mev.t <= t) {\r\n\t                            ev = mev;\r\n\t                        }\r\n\t                    }\r\n\t                    if (ev != null) {\r\n\t                        timeSnk.send(ev.t);\r\n\t                        Transaction_1.transactionally(function () { return ev.sAlarm.send_(ev.t); });\r\n\t                    }\r\n\t                    else\r\n\t                        return \"break\";\r\n\t                };\r\n\t                while (true) {\r\n\t                    var state_1 = _loop_1();\r\n\t                    if (state_1 === \"break\") break;\r\n\t                }\r\n\t                timeSnk.send(t);\r\n\t            });\r\n\t        });\r\n\t    }\r\n\t    /**\r\n\t     * A timer that fires at the specified time, which can be null, meaning\r\n\t     * that the alarm is not set.\r\n\t     */\r\n\t    TimerSystem.prototype.at = function (tAlarm) {\r\n\t        var _this = this;\r\n\t        var current = null, cancelCurrent = null, active = false, tAl = null, sampled = false;\r\n\t        var sAlarm = new Stream_1.StreamWithSend(null), updateTimer = function () {\r\n\t            if (cancelCurrent !== null) {\r\n\t                cancelCurrent();\r\n\t                _this.eventQueue.remove(current);\r\n\t            }\r\n\t            cancelCurrent = null;\r\n\t            current = null;\r\n\t            if (active) {\r\n\t                if (!sampled) {\r\n\t                    sampled = true;\r\n\t                    tAl = tAlarm.sampleNoTrans__();\r\n\t                }\r\n\t                if (tAl !== null) {\r\n\t                    current = new Event(tAl, sAlarm);\r\n\t                    _this.eventQueue.add(current);\r\n\t                    cancelCurrent = _this.impl.setTimer(tAl, function () {\r\n\t                        // Open and close a transaction to trigger queued\r\n\t                        // events to run.\r\n\t                        Transaction_1.transactionally(function () { });\r\n\t                    });\r\n\t                }\r\n\t            }\r\n\t        };\r\n\t        sAlarm.setVertex__(new Vertex_1.Vertex(\"at\", 0, [\r\n\t            new Vertex_1.Source(tAlarm.getVertex__(), function () {\r\n\t                active = true;\r\n\t                sampled = false;\r\n\t                Transaction_1.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\r\n\t                var kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), function (oAlarm) {\r\n\t                    tAl = oAlarm;\r\n\t                    sampled = true;\r\n\t                    updateTimer();\r\n\t                }, false);\r\n\t                return function () {\r\n\t                    active = false;\r\n\t                    updateTimer();\r\n\t                    kill();\r\n\t                };\r\n\t            })\r\n\t        ]));\r\n\t        return sAlarm;\r\n\t    };\r\n\t    return TimerSystem;\r\n\t}());\r\n\texports.TimerSystem = TimerSystem;\r\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar TimerSystem_1 = __webpack_require__(30);\r\n\t/**\r\n\t * A timer system implementation using seconds as the time unit.\r\n\t */\r\n\tvar SecondsTimerSystem = (function (_super) {\r\n\t    __extends(SecondsTimerSystem, _super);\r\n\t    function SecondsTimerSystem() {\r\n\t        _super.call(this, new SecondsTimerSystemImpl());\r\n\t    }\r\n\t    return SecondsTimerSystem;\r\n\t}(TimerSystem_1.TimerSystem));\r\n\texports.SecondsTimerSystem = SecondsTimerSystem;\r\n\tvar SecondsTimerSystemImpl = (function (_super) {\r\n\t    __extends(SecondsTimerSystemImpl, _super);\r\n\t    function SecondsTimerSystemImpl() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    /**\r\n\t     * Set a timer that will execute the specified callback at the specified time.\r\n\t     * @return A function that can be used to cancel the timer.\r\n\t     */\r\n\t    SecondsTimerSystemImpl.prototype.setTimer = function (t, callback) {\r\n\t        var timeout = setTimeout(callback, (t - this.now()) * 1000);\r\n\t        return function () { clearTimeout(timeout); };\r\n\t    };\r\n\t    /**\r\n\t     * Return the current clock time.\r\n\t     */\r\n\t    SecondsTimerSystemImpl.prototype.now = function () {\r\n\t        return Date.now() * 0.001;\r\n\t    };\r\n\t    return SecondsTimerSystemImpl;\r\n\t}(TimerSystem_1.TimerSystemImpl));\r\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar __extends = (this && this.__extends) || function (d, b) {\r\n\t    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n\t    function __() { this.constructor = d; }\r\n\t    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n\t};\r\n\tvar TimerSystem_1 = __webpack_require__(30);\r\n\t/**\r\n\t * A timer system implementation using milliseconds as the time unit.\r\n\t */\r\n\tvar MillisecondsTimerSystem = (function (_super) {\r\n\t    __extends(MillisecondsTimerSystem, _super);\r\n\t    function MillisecondsTimerSystem() {\r\n\t        _super.call(this, new MillisecondsTimerSystemImpl());\r\n\t    }\r\n\t    return MillisecondsTimerSystem;\r\n\t}(TimerSystem_1.TimerSystem));\r\n\texports.MillisecondsTimerSystem = MillisecondsTimerSystem;\r\n\tvar MillisecondsTimerSystemImpl = (function (_super) {\r\n\t    __extends(MillisecondsTimerSystemImpl, _super);\r\n\t    function MillisecondsTimerSystemImpl() {\r\n\t        _super.apply(this, arguments);\r\n\t    }\r\n\t    /**\r\n\t     * Set a timer that will execute the specified callback at the specified time.\r\n\t     * @return A function that can be used to cancel the timer.\r\n\t     */\r\n\t    MillisecondsTimerSystemImpl.prototype.setTimer = function (t, callback) {\r\n\t        var timeout = setTimeout(callback, t - this.now());\r\n\t        return function () { clearTimeout(timeout); };\r\n\t    };\r\n\t    /**\r\n\t     * Return the current clock time.\r\n\t     */\r\n\t    MillisecondsTimerSystemImpl.prototype.now = function () {\r\n\t        return Date.now();\r\n\t    };\r\n\t    return MillisecondsTimerSystemImpl;\r\n\t}(TimerSystem_1.TimerSystemImpl));\r\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\tvar Stream_1 = __webpack_require__(3);\r\n\tvar Vertex_1 = __webpack_require__(2);\r\n\tvar Transaction_1 = __webpack_require__(4);\r\n\tvar IOAction = (function () {\r\n\t    function IOAction() {\r\n\t    }\r\n\t    /*!\r\n\t     * Convert a function that performs asynchronous I/O taking input A\r\n\t     * and returning a value of type B into an I/O action of type\r\n\t     * (sa : Stream<A>) => Stream<B>\r\n\t     */\r\n\t    IOAction.fromAsync = function (performIO) {\r\n\t        return function (sa) {\r\n\t            var out = new Stream_1.StreamWithSend(null);\r\n\t            out.setVertex__(new Vertex_1.Vertex(\"map\", 0, [\r\n\t                new Vertex_1.Source(sa.getVertex__(), function () {\r\n\t                    return sa.listen_(out.getVertex__(), function (a) {\r\n\t                        performIO(a, function (b) {\r\n\t                            Transaction_1.transactionally(function () {\r\n\t                                out.send_(b);\r\n\t                            });\r\n\t                        });\r\n\t                    }, false);\r\n\t                })\r\n\t            ]));\r\n\t            return out;\r\n\t        };\r\n\t    };\r\n\t    return IOAction;\r\n\t}());\r\n\texports.IOAction = IOAction;\r\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** sodium.umd.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap eadf33d06606958bd9c7\n **/","export { lambda1, lambda2, lambda3, lambda4, lambda5, lambda6 } from \"./Lambda\";\nexport { Stream, StreamLoop } from \"./Stream\";\nexport { StreamSink } from \"./StreamSink\";\nexport { Cell } from \"./Cell\";\nexport { CellLoop } from \"./CellLoop\";\nexport { CellSink } from \"./CellSink\";\nexport { transactionally } from \"./Transaction\";\nexport { Tuple2 } from \"./Tuple2\";\nexport { Unit } from \"./Unit\";\nexport { Operational } from \"./Operational\";\nexport { getTotalRegistrations, Vertex } from \"./Vertex\";\nexport { TimerSystemImpl, TimerSystem } from \"./TimerSystem\";\nexport { SecondsTimerSystem } from \"./SecondsTimerSystem\";\nexport { MillisecondsTimerSystem } from \"./MillisecondsTimerSystem\";\nexport { IOAction } from \"./IOAction\";\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Sodium.ts\n **/","import { Stream } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { Source } from \"./Vertex\";\n\nexport class Lambda1<A,B> {\n    constructor(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A) => B;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda1<A,B>(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda1<A,B>\n{\n    return new Lambda1(f, deps);\n}\n\nexport function Lambda1_deps<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda1)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda1_toFunction<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : (a : A) => B {\n    if (f instanceof Lambda1)\n        return f.f;\n    else\n        return <(a : A) => B>f;\n}\n\nexport class Lambda2<A,B,C> {\n    constructor(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B) => C;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda2<A,B,C>(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda2<A,B,C>\n{\n    return new Lambda2(f, deps);\n}\n\nexport function Lambda2_deps<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda2)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda2_toFunction<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : (a : A, b : B) => C {\n    if (f instanceof Lambda2)\n        return f.f;\n    else\n        return <(a : A, b : B) => C>f;\n}\n\nexport class Lambda3<A,B,C,D> {\n    constructor(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C) => D;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda3<A,B,C,D>(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda3<A,B,C,D>\n{\n    return new Lambda3(f, deps);\n}\n\nexport function Lambda3_deps<A,B,C,D>(f : ((a : A, b : B, c : C) => D)\n        | Lambda3<A,B,C,D>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda3)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda3_toFunction<A,B,C,D>(f : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : (a : A, b : B, c : C) => D {\n    if (f instanceof Lambda3)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C) => D>f;\n}\n\nexport class Lambda4<A,B,C,D,E> {\n    constructor(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D) => E;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda4<A,B,C,D,E>(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda4<A,B,C,D,E>\n{\n    return new Lambda4(f, deps);\n}\n\nexport function Lambda4_deps<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda4)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda4_toFunction<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : (a : A, b : B, c : C, d : D) => E {\n    if (f instanceof Lambda4)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D) => E>f;\n}\n\nexport class Lambda5<A,B,C,D,E,F> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E) => F;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda5<A,B,C,D,E,F>(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda5<A,B,C,D,E,F>\n{\n    return new Lambda5(f, deps);\n}\n\nexport function Lambda5_deps<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda5)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda5_toFunction<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : (a : A, b : B, c : C, d : D, e : E) => F {\n    if (f instanceof Lambda5)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E) => F>f;\n}\n\nexport class Lambda6<A,B,C,D,E,F,G> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E, f : F) => G;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda6<A,B,C,D,E,F,G>(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda6<A,B,C,D,E,F,G>\n{\n    return new Lambda6(f, deps);\n}\n\nexport function Lambda6_deps<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda6)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda6_toFunction<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : (a : A, b : B, c : C, d : D, e : E, f : F) => G {\n    if (f instanceof Lambda6)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E, f : F) => G>f;\n}\n\nexport function toSources(deps : Array<Stream<any>|Cell<any>>) : Source[] {\n    const ss : Source[] = [];\n    for (let i = 0; i < deps.length; i++) {\n        const dep = deps[i];\n        ss.push(new Source(dep.getVertex__(), null));\n    }\n    return ss;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Lambda.ts\n **/","import { Set } from \"typescript-collections\";\n\nlet totalRegistrations : number = 0;\nexport function getTotalRegistrations() : number {\n    return totalRegistrations;\n}\n\nexport class Source {\n    constructor(\n        origin : Vertex,\n        register_ : () => () => void\n    ) {\n        if (origin === null)\n            throw new Error(\"null origin!\");\n        this.origin = origin;\n        this.register_ = register_;\n    }\n    origin : Vertex;\n    private register_ : () => () => void;\n    private registered : boolean = false;\n    private deregister_ : () => void = null;\n\n    register(target : Vertex) : void {\n        if (!this.registered) {\n            this.registered = true;\n            if (this.register_ !== null)\n                this.deregister_ = this.register_();\n            else {\n                this.origin.increment(target);\n                this.deregister_ = () => this.origin.decrement(target);\n            }\n        }\n    }\n    deregister(target : Vertex) : void {\n        if (this.registered) {\n            this.registered = false;\n            if (this.deregister_ !== null)\n                this.deregister_();\n        }\n    }\n}\n\nexport enum Color { black, gray, white, purple };\nlet roots : Vertex[] = [];\nlet nextID : number = 0;\nlet verbose : boolean = false;\n\nexport function setVerbose(v : boolean) : void { verbose = v; }\n\nexport function describeAll(v : Vertex, visited : Set<number>)\n{\n    if (visited.contains(v.id)) return;\n    console.log(v.descr());\n    visited.add(v.id);\n    let chs = v.children();\n    for (let i = 0; i < chs.length; i++)\n        describeAll(chs[i], visited);\n}\n\nexport class Vertex {\n    static NULL : Vertex = new Vertex(\"user\", 1e12, []);\n    id : number;\n\n\tconstructor(name : string, rank : number, sources : Source[]) {\n\t    this.name = name;\n\t\tthis.rank = rank;\n\t\tthis.sources = sources;\n\t\tthis.id = nextID++;\n\t}\n\tname : string;\n    rank : number;\n    sources : Source[];\n    targets : Vertex[] = [];\n    childrn : Vertex[] = [];\n    refCount() : number { return this.targets.length; };\n    visited : boolean = false;\n    register(target : Vertex) : boolean {\n        return this.increment(target);\n    }\n    deregister(target : Vertex) : void {\n        if (verbose)\n            console.log(\"deregister \"+this.descr()+\" => \"+target.descr());\n        this.decrement(target);\n        Vertex.collectCycles();\n    }\n    private incRefCount(target : Vertex) : boolean {\n        let anyChanged : boolean = false;\n        if (this.refCount() == 0) {\n            for (let i = 0; i < this.sources.length; i++)\n                this.sources[i].register(this);\n        }\n        this.targets.push(target);\n        target.childrn.push(this);\n        if (target.ensureBiggerThan(this.rank))\n            anyChanged = true;\n        totalRegistrations++;\n        return anyChanged;\n    }\n\n    private decRefCount(target : Vertex) : void {\n        if (verbose)\n            console.log(\"DEC \"+this.descr());\n        let matched = false;\n        for (let i = 0; i < target.childrn.length; i++)\n            if (target.childrn[i] === this) {\n                target.childrn.splice(i, 1);\n            }\n        for (let i = 0; i < this.targets.length; i++)\n            if (this.targets[i] === target) {\n                this.targets.splice(i, 1);\n                matched = true;\n                break;\n            }\n        if (matched) {\n            if (this.refCount() == 0) {\n                for (let i = 0; i < this.sources.length; i++)\n                    this.sources[i].deregister(this);\n            }\n            totalRegistrations--;\n        }\n    }\n\n    addSource(src : Source) : void {\n        this.sources.push(src);\n        if (this.refCount() > 0)\n            src.register(this);\n    }\n\n\tprivate ensureBiggerThan(limit : number) : boolean {\n\t\tif (this.rank > limit || this.visited)\n\t\t\treturn false;\n\n        this.visited = true;\n\t\tthis.rank = limit + 1;\n\t\tfor (let i = 0; i < this.targets.length; i++)\n\t\t\tthis.targets[i].ensureBiggerThan(this.rank);\n        this.visited = false;\n\t\treturn true;\n\t}\n\n\tdescr() : string {\n        let colStr : string = null;\n        switch (this.color) {\n        case Color.black: colStr = \"black\"; break;\n        case Color.gray:  colStr = \"gray\"; break;\n        case Color.white: colStr = \"white\"; break;\n        case Color.purple: colStr = \"purple\"; break;\n        }\n        let str = this.id+\" \"+this.name+\" [\"+this.refCount()+\"/\"+this.refCountAdj+\"] \"+colStr+\" ->\";\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            str = str + \" \" + chs[i].id;\n        }\n        return str;\n\t}\n\n\t// --------------------------------------------------------\n\t// Synchronous Cycle Collection algorithm presented in \"Concurrent\n\t// Cycle Collection in Reference Counted Systems\" by David F. Bacon\n\t// and V.T. Rajan.\n\n    color : Color = Color.black;\n    buffered : boolean = false;\n    refCountAdj : number = 0;\n\n\tchildren() : Vertex[] { return this.childrn; }\n\n\tincrement(referrer : Vertex) : boolean {\n\t    return this.incRefCount(referrer);\n\t}\n\n\tdecrement(referrer : Vertex) : void {\n\t    this.decRefCount(referrer);\n\t    if (this.refCount() == 0)\n\t        this.release();\n        else\n            this.possibleRoots();\n\t}\n\n    release() : void {\n        this.color = Color.black;\n        if (!this.buffered)\n            this.free();\n    }\n\n    free() : void {\n        while (this.targets.length > 0)\n            this.decRefCount(this.targets[0]);\n    }\n\n\tpossibleRoots() : void {\n\t    if (this.color != Color.purple) {\n\t        this.color = Color.purple;\n\t        if (!this.buffered) {\n                this.buffered = true;\n                roots.push(this);\n            }\n        }\n\t}\n\n\tstatic collectCycles() : void {\n\t    Vertex.markRoots();\n\t    Vertex.scanRoots();\n\t    Vertex.collectRoots();\n\t}\n\n\tstatic markRoots() : void {\n\t    const newRoots : Vertex[] = [];\n\t    for (let i = 0; i < roots.length; i++) {\n            if (verbose)\n                console.log(\"markRoots \"+roots[i].descr());  // ###\n\t        if (roots[i].color == Color.purple) {\n\t            roots[i].markGray();\n\t            newRoots.push(roots[i]);\n            }\n\t        else {\n\t            roots[i].buffered = false;\n\t            if (roots[i].color == Color.black && roots[i].refCount() == 0)\n\t                roots[i].free();\n            }\n\t    }\n\t    roots = newRoots;\n\t}\n\n\tstatic scanRoots() : void {\n\t    for (let i = 0; i < roots.length; i++)\n\t        roots[i].scan();\n\t}\n\n\tstatic collectRoots() : void {\n\t    for (let i = 0; i < roots.length; i++) {\n\t        roots[i].buffered = false;\n\t        roots[i].collectWhite();\n\t    }\n\t    roots = [];\n\t}\n\n\tmarkGray() : void {\n\t    if (this.color != Color.gray) {\n\t        this.color = Color.gray;\n\t        let chs = this.children();\n\t        for (let i = 0; i < chs.length; i++) {\n\t            chs[i].refCountAdj--;\n                if (verbose)\n                    console.log(\"markGray \"+this.descr());\n\t            chs[i].markGray();\n            }\n\t    }\n\t}\n\n\tscan() : void {\n\t    if (verbose)\n            console.log(\"scan \"+this.descr());\n\t    if (this.color == Color.gray) {\n\t        if (this.refCount()+this.refCountAdj > 0)\n\t            this.scanBlack();\n\t        else {\n\t            this.color = Color.white;\n                if (verbose)\n                    console.log(\"scan WHITE \"+this.descr());\n                let chs = this.children();\n                for (let i = 0; i < chs.length; i++)\n                    chs[i].scan();\n\t        }\n\t    }\n\t}\n\n\tscanBlack() : void {\n\t    this.color = Color.black;\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            chs[i].refCountAdj++;\n            if (verbose)\n                console.log(\"scanBlack \"+this.descr());\n            if (chs[i].color != Color.black)\n                chs[i].scanBlack();\n        }\n\t}\n\n\tcollectWhite() : void {\n\t    if (this.color == Color.white && !this.buffered) {\n            if (verbose)\n                console.log(\"collectWhite \"+this.descr());\n\t        this.color = Color.black;\n\t        this.refCountAdj = 0;\n            let chs = this.children();\n            for (let i = 0; i < chs.length; i++)\n                chs[i].collectWhite();\n            this.free();\n\t    }\n\t}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Vertex.ts\n **/","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction, transactionally, currentTransaction } from \"./Transaction\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { Cell } from \"./Cell\";\n//import { StreamLoop } from \"./StreamLoop\";\nimport { Listener } from \"./Listener\";\nimport { Tuple2 } from \"./Tuple2\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\n\nexport class Stream<A> {\n    constructor(vertex? : Vertex) {\n        this.vertex = vertex ? vertex : new Vertex(\"Stream\", 0, []);\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    protected vertex : Vertex;\n    protected listeners : Array<Listener<A>> = [];\n    protected firings : A[] = [];\n\n    /**\n     * Transform the stream's event values according to the supplied function, so the returned\n     * Stream's event values reflect the value of the function applied to the input\n     * Stream's event values.\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"map\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a));\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Transform the stream's event values into the specified constant value.\n     * @param b Constant value.\n     */\n    mapTo<B>(b : B) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"mapTo\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(b);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\n     * in the simultaneous case.\n     * <p>\n     * In the case where two events are simultaneous (i.e. both\n     * within the same transaction), the event from <em>this</em> will take precedence, and\n     * the event from <em>s</em> will be dropped.\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\n     * <p>\n     * The name orElse() is used instead of merge() to make it really clear that care should\n     * be taken, because events can be dropped.\n     */\n    orElse(s : Stream<A>) : Stream<A> {\n        return this.merge(s, (left : A, right: A) => {\n            return left;\n        });\n    }\n\n    private merge_(s : Stream<A>) : Stream<A> {\n        const out = new StreamWithSend<A>();\n        const left = new Vertex(\"merge\", 0, []);\n        left.sources.push(new Source(this.vertex, () => {\n            return this.listen_(left, (a : A) => {\n                    out.send_(a);\n                }, false);\n        }));\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    left,\n                    () => {\n                        left.register(out.vertex);\n                        return () => { left.deregister(out.vertex); }\n                    }\n                ),\n                new Source(\n                    s.vertex,\n                    () => {\n                        return s.listen_(out.vertex, (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                )\n            ]);\n        return out;\n    }\n\n    coalesce__(f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {  // TO DO figure out how to hide this\n        const out = new StreamWithSend<A>();\n        const coalescer = new CoalesceHandler<A>(f, out);\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            coalescer.send_(a);\n                        }, false);\n                    }\n                )\n            ]).concat(toSources(Lambda2_deps(f)));\n        return out;\n    }\n\n    /**\n     * Merge two streams of the same type into one, so that events on either input appear\n     * on the returned stream.\n     * <p>\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\n     * occurring in the same transaction), combine them into one using the specified combining function\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\n     * The event from <em>this</em> will appear at the left input of the combining function, and\n     * the event from <em>s</em> will appear at the right.\n     * @param f Function to combine the values. It may construct FRP logic or use\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    merge(s : Stream<A>, f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {\n        return transactionally<Stream<A>>(() => {\n            return this.merge_(s).coalesce__(f);\n        });\n    }\n\n    /**\n     * Return a stream that only outputs events for which the predicate returns true.\n     */\n    filter(f : ((a : A) => boolean) | Lambda1<A,boolean>) : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"filter\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (ff(a))\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events that have present\n     * values, discarding null values.\n     */\n    filterNotNull() : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        out.vertex = new Vertex(\"filterNotNull\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (a !== null)\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events from the input stream\n     * when the specified cell's value is true.\n     */\n    gate(c : Cell<boolean>) : Stream<A> {\n        return this.snapshot(c, (a : A, pred : boolean) => {\n            return pred ? a : null;\n        }).filterNotNull();\n    }\n\n\t/**\n\t * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\n\t * at the time of the event firing, ignoring the stream's value.\n\t */\n\tsnapshot1<B>(c : Cell<B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"snapshot1\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(c.sampleNoTrans__());\n                        }, false);\n                    }\n                ),\n                new Source(c.getVertex__(), null)\n            ]\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cell at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot<B,C>(c : Cell<B>, f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Stream<C>\n\t{\n        const out = new StreamWithSend<C>(null);\n        const ff = Lambda2_toFunction(f);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, c.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(c.getVertex__(), null)\n            ].concat(toSources(Lambda2_deps(f)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Create a {@link Cell} with the specified initial value, that is updated\n     * by this stream's event values.\n     * <p>\n     * There is an implicit delay: State updates caused by event firings don't become\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\n     * until the following transaction. To put this another way,\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\n     * any state changes from the current transaction.\n     */\n    hold(initValue : A) : Cell<A> {\n        return new Cell<A>(initValue, this);\n\t}\n\n\t/**\n\t * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\n\t */\n\tholdLazy(initValue : Lazy<A>) : Cell<A> {\n\t    return new LazyCell<A>(initValue, this);\n\t}\n\n    /**\n     * Transform an event with a generalized state loop (a Mealy machine). The function\n     * is passed the input and the old state and returns the new state and output value.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    collect<B,S>(initState : S, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        return this.collectLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    collectLazy<B,S>(initState : Lazy<S>, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        const ea = this;\n        return transactionally(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                ebs = ea.snapshot(s, f),\n                eb = ebs.map((bs : Tuple2<B,S>) => { return bs.a; }),\n                es_out = ebs.map((bs : Tuple2<B,S>) => { return bs.b; });\n            es.loop(es_out);\n            return eb;\n        });\n    }\n\n    /**\n     * Accumulate on input event, outputting the new state each time.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    accum<S>(initState : S, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        return this.accumLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    accumLazy<S>(initState : Lazy<S>, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        const ea = this;\n        return transactionally(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                es_out = ea.snapshot(s, f);\n            es.loop(es_out);\n            return es_out.holdLazy(initState);\n        });\n    }\n\n    /**\n     * Return a stream that outputs only one value: the next event of the\n     * input stream, starting from the transaction in which once() was invoked.\n     */\n    once() : Stream<A> {\n    /*\n        return transactionally(() => {\n            const ev = this,\n                out = new StreamWithSend<A>();\n            let la : () => void = null;\n            la = ev.listen_(out.vertex, (a : A) => {\n                if (la !== null) {\n                    out.send_(a);\n                    la();\n                    la = null;\n                }\n            }, false);\n            return out;\n        });\n        */\n        // We can't use the implementation above, beacuse deregistering\n        // listeners triggers the exception\n        // \"send() was invoked before listeners were registered\"\n        // We can revisit this another time. For now we will use the less\n        // efficient implementation below.\n        const me = this;\n        return transactionally(() => me.gate(me.mapTo(false).hold(true)));\n    }\n\n    listen(h : (a : A) => void) : () => void {\n        return transactionally<() => void>(() => {\n            return this.listen_(Vertex.NULL, h, false);\n        });\n    }\n\n    listen_(target : Vertex,\n            h : (a : A) => void,\n            suppressEarlierFirings : boolean) : () => void {\n        if (this.vertex.register(target))\n            currentTransaction.requestRegen();\n        const listener = new Listener<A>(h, target);\n        this.listeners.push(listener);\n        if (!suppressEarlierFirings && this.firings.length != 0) {\n            const firings = this.firings.slice();\n            currentTransaction.prioritized(target, () => {\n                // Anything sent already in this transaction must be sent now so that\n                // there's no order dependency between send and listen.\n                for (let i = 0; i < firings.length; i++)\n                    h(firings[i]);\n            });\n        }\n        return () => {\n            let removed = false;\n            for (let i = 0; i < this.listeners.length; i++) {\n                if (this.listeners[i] == listener) {\n                    this.listeners.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (removed)\n                this.vertex.deregister(target);\n        };\n    }\n}\n\nexport class StreamWithSend<A> extends Stream<A> {\n    constructor(vertex? : Vertex) {\n        super(vertex);\n    }\n    \n    setVertex__(vertex : Vertex) {  // TO DO figure out how to hide this\n        this.vertex = vertex;\n    }\n\n    send_(a : A) : void {\n        // We throw this error if we send into FRP logic that has been constructed\n        // but nothing is listening to it yet. We need to do it this way because\n        // it's the only way to manage memory in a language with no finalizers.\n        if (this.vertex.refCount() == 0)\n            throw new Error(\"send() was invoked before listeners were registered\");\n\t\tif (this.firings.length == 0)\n\t\t\tcurrentTransaction.last(() => {\n\t\t\t    this.firings = [];\n            });\n\t\tthis.firings.push(a);\n\t\tconst listeners = this.listeners.slice();\n        for (let i = 0; i < listeners.length; i++) {\n            const h = listeners[i].h;\n            currentTransaction.prioritized(listeners[i].target, () => {\n                currentTransaction.inCallback++;\n                try {\n                    h(a);\n                    currentTransaction.inCallback--;\n                }\n                catch (err) {\n                    currentTransaction.inCallback--;\n                    throw err;\n                }\n            });\n        }\n    }\n}\n\n/**\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced. \n */\nexport class StreamLoop<A> extends StreamWithSend<A> {\n    assigned__ : boolean = false;  // to do: Figure out how to hide this\n\n    constructor()\n    {\n        super();\n        this.vertex.name = \"StreamLoop\";\n    \tif (currentTransaction === null)\n    \t    throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\n    }\n\n    /**\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(sa_out : Stream<A>) : void {\n        if (this.assigned__)\n            throw new Error(\"StreamLoop looped more than once\");\n        this.assigned__ = true;\n        this.vertex.addSource(\n            new Source(\n                sa_out.getVertex__(),\n                () => {\n                    return sa_out.listen_(this.vertex, (a : A) => {\n                        this.send_(a);\n                    }, false);\n                }\n            )\n        );\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Stream.ts\n **/","import { Vertex } from './Vertex';\nimport { Set, PriorityQueue } from 'typescript-collections';\n\nexport class Entry {\n    constructor(rank : Vertex, action : () => void) {\n        this.rank = rank; \n        this.action = action;\n        this.seq = Entry.nextSeq++;\n    }\n    private static nextSeq : number = 0;\n    rank : Vertex;\n    action : () => void;\n    seq : number;\n    toString() : string {\n        return this.seq.toString();\n    }\n}\n\nexport class Transaction {\n    constructor() {}\n    inCallback : number = 0;\n    private toRegen : boolean = false;\n    requestRegen() : void { this.toRegen = true; }\n    prioritizedQ : PriorityQueue<Entry> = new PriorityQueue<Entry>((a, b) => {\n        // Note: Low priority numbers are treated as \"greater\" according to this\n        // comparison, so that the lowest numbers are highest priority and go first.\n        if (a.rank.rank < b.rank.rank) return 1;\n        if (a.rank.rank > b.rank.rank) return -1;\n        if (a.seq < b.seq) return 1;\n        if (a.seq > b.seq) return -1;\n        return 0;\n    });\n    private entries : Set<Entry> = new Set<Entry>((a) => a.toString());\n    private lastQ : Array<() => void> = [];\n    private postQ : Array<() => void> = null;\n\n    prioritized(target : Vertex, f : () => void) : void {\n        const e = new Entry(target, f);\n        this.prioritizedQ.enqueue(e);\n        this.entries.add(e);\n    }\n    \n    last(h : () => void) : void {\n        this.lastQ.push(h);\n    }\n\n\t/**\n     * Add an action to run after all last() actions.\n     */\n\tpost(childIx : number, action : () => void) : void {\n\t    if (this.postQ == null)\n\t        this.postQ = [];\n\t    // If an entry exists already, combine the old one with the new one.\n\t    while (this.postQ.length <= childIx)\n\t        this.postQ.push(null);\n\t    const existing = this.postQ[childIx],\n\t        neu =\n                existing === null ? action\n\t                         : () => {\n\t                               existing();\n\t                               action();\n                               };\n\t    this.postQ[childIx] = neu;\n\t}\n\n\t// If the priority queue has entries in it when we modify any of the nodes'\n\t// ranks, then we need to re-generate it to make sure it's up-to-date.\n\tprivate checkRegen() : void\n\t{\n\t    if (this.toRegen) {\n\t        this.toRegen = false;\n\t        this.prioritizedQ.clear();\n\t        const es = this.entries.toArray();\n\t        for (let i : number = 0; i < es.length; i++)\n\t            this.prioritizedQ.enqueue(es[i]);\n\t    }\n\t}\n\n    close() : void {\n\t    while (true) {\n\t        this.checkRegen();\n\t\t    if (this.prioritizedQ.isEmpty()) break;\n\t\t    const e = this.prioritizedQ.dequeue();\n\t\t    this.entries.remove(e);\n\t\t\te.action();\n\t\t}\n\t\tfor (let i = 0; i < this.lastQ.length; i++)\n\t\t    this.lastQ[i]();\n        this.lastQ = [];\n\t\tif (this.postQ != null) {\n\t\t    for (let i = 0; i < this.postQ.length; i++) {\n\t\t        if (this.postQ[i] != null) {\n                    const parent = currentTransaction;\n                    try {\n                        if (i > 0) {\n                            currentTransaction = new Transaction();\n                            try {\n                                this.postQ[i]();\n                                currentTransaction.close();\n                            }\n                            catch (err) {\n                                currentTransaction.close();\n                                throw err;\n                            }\n                        }\n                        else {\n                            currentTransaction = null;\n                            this.postQ[i]();\n                        }\n                        currentTransaction = parent;\n                    }\n                    catch (err) {\n                        currentTransaction = parent;\n                        throw err;\n                    }\n                }\n            }\n            this.postQ = null;\n\t\t}\n    }\n\n\t/**\n\t * Add a runnable that will be executed whenever a transaction is started.\n\t * That runnable may start transactions itself, which will not cause the\n\t * hooks to be run recursively.\n\t *\n\t * The main use case of this is the implementation of a time/alarm system.\n\t */\n\tstatic onStart(r : () => void) : void {\n        onStartHooks.push(r);\n\t}\n}\n\nexport let currentTransaction : Transaction = null;\nlet onStartHooks : (() => void)[] = [],\n    runningOnStartHooks : boolean = false;\n\nexport function transactionally<A>(f : () => A) : A {\n    const transWas : Transaction = currentTransaction;\n    if (transWas === null) {\n        if (!runningOnStartHooks) {\n            runningOnStartHooks = true;\n            try {\n                for (let i = 0; i < onStartHooks.length; i++)\n                    onStartHooks[i]();\n            }\n            finally {\n                runningOnStartHooks = false;\n            }\n        }\n        currentTransaction = new Transaction();\n    }\n    try {\n        const a : A = f();\n        if (transWas === null) {\n            currentTransaction.close();\n            currentTransaction = null;\n        }\n        return a;\n    }\n    catch (err) {\n        if (transWas === null) {\n            currentTransaction.close();\n            currentTransaction = null;\n        }\n        throw err;\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Transaction.ts\n **/","\"use strict\";\r\n// Copyright 2013 Basarat Ali Syed. All Rights Reserved.\r\n//\r\n// Licensed under MIT open source license http://opensource.org/licenses/MIT\r\n//\r\n// Orginal javascript code was by Mauricio Santos\r\n//\r\nvar _arrays = require('./arrays');\r\nexports.arrays = _arrays;\r\nvar Bag_1 = require('./Bag');\r\nexports.Bag = Bag_1.default;\r\nvar BSTree_1 = require('./BSTree');\r\nexports.BSTree = BSTree_1.default;\r\nvar Dictionary_1 = require('./Dictionary');\r\nexports.Dictionary = Dictionary_1.default;\r\nvar Heap_1 = require('./Heap');\r\nexports.Heap = Heap_1.default;\r\nvar LinkedDictionary_1 = require('./LinkedDictionary');\r\nexports.LinkedDictionary = LinkedDictionary_1.default;\r\nvar LinkedList_1 = require('./LinkedList');\r\nexports.LinkedList = LinkedList_1.default;\r\nvar MultiDictionary_1 = require('./MultiDictionary');\r\nexports.MultiDictionary = MultiDictionary_1.default;\r\nvar Queue_1 = require('./Queue');\r\nexports.Queue = Queue_1.default;\r\nvar PriorityQueue_1 = require('./PriorityQueue');\r\nexports.PriorityQueue = PriorityQueue_1.default;\r\nvar Set_1 = require('./Set');\r\nexports.Set = Set_1.default;\r\nvar Stack_1 = require('./Stack');\r\nexports.Stack = Stack_1.default;\r\nvar _util = require('./util');\r\nexports.util = _util;\r\n//# sourceMappingURL=index.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/index.js\n ** module id = 5\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\n/**\r\n * Returns the position of the first occurrence of the specified item\r\n * within the specified array.4\r\n * @param {*} array the array in which to search the element.\r\n * @param {Object} item the element to search.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n * check equality between 2 elements.\r\n * @return {number} the position of the first occurrence of the specified element\r\n * within the specified array, or -1 if not found.\r\n */\r\nfunction indexOf(array, item, equalsFunction) {\r\n    var equals = equalsFunction || util.defaultEquals;\r\n    var length = array.length;\r\n    for (var i = 0; i < length; i++) {\r\n        if (equals(array[i], item)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexports.indexOf = indexOf;\r\n/**\r\n * Returns the position of the last occurrence of the specified element\r\n * within the specified array.\r\n * @param {*} array the array in which to search the element.\r\n * @param {Object} item the element to search.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n * check equality between 2 elements.\r\n * @return {number} the position of the last occurrence of the specified element\r\n * within the specified array or -1 if not found.\r\n */\r\nfunction lastIndexOf(array, item, equalsFunction) {\r\n    var equals = equalsFunction || util.defaultEquals;\r\n    var length = array.length;\r\n    for (var i = length - 1; i >= 0; i--) {\r\n        if (equals(array[i], item)) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\nexports.lastIndexOf = lastIndexOf;\r\n/**\r\n * Returns true if the specified array contains the specified element.\r\n * @param {*} array the array in which to search the element.\r\n * @param {Object} item the element to search.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\r\n * check equality between 2 elements.\r\n * @return {boolean} true if the specified array contains the specified element.\r\n */\r\nfunction contains(array, item, equalsFunction) {\r\n    return indexOf(array, item, equalsFunction) >= 0;\r\n}\r\nexports.contains = contains;\r\n/**\r\n * Removes the first ocurrence of the specified element from the specified array.\r\n * @param {*} array the array in which to search element.\r\n * @param {Object} item the element to search.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function to\r\n * check equality between 2 elements.\r\n * @return {boolean} true if the array changed after this call.\r\n */\r\nfunction remove(array, item, equalsFunction) {\r\n    var index = indexOf(array, item, equalsFunction);\r\n    if (index < 0) {\r\n        return false;\r\n    }\r\n    array.splice(index, 1);\r\n    return true;\r\n}\r\nexports.remove = remove;\r\n/**\r\n * Returns the number of elements in the specified array equal\r\n * to the specified object.\r\n * @param {Array} array the array in which to determine the frequency of the element.\r\n * @param {Object} item the element whose frequency is to be determined.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n * check equality between 2 elements.\r\n * @return {number} the number of elements in the specified array\r\n * equal to the specified object.\r\n */\r\nfunction frequency(array, item, equalsFunction) {\r\n    var equals = equalsFunction || util.defaultEquals;\r\n    var length = array.length;\r\n    var freq = 0;\r\n    for (var i = 0; i < length; i++) {\r\n        if (equals(array[i], item)) {\r\n            freq++;\r\n        }\r\n    }\r\n    return freq;\r\n}\r\nexports.frequency = frequency;\r\n/**\r\n * Returns true if the two specified arrays are equal to one another.\r\n * Two arrays are considered equal if both arrays contain the same number\r\n * of elements, and all corresponding pairs of elements in the two\r\n * arrays are equal and are in the same order.\r\n * @param {Array} array1 one array to be tested for equality.\r\n * @param {Array} array2 the other array to be tested for equality.\r\n * @param {function(Object,Object):boolean=} equalsFunction optional function used to\r\n * check equality between elemements in the arrays.\r\n * @return {boolean} true if the two arrays are equal\r\n */\r\nfunction equals(array1, array2, equalsFunction) {\r\n    var equals = equalsFunction || util.defaultEquals;\r\n    if (array1.length !== array2.length) {\r\n        return false;\r\n    }\r\n    var length = array1.length;\r\n    for (var i = 0; i < length; i++) {\r\n        if (!equals(array1[i], array2[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nexports.equals = equals;\r\n/**\r\n * Returns shallow a copy of the specified array.\r\n * @param {*} array the array to copy.\r\n * @return {Array} a copy of the specified array\r\n */\r\nfunction copy(array) {\r\n    return array.concat();\r\n}\r\nexports.copy = copy;\r\n/**\r\n * Swaps the elements at the specified positions in the specified array.\r\n * @param {Array} array The array in which to swap elements.\r\n * @param {number} i the index of one element to be swapped.\r\n * @param {number} j the index of the other element to be swapped.\r\n * @return {boolean} true if the array is defined and the indexes are valid.\r\n */\r\nfunction swap(array, i, j) {\r\n    if (i < 0 || i >= array.length || j < 0 || j >= array.length) {\r\n        return false;\r\n    }\r\n    var temp = array[i];\r\n    array[i] = array[j];\r\n    array[j] = temp;\r\n    return true;\r\n}\r\nexports.swap = swap;\r\nfunction toString(array) {\r\n    return '[' + array.toString() + ']';\r\n}\r\nexports.toString = toString;\r\n/**\r\n * Executes the provided function once for each element present in this array\r\n * starting from index 0 to length - 1.\r\n * @param {Array} array The array in which to iterate.\r\n * @param {function(Object):*} callback function to execute, it is\r\n * invoked with one argument: the element value, to break the iteration you can\r\n * optionally return false.\r\n */\r\nfunction forEach(array, callback) {\r\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\r\n        var ele = array_1[_i];\r\n        if (callback(ele) === false) {\r\n            return;\r\n        }\r\n    }\r\n}\r\nexports.forEach = forEach;\r\n//# sourceMappingURL=arrays.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/arrays.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\r\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\r\nexports.has = function (obj, prop) {\r\n    return _hasOwnProperty.call(obj, prop);\r\n};\r\n/**\r\n * Default function to compare element order.\r\n * @function\r\n */\r\nfunction defaultCompare(a, b) {\r\n    if (a < b) {\r\n        return -1;\r\n    }\r\n    else if (a === b) {\r\n        return 0;\r\n    }\r\n    else {\r\n        return 1;\r\n    }\r\n}\r\nexports.defaultCompare = defaultCompare;\r\n/**\r\n * Default function to test equality.\r\n * @function\r\n */\r\nfunction defaultEquals(a, b) {\r\n    return a === b;\r\n}\r\nexports.defaultEquals = defaultEquals;\r\n/**\r\n * Default function to convert an object to a string.\r\n * @function\r\n */\r\nfunction defaultToString(item) {\r\n    if (item === null) {\r\n        return 'COLLECTION_NULL';\r\n    }\r\n    else if (isUndefined(item)) {\r\n        return 'COLLECTION_UNDEFINED';\r\n    }\r\n    else if (isString(item)) {\r\n        return '$s' + item;\r\n    }\r\n    else {\r\n        return '$o' + item.toString();\r\n    }\r\n}\r\nexports.defaultToString = defaultToString;\r\n/**\r\n* Joins all the properies of the object using the provided join string\r\n*/\r\nfunction makeString(item, join) {\r\n    if (join === void 0) { join = ','; }\r\n    if (item === null) {\r\n        return 'COLLECTION_NULL';\r\n    }\r\n    else if (isUndefined(item)) {\r\n        return 'COLLECTION_UNDEFINED';\r\n    }\r\n    else if (isString(item)) {\r\n        return item.toString();\r\n    }\r\n    else {\r\n        var toret = '{';\r\n        var first = true;\r\n        for (var prop in item) {\r\n            if (exports.has(item, prop)) {\r\n                if (first) {\r\n                    first = false;\r\n                }\r\n                else {\r\n                    toret = toret + join;\r\n                }\r\n                toret = toret + prop + ':' + item[prop];\r\n            }\r\n        }\r\n        return toret + '}';\r\n    }\r\n}\r\nexports.makeString = makeString;\r\n/**\r\n * Checks if the given argument is a function.\r\n * @function\r\n */\r\nfunction isFunction(func) {\r\n    return (typeof func) === 'function';\r\n}\r\nexports.isFunction = isFunction;\r\n/**\r\n * Checks if the given argument is undefined.\r\n * @function\r\n */\r\nfunction isUndefined(obj) {\r\n    return (typeof obj) === 'undefined';\r\n}\r\nexports.isUndefined = isUndefined;\r\n/**\r\n * Checks if the given argument is a string.\r\n * @function\r\n */\r\nfunction isString(obj) {\r\n    return Object.prototype.toString.call(obj) === '[object String]';\r\n}\r\nexports.isString = isString;\r\n/**\r\n * Reverses a compare function.\r\n * @function\r\n */\r\nfunction reverseCompareFunction(compareFunction) {\r\n    if (!isFunction(compareFunction)) {\r\n        return function (a, b) {\r\n            if (a < b) {\r\n                return 1;\r\n            }\r\n            else if (a === b) {\r\n                return 0;\r\n            }\r\n            else {\r\n                return -1;\r\n            }\r\n        };\r\n    }\r\n    else {\r\n        return function (d, v) {\r\n            return compareFunction(d, v) * -1;\r\n        };\r\n    }\r\n}\r\nexports.reverseCompareFunction = reverseCompareFunction;\r\n/**\r\n * Returns an equal function given a compare function.\r\n * @function\r\n */\r\nfunction compareToEquals(compareFunction) {\r\n    return function (a, b) {\r\n        return compareFunction(a, b) === 0;\r\n    };\r\n}\r\nexports.compareToEquals = compareToEquals;\r\n//# sourceMappingURL=util.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/util.js\n ** module id = 7\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar Dictionary_1 = require('./Dictionary');\r\nvar Set_1 = require('./Set');\r\nvar Bag = (function () {\r\n    /**\r\n     * Creates an empty bag.\r\n     * @class <p>A bag is a special kind of set in which members are\r\n     * allowed to appear more than once.</p>\r\n     * <p>If the inserted elements are custom objects a function\r\n     * which converts elements to unique strings must be provided. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function petToString(pet) {\r\n     *  return pet.name;\r\n     * }\r\n     * </pre>\r\n     *\r\n     * @constructor\r\n     * @param {function(Object):string=} toStrFunction optional function used\r\n     * to convert elements to strings. If the elements aren't strings or if toString()\r\n     * is not appropriate, a custom function which receives an object and returns a\r\n     * unique string must be provided.\r\n     */\r\n    function Bag(toStrFunction) {\r\n        this.toStrF = toStrFunction || util.defaultToString;\r\n        this.dictionary = new Dictionary_1.default(this.toStrF);\r\n        this.nElements = 0;\r\n    }\r\n    /**\r\n    * Adds nCopies of the specified object to this bag.\r\n    * @param {Object} element element to add.\r\n    * @param {number=} nCopies the number of copies to add, if this argument is\r\n    * undefined 1 copy is added.\r\n    * @return {boolean} true unless element is undefined.\r\n    */\r\n    Bag.prototype.add = function (element, nCopies) {\r\n        if (nCopies === void 0) { nCopies = 1; }\r\n        if (util.isUndefined(element) || nCopies <= 0) {\r\n            return false;\r\n        }\r\n        if (!this.contains(element)) {\r\n            var node = {\r\n                value: element,\r\n                copies: nCopies\r\n            };\r\n            this.dictionary.setValue(element, node);\r\n        }\r\n        else {\r\n            this.dictionary.getValue(element).copies += nCopies;\r\n        }\r\n        this.nElements += nCopies;\r\n        return true;\r\n    };\r\n    /**\r\n    * Counts the number of copies of the specified object in this bag.\r\n    * @param {Object} element the object to search for..\r\n    * @return {number} the number of copies of the object, 0 if not found\r\n    */\r\n    Bag.prototype.count = function (element) {\r\n        if (!this.contains(element)) {\r\n            return 0;\r\n        }\r\n        else {\r\n            return this.dictionary.getValue(element).copies;\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if this bag contains the specified element.\r\n     * @param {Object} element element to search for.\r\n     * @return {boolean} true if this bag contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    Bag.prototype.contains = function (element) {\r\n        return this.dictionary.containsKey(element);\r\n    };\r\n    /**\r\n    * Removes nCopies of the specified object to this bag.\r\n    * If the number of copies to remove is greater than the actual number\r\n    * of copies in the Bag, all copies are removed.\r\n    * @param {Object} element element to remove.\r\n    * @param {number=} nCopies the number of copies to remove, if this argument is\r\n    * undefined 1 copy is removed.\r\n    * @return {boolean} true if at least 1 element was removed.\r\n    */\r\n    Bag.prototype.remove = function (element, nCopies) {\r\n        if (nCopies === void 0) { nCopies = 1; }\r\n        if (util.isUndefined(element) || nCopies <= 0) {\r\n            return false;\r\n        }\r\n        if (!this.contains(element)) {\r\n            return false;\r\n        }\r\n        else {\r\n            var node = this.dictionary.getValue(element);\r\n            if (nCopies > node.copies) {\r\n                this.nElements -= node.copies;\r\n            }\r\n            else {\r\n                this.nElements -= nCopies;\r\n            }\r\n            node.copies -= nCopies;\r\n            if (node.copies <= 0) {\r\n                this.dictionary.remove(element);\r\n            }\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * Returns an array containing all of the elements in this big in arbitrary order,\r\n     * including multiple copies.\r\n     * @return {Array} an array containing all of the elements in this bag.\r\n     */\r\n    Bag.prototype.toArray = function () {\r\n        var a = [];\r\n        var values = this.dictionary.values();\r\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\r\n            var node = values_1[_i];\r\n            var element = node.value;\r\n            var copies = node.copies;\r\n            for (var j = 0; j < copies; j++) {\r\n                a.push(element);\r\n            }\r\n        }\r\n        return a;\r\n    };\r\n    /**\r\n     * Returns a set of unique elements in this bag.\r\n     * @return {collections.Set<T>} a set of unique elements in this bag.\r\n     */\r\n    Bag.prototype.toSet = function () {\r\n        var toret = new Set_1.default(this.toStrF);\r\n        var elements = this.dictionary.values();\r\n        for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {\r\n            var ele = elements_1[_i];\r\n            var value = ele.value;\r\n            toret.add(value);\r\n        }\r\n        return toret;\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element\r\n     * present in this bag, including multiple copies.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element. To break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    Bag.prototype.forEach = function (callback) {\r\n        this.dictionary.forEach(function (k, v) {\r\n            var value = v.value;\r\n            var copies = v.copies;\r\n            for (var i = 0; i < copies; i++) {\r\n                if (callback(value) === false) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Returns the number of elements in this bag.\r\n     * @return {number} the number of elements in this bag.\r\n     */\r\n    Bag.prototype.size = function () {\r\n        return this.nElements;\r\n    };\r\n    /**\r\n     * Returns true if this bag contains no elements.\r\n     * @return {boolean} true if this bag contains no elements.\r\n     */\r\n    Bag.prototype.isEmpty = function () {\r\n        return this.nElements === 0;\r\n    };\r\n    /**\r\n     * Removes all of the elements from this bag.\r\n     */\r\n    Bag.prototype.clear = function () {\r\n        this.nElements = 0;\r\n        this.dictionary.clear();\r\n    };\r\n    return Bag;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Bag; // End of bag\r\n//# sourceMappingURL=Bag.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Bag.js\n ** module id = 8\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar Dictionary = (function () {\r\n    /**\r\n     * Creates an empty dictionary.\r\n     * @class <p>Dictionaries map keys to values; each key can map to at most one value.\r\n     * This implementation accepts any kind of objects as keys.</p>\r\n     *\r\n     * <p>If the keys are custom objects a function which converts keys to unique\r\n     * strings must be provided. Example:</p>\r\n     * <pre>\r\n     * function petToString(pet) {\r\n     *  return pet.name;\r\n     * }\r\n     * </pre>\r\n     * @constructor\r\n     * @param {function(Object):string=} toStrFunction optional function used\r\n     * to convert keys to strings. If the keys aren't strings or if toString()\r\n     * is not appropriate, a custom function which receives a key and returns a\r\n     * unique string must be provided.\r\n     */\r\n    function Dictionary(toStrFunction) {\r\n        this.table = {};\r\n        this.nElements = 0;\r\n        this.toStr = toStrFunction || util.defaultToString;\r\n    }\r\n    /**\r\n     * Returns the value to which this dictionary maps the specified key.\r\n     * Returns undefined if this dictionary contains no mapping for this key.\r\n     * @param {Object} key key whose associated value is to be returned.\r\n     * @return {*} the value to which this dictionary maps the specified key or\r\n     * undefined if the map contains no mapping for this key.\r\n     */\r\n    Dictionary.prototype.getValue = function (key) {\r\n        var pair = this.table['$' + this.toStr(key)];\r\n        if (util.isUndefined(pair)) {\r\n            return undefined;\r\n        }\r\n        return pair.value;\r\n    };\r\n    /**\r\n     * Associates the specified value with the specified key in this dictionary.\r\n     * If the dictionary previously contained a mapping for this key, the old\r\n     * value is replaced by the specified value.\r\n     * @param {Object} key key with which the specified value is to be\r\n     * associated.\r\n     * @param {Object} value value to be associated with the specified key.\r\n     * @return {*} previous value associated with the specified key, or undefined if\r\n     * there was no mapping for the key or if the key/value are undefined.\r\n     */\r\n    Dictionary.prototype.setValue = function (key, value) {\r\n        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n            return undefined;\r\n        }\r\n        var ret;\r\n        var k = '$' + this.toStr(key);\r\n        var previousElement = this.table[k];\r\n        if (util.isUndefined(previousElement)) {\r\n            this.nElements++;\r\n            ret = undefined;\r\n        }\r\n        else {\r\n            ret = previousElement.value;\r\n        }\r\n        this.table[k] = {\r\n            key: key,\r\n            value: value\r\n        };\r\n        return ret;\r\n    };\r\n    /**\r\n     * Removes the mapping for this key from this dictionary if it is present.\r\n     * @param {Object} key key whose mapping is to be removed from the\r\n     * dictionary.\r\n     * @return {*} previous value associated with specified key, or undefined if\r\n     * there was no mapping for key.\r\n     */\r\n    Dictionary.prototype.remove = function (key) {\r\n        var k = '$' + this.toStr(key);\r\n        var previousElement = this.table[k];\r\n        if (!util.isUndefined(previousElement)) {\r\n            delete this.table[k];\r\n            this.nElements--;\r\n            return previousElement.value;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns an array containing all of the keys in this dictionary.\r\n     * @return {Array} an array containing all of the keys in this dictionary.\r\n     */\r\n    Dictionary.prototype.keys = function () {\r\n        var array = [];\r\n        for (var name_1 in this.table) {\r\n            if (util.has(this.table, name_1)) {\r\n                var pair = this.table[name_1];\r\n                array.push(pair.key);\r\n            }\r\n        }\r\n        return array;\r\n    };\r\n    /**\r\n     * Returns an array containing all of the values in this dictionary.\r\n     * @return {Array} an array containing all of the values in this dictionary.\r\n     */\r\n    Dictionary.prototype.values = function () {\r\n        var array = [];\r\n        for (var name_2 in this.table) {\r\n            if (util.has(this.table, name_2)) {\r\n                var pair = this.table[name_2];\r\n                array.push(pair.value);\r\n            }\r\n        }\r\n        return array;\r\n    };\r\n    /**\r\n    * Executes the provided function once for each key-value pair\r\n    * present in this dictionary.\r\n    * @param {function(Object,Object):*} callback function to execute, it is\r\n    * invoked with two arguments: key and value. To break the iteration you can\r\n    * optionally return false.\r\n    */\r\n    Dictionary.prototype.forEach = function (callback) {\r\n        for (var name_3 in this.table) {\r\n            if (util.has(this.table, name_3)) {\r\n                var pair = this.table[name_3];\r\n                var ret = callback(pair.key, pair.value);\r\n                if (ret === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Returns true if this dictionary contains a mapping for the specified key.\r\n     * @param {Object} key key whose presence in this dictionary is to be\r\n     * tested.\r\n     * @return {boolean} true if this dictionary contains a mapping for the\r\n     * specified key.\r\n     */\r\n    Dictionary.prototype.containsKey = function (key) {\r\n        return !util.isUndefined(this.getValue(key));\r\n    };\r\n    /**\r\n    * Removes all mappings from this dictionary.\r\n    * @this {collections.Dictionary}\r\n    */\r\n    Dictionary.prototype.clear = function () {\r\n        this.table = {};\r\n        this.nElements = 0;\r\n    };\r\n    /**\r\n     * Returns the number of keys in this dictionary.\r\n     * @return {number} the number of key-value mappings in this dictionary.\r\n     */\r\n    Dictionary.prototype.size = function () {\r\n        return this.nElements;\r\n    };\r\n    /**\r\n     * Returns true if this dictionary contains no mappings.\r\n     * @return {boolean} true if this dictionary contains no mappings.\r\n     */\r\n    Dictionary.prototype.isEmpty = function () {\r\n        return this.nElements <= 0;\r\n    };\r\n    Dictionary.prototype.toString = function () {\r\n        var toret = '{';\r\n        this.forEach(function (k, v) {\r\n            toret += \"\\n\\t\" + k + \" : \" + v;\r\n        });\r\n        return toret + '\\n}';\r\n    };\r\n    return Dictionary;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Dictionary; // End of dictionary\r\n//# sourceMappingURL=Dictionary.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Dictionary.js\n ** module id = 9\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar arrays = require('./arrays');\r\nvar Dictionary_1 = require('./Dictionary');\r\nvar Set = (function () {\r\n    /**\r\n     * Creates an empty set.\r\n     * @class <p>A set is a data structure that contains no duplicate items.</p>\r\n     * <p>If the inserted elements are custom objects a function\r\n     * which converts elements to strings must be provided. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function petToString(pet) {\r\n     *  return pet.name;\r\n     * }\r\n     * </pre>\r\n     *\r\n     * @constructor\r\n     * @param {function(Object):string=} toStringFunction optional function used\r\n     * to convert elements to strings. If the elements aren't strings or if toString()\r\n     * is not appropriate, a custom function which receives a onject and returns a\r\n     * unique string must be provided.\r\n     */\r\n    function Set(toStringFunction) {\r\n        this.dictionary = new Dictionary_1.default(toStringFunction);\r\n    }\r\n    /**\r\n     * Returns true if this set contains the specified element.\r\n     * @param {Object} element element to search for.\r\n     * @return {boolean} true if this set contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    Set.prototype.contains = function (element) {\r\n        return this.dictionary.containsKey(element);\r\n    };\r\n    /**\r\n     * Adds the specified element to this set if it is not already present.\r\n     * @param {Object} element the element to insert.\r\n     * @return {boolean} true if this set did not already contain the specified element.\r\n     */\r\n    Set.prototype.add = function (element) {\r\n        if (this.contains(element) || util.isUndefined(element)) {\r\n            return false;\r\n        }\r\n        else {\r\n            this.dictionary.setValue(element, element);\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * Performs an intersecion between this an another set.\r\n     * Removes all values that are not present this set and the given set.\r\n     * @param {collections.Set} otherSet other set.\r\n     */\r\n    Set.prototype.intersection = function (otherSet) {\r\n        var set = this;\r\n        this.forEach(function (element) {\r\n            if (!otherSet.contains(element)) {\r\n                set.remove(element);\r\n            }\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Performs a union between this an another set.\r\n     * Adds all values from the given set to this set.\r\n     * @param {collections.Set} otherSet other set.\r\n     */\r\n    Set.prototype.union = function (otherSet) {\r\n        var set = this;\r\n        otherSet.forEach(function (element) {\r\n            set.add(element);\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Performs a difference between this an another set.\r\n     * Removes from this set all the values that are present in the given set.\r\n     * @param {collections.Set} otherSet other set.\r\n     */\r\n    Set.prototype.difference = function (otherSet) {\r\n        var set = this;\r\n        otherSet.forEach(function (element) {\r\n            set.remove(element);\r\n            return true;\r\n        });\r\n    };\r\n    /**\r\n     * Checks whether the given set contains all the elements in this set.\r\n     * @param {collections.Set} otherSet other set.\r\n     * @return {boolean} true if this set is a subset of the given set.\r\n     */\r\n    Set.prototype.isSubsetOf = function (otherSet) {\r\n        if (this.size() > otherSet.size()) {\r\n            return false;\r\n        }\r\n        var isSub = true;\r\n        this.forEach(function (element) {\r\n            if (!otherSet.contains(element)) {\r\n                isSub = false;\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        return isSub;\r\n    };\r\n    /**\r\n     * Removes the specified element from this set if it is present.\r\n     * @return {boolean} true if this set contained the specified element.\r\n     */\r\n    Set.prototype.remove = function (element) {\r\n        if (!this.contains(element)) {\r\n            return false;\r\n        }\r\n        else {\r\n            this.dictionary.remove(element);\r\n            return true;\r\n        }\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element\r\n     * present in this set.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one arguments: the element. To break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    Set.prototype.forEach = function (callback) {\r\n        this.dictionary.forEach(function (k, v) {\r\n            return callback(v);\r\n        });\r\n    };\r\n    /**\r\n     * Returns an array containing all of the elements in this set in arbitrary order.\r\n     * @return {Array} an array containing all of the elements in this set.\r\n     */\r\n    Set.prototype.toArray = function () {\r\n        return this.dictionary.values();\r\n    };\r\n    /**\r\n     * Returns true if this set contains no elements.\r\n     * @return {boolean} true if this set contains no elements.\r\n     */\r\n    Set.prototype.isEmpty = function () {\r\n        return this.dictionary.isEmpty();\r\n    };\r\n    /**\r\n     * Returns the number of elements in this set.\r\n     * @return {number} the number of elements in this set.\r\n     */\r\n    Set.prototype.size = function () {\r\n        return this.dictionary.size();\r\n    };\r\n    /**\r\n     * Removes all of the elements from this set.\r\n     */\r\n    Set.prototype.clear = function () {\r\n        this.dictionary.clear();\r\n    };\r\n    /*\r\n    * Provides a string representation for display\r\n    */\r\n    Set.prototype.toString = function () {\r\n        return arrays.toString(this.toArray());\r\n    };\r\n    return Set;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Set; // end of Set\r\n//# sourceMappingURL=Set.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Set.js\n ** module id = 10\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar Queue_1 = require('./Queue');\r\nvar BSTree = (function () {\r\n    /**\r\n     * Creates an empty binary search tree.\r\n     * @class <p>A binary search tree is a binary tree in which each\r\n     * internal node stores an element such that the elements stored in the\r\n     * left subtree are less than it and the elements\r\n     * stored in the right subtree are greater.</p>\r\n     * <p>Formally, a binary search tree is a node-based binary tree data structure which\r\n     * has the following properties:</p>\r\n     * <ul>\r\n     * <li>The left subtree of a node contains only nodes with elements less\r\n     * than the node's element</li>\r\n     * <li>The right subtree of a node contains only nodes with elements greater\r\n     * than the node's element</li>\r\n     * <li>Both the left and right subtrees must also be binary search trees.</li>\r\n     * </ul>\r\n     * <p>If the inserted elements are custom objects a compare function must\r\n     * be provided at construction time, otherwise the <=, === and >= operators are\r\n     * used to compare elements. Example:</p>\r\n     * <pre>\r\n     * function compare(a, b) {\r\n     *  if (a is less than b by some ordering criterion) {\r\n     *     return -1;\r\n     *  } if (a is greater than b by the ordering criterion) {\r\n     *     return 1;\r\n     *  }\r\n     *  // a must be equal to b\r\n     *  return 0;\r\n     * }\r\n     * </pre>\r\n     * @constructor\r\n     * @param {function(Object,Object):number=} compareFunction optional\r\n     * function used to compare two elements. Must return a negative integer,\r\n     * zero, or a positive integer as the first argument is less than, equal to,\r\n     * or greater than the second.\r\n     */\r\n    function BSTree(compareFunction) {\r\n        this.root = null;\r\n        this.compare = compareFunction || util.defaultCompare;\r\n        this.nElements = 0;\r\n    }\r\n    /**\r\n     * Adds the specified element to this tree if it is not already present.\r\n     * @param {Object} element the element to insert.\r\n     * @return {boolean} true if this tree did not already contain the specified element.\r\n     */\r\n    BSTree.prototype.add = function (element) {\r\n        if (util.isUndefined(element)) {\r\n            return false;\r\n        }\r\n        if (this.insertNode(this.createNode(element)) !== null) {\r\n            this.nElements++;\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Removes all of the elements from this tree.\r\n     */\r\n    BSTree.prototype.clear = function () {\r\n        this.root = null;\r\n        this.nElements = 0;\r\n    };\r\n    /**\r\n     * Returns true if this tree contains no elements.\r\n     * @return {boolean} true if this tree contains no elements.\r\n     */\r\n    BSTree.prototype.isEmpty = function () {\r\n        return this.nElements === 0;\r\n    };\r\n    /**\r\n     * Returns the number of elements in this tree.\r\n     * @return {number} the number of elements in this tree.\r\n     */\r\n    BSTree.prototype.size = function () {\r\n        return this.nElements;\r\n    };\r\n    /**\r\n     * Returns true if this tree contains the specified element.\r\n     * @param {Object} element element to search for.\r\n     * @return {boolean} true if this tree contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    BSTree.prototype.contains = function (element) {\r\n        if (util.isUndefined(element)) {\r\n            return false;\r\n        }\r\n        return this.searchNode(this.root, element) !== null;\r\n    };\r\n    /**\r\n     * Removes the specified element from this tree if it is present.\r\n     * @return {boolean} true if this tree contained the specified element.\r\n     */\r\n    BSTree.prototype.remove = function (element) {\r\n        var node = this.searchNode(this.root, element);\r\n        if (node === null) {\r\n            return false;\r\n        }\r\n        this.removeNode(node);\r\n        this.nElements--;\r\n        return true;\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this tree in\r\n     * in-order.\r\n     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n     * argument: the element value, to break the iteration you can optionally return false.\r\n     */\r\n    BSTree.prototype.inorderTraversal = function (callback) {\r\n        this.inorderTraversalAux(this.root, callback, {\r\n            stop: false\r\n        });\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this tree in pre-order.\r\n     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n     * argument: the element value, to break the iteration you can optionally return false.\r\n     */\r\n    BSTree.prototype.preorderTraversal = function (callback) {\r\n        this.preorderTraversalAux(this.root, callback, {\r\n            stop: false\r\n        });\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this tree in post-order.\r\n     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n     * argument: the element value, to break the iteration you can optionally return false.\r\n     */\r\n    BSTree.prototype.postorderTraversal = function (callback) {\r\n        this.postorderTraversalAux(this.root, callback, {\r\n            stop: false\r\n        });\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this tree in\r\n     * level-order.\r\n     * @param {function(Object):*} callback function to execute, it is invoked with one\r\n     * argument: the element value, to break the iteration you can optionally return false.\r\n     */\r\n    BSTree.prototype.levelTraversal = function (callback) {\r\n        this.levelTraversalAux(this.root, callback);\r\n    };\r\n    /**\r\n     * Returns the minimum element of this tree.\r\n     * @return {*} the minimum element of this tree or undefined if this tree is\r\n     * is empty.\r\n     */\r\n    BSTree.prototype.minimum = function () {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.minimumAux(this.root).element;\r\n    };\r\n    /**\r\n     * Returns the maximum element of this tree.\r\n     * @return {*} the maximum element of this tree or undefined if this tree is\r\n     * is empty.\r\n     */\r\n    BSTree.prototype.maximum = function () {\r\n        if (this.isEmpty()) {\r\n            return undefined;\r\n        }\r\n        return this.maximumAux(this.root).element;\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this tree in inorder.\r\n     * Equivalent to inorderTraversal.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    BSTree.prototype.forEach = function (callback) {\r\n        this.inorderTraversal(callback);\r\n    };\r\n    /**\r\n     * Returns an array containing all of the elements in this tree in in-order.\r\n     * @return {Array} an array containing all of the elements in this tree in in-order.\r\n     */\r\n    BSTree.prototype.toArray = function () {\r\n        var array = [];\r\n        this.inorderTraversal(function (element) {\r\n            array.push(element);\r\n            return true;\r\n        });\r\n        return array;\r\n    };\r\n    /**\r\n     * Returns the height of this tree.\r\n     * @return {number} the height of this tree or -1 if is empty.\r\n     */\r\n    BSTree.prototype.height = function () {\r\n        return this.heightAux(this.root);\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.searchNode = function (node, element) {\r\n        var cmp = null;\r\n        while (node !== null && cmp !== 0) {\r\n            cmp = this.compare(element, node.element);\r\n            if (cmp < 0) {\r\n                node = node.leftCh;\r\n            }\r\n            else if (cmp > 0) {\r\n                node = node.rightCh;\r\n            }\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.transplant = function (n1, n2) {\r\n        if (n1.parent === null) {\r\n            this.root = n2;\r\n        }\r\n        else if (n1 === n1.parent.leftCh) {\r\n            n1.parent.leftCh = n2;\r\n        }\r\n        else {\r\n            n1.parent.rightCh = n2;\r\n        }\r\n        if (n2 !== null) {\r\n            n2.parent = n1.parent;\r\n        }\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.removeNode = function (node) {\r\n        if (node.leftCh === null) {\r\n            this.transplant(node, node.rightCh);\r\n        }\r\n        else if (node.rightCh === null) {\r\n            this.transplant(node, node.leftCh);\r\n        }\r\n        else {\r\n            var y = this.minimumAux(node.rightCh);\r\n            if (y.parent !== node) {\r\n                this.transplant(y, y.rightCh);\r\n                y.rightCh = node.rightCh;\r\n                y.rightCh.parent = y;\r\n            }\r\n            this.transplant(node, y);\r\n            y.leftCh = node.leftCh;\r\n            y.leftCh.parent = y;\r\n        }\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.inorderTraversalAux = function (node, callback, signal) {\r\n        if (node === null || signal.stop) {\r\n            return;\r\n        }\r\n        this.inorderTraversalAux(node.leftCh, callback, signal);\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        signal.stop = callback(node.element) === false;\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        this.inorderTraversalAux(node.rightCh, callback, signal);\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.levelTraversalAux = function (node, callback) {\r\n        var queue = new Queue_1.default();\r\n        if (node !== null) {\r\n            queue.enqueue(node);\r\n        }\r\n        while (!queue.isEmpty()) {\r\n            node = queue.dequeue();\r\n            if (callback(node.element) === false) {\r\n                return;\r\n            }\r\n            if (node.leftCh !== null) {\r\n                queue.enqueue(node.leftCh);\r\n            }\r\n            if (node.rightCh !== null) {\r\n                queue.enqueue(node.rightCh);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.preorderTraversalAux = function (node, callback, signal) {\r\n        if (node === null || signal.stop) {\r\n            return;\r\n        }\r\n        signal.stop = callback(node.element) === false;\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        this.preorderTraversalAux(node.leftCh, callback, signal);\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        this.preorderTraversalAux(node.rightCh, callback, signal);\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.postorderTraversalAux = function (node, callback, signal) {\r\n        if (node === null || signal.stop) {\r\n            return;\r\n        }\r\n        this.postorderTraversalAux(node.leftCh, callback, signal);\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        this.postorderTraversalAux(node.rightCh, callback, signal);\r\n        if (signal.stop) {\r\n            return;\r\n        }\r\n        signal.stop = callback(node.element) === false;\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.minimumAux = function (node) {\r\n        while (node.leftCh !== null) {\r\n            node = node.leftCh;\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.maximumAux = function (node) {\r\n        while (node.rightCh !== null) {\r\n            node = node.rightCh;\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n      * @private\r\n      */\r\n    BSTree.prototype.heightAux = function (node) {\r\n        if (node === null) {\r\n            return -1;\r\n        }\r\n        return Math.max(this.heightAux(node.leftCh), this.heightAux(node.rightCh)) + 1;\r\n    };\r\n    /*\r\n    * @private\r\n    */\r\n    BSTree.prototype.insertNode = function (node) {\r\n        var parent = null;\r\n        var position = this.root;\r\n        var cmp = null;\r\n        while (position !== null) {\r\n            cmp = this.compare(node.element, position.element);\r\n            if (cmp === 0) {\r\n                return null;\r\n            }\r\n            else if (cmp < 0) {\r\n                parent = position;\r\n                position = position.leftCh;\r\n            }\r\n            else {\r\n                parent = position;\r\n                position = position.rightCh;\r\n            }\r\n        }\r\n        node.parent = parent;\r\n        if (parent === null) {\r\n            // tree is empty\r\n            this.root = node;\r\n        }\r\n        else if (this.compare(node.element, parent.element) < 0) {\r\n            parent.leftCh = node;\r\n        }\r\n        else {\r\n            parent.rightCh = node;\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    BSTree.prototype.createNode = function (element) {\r\n        return {\r\n            element: element,\r\n            leftCh: null,\r\n            rightCh: null,\r\n            parent: null\r\n        };\r\n    };\r\n    return BSTree;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = BSTree;\r\n//# sourceMappingURL=BSTree.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/BSTree.js\n ** module id = 11\n ** module chunks = 0\n **/","\"use strict\";\r\nvar LinkedList_1 = require('./LinkedList');\r\nvar Queue = (function () {\r\n    /**\r\n     * Creates an empty queue.\r\n     * @class A queue is a First-In-First-Out (FIFO) data structure, the first\r\n     * element added to the queue will be the first one to be removed. This\r\n     * implementation uses a linked list as a container.\r\n     * @constructor\r\n     */\r\n    function Queue() {\r\n        this.list = new LinkedList_1.default();\r\n    }\r\n    /**\r\n     * Inserts the specified element into the end of this queue.\r\n     * @param {Object} elem the element to insert.\r\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n     */\r\n    Queue.prototype.enqueue = function (elem) {\r\n        return this.list.add(elem);\r\n    };\r\n    /**\r\n     * Inserts the specified element into the end of this queue.\r\n     * @param {Object} elem the element to insert.\r\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n     */\r\n    Queue.prototype.add = function (elem) {\r\n        return this.list.add(elem);\r\n    };\r\n    /**\r\n     * Retrieves and removes the head of this queue.\r\n     * @return {*} the head of this queue, or undefined if this queue is empty.\r\n     */\r\n    Queue.prototype.dequeue = function () {\r\n        if (this.list.size() !== 0) {\r\n            var el = this.list.first();\r\n            this.list.removeElementAtIndex(0);\r\n            return el;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Retrieves, but does not remove, the head of this queue.\r\n     * @return {*} the head of this queue, or undefined if this queue is empty.\r\n     */\r\n    Queue.prototype.peek = function () {\r\n        if (this.list.size() !== 0) {\r\n            return this.list.first();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns the number of elements in this queue.\r\n     * @return {number} the number of elements in this queue.\r\n     */\r\n    Queue.prototype.size = function () {\r\n        return this.list.size();\r\n    };\r\n    /**\r\n     * Returns true if this queue contains the specified element.\r\n     * <p>If the elements inside this stack are\r\n     * not comparable with the === operator, a custom equals function should be\r\n     * provided to perform searches, the function must receive two arguments and\r\n     * return true if they are equal, false otherwise. Example:</p>\r\n     *\r\n     * <pre>\r\n     * const petsAreEqualByName (pet1, pet2) {\r\n     *  return pet1.name === pet2.name;\r\n     * }\r\n     * </pre>\r\n     * @param {Object} elem element to search for.\r\n     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n     * function to check if two elements are equal.\r\n     * @return {boolean} true if this queue contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    Queue.prototype.contains = function (elem, equalsFunction) {\r\n        return this.list.contains(elem, equalsFunction);\r\n    };\r\n    /**\r\n     * Checks if this queue is empty.\r\n     * @return {boolean} true if and only if this queue contains no items; false\r\n     * otherwise.\r\n     */\r\n    Queue.prototype.isEmpty = function () {\r\n        return this.list.size() <= 0;\r\n    };\r\n    /**\r\n     * Removes all of the elements from this queue.\r\n     */\r\n    Queue.prototype.clear = function () {\r\n        this.list.clear();\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this queue in\r\n     * FIFO order.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    Queue.prototype.forEach = function (callback) {\r\n        this.list.forEach(callback);\r\n    };\r\n    return Queue;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Queue; // End of queue\r\n//# sourceMappingURL=Queue.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Queue.js\n ** module id = 12\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar arrays = require('./arrays');\r\nvar LinkedList = (function () {\r\n    /**\r\n    * Creates an empty Linked List.\r\n    * @class A linked list is a data structure consisting of a group of nodes\r\n    * which together represent a sequence.\r\n    * @constructor\r\n    */\r\n    function LinkedList() {\r\n        /**\r\n        * First node in the list\r\n        * @type {Object}\r\n        * @private\r\n        */\r\n        this.firstNode = null;\r\n        /**\r\n        * Last node in the list\r\n        * @type {Object}\r\n        * @private\r\n        */\r\n        this.lastNode = null;\r\n        /**\r\n        * Number of elements in the list\r\n        * @type {number}\r\n        * @private\r\n        */\r\n        this.nElements = 0;\r\n    }\r\n    /**\r\n    * Adds an element to this list.\r\n    * @param {Object} item element to be added.\r\n    * @param {number=} index optional index to add the element. If no index is specified\r\n    * the element is added to the end of this list.\r\n    * @return {boolean} true if the element was added or false if the index is invalid\r\n    * or if the element is undefined.\r\n    */\r\n    LinkedList.prototype.add = function (item, index) {\r\n        if (util.isUndefined(index)) {\r\n            index = this.nElements;\r\n        }\r\n        if (index < 0 || index > this.nElements || util.isUndefined(item)) {\r\n            return false;\r\n        }\r\n        var newNode = this.createNode(item);\r\n        if (this.nElements === 0) {\r\n            // First node in the list.\r\n            this.firstNode = newNode;\r\n            this.lastNode = newNode;\r\n        }\r\n        else if (index === this.nElements) {\r\n            // Insert at the end.\r\n            this.lastNode.next = newNode;\r\n            this.lastNode = newNode;\r\n        }\r\n        else if (index === 0) {\r\n            // Change first node.\r\n            newNode.next = this.firstNode;\r\n            this.firstNode = newNode;\r\n        }\r\n        else {\r\n            var prev = this.nodeAtIndex(index - 1);\r\n            newNode.next = prev.next;\r\n            prev.next = newNode;\r\n        }\r\n        this.nElements++;\r\n        return true;\r\n    };\r\n    /**\r\n    * Returns the first element in this list.\r\n    * @return {*} the first element of the list or undefined if the list is\r\n    * empty.\r\n    */\r\n    LinkedList.prototype.first = function () {\r\n        if (this.firstNode !== null) {\r\n            return this.firstNode.element;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n    * Returns the last element in this list.\r\n    * @return {*} the last element in the list or undefined if the list is\r\n    * empty.\r\n    */\r\n    LinkedList.prototype.last = function () {\r\n        if (this.lastNode !== null) {\r\n            return this.lastNode.element;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns the element at the specified position in this list.\r\n     * @param {number} index desired index.\r\n     * @return {*} the element at the given index or undefined if the index is\r\n     * out of bounds.\r\n     */\r\n    LinkedList.prototype.elementAtIndex = function (index) {\r\n        var node = this.nodeAtIndex(index);\r\n        if (node === null) {\r\n            return undefined;\r\n        }\r\n        return node.element;\r\n    };\r\n    /**\r\n     * Returns the index in this list of the first occurrence of the\r\n     * specified element, or -1 if the List does not contain this element.\r\n     * <p>If the elements inside this list are\r\n     * not comparable with the === operator a custom equals function should be\r\n     * provided to perform searches, the function must receive two arguments and\r\n     * return true if they are equal, false otherwise. Example:</p>\r\n     *\r\n     * <pre>\r\n     * const petsAreEqualByName = function(pet1, pet2) {\r\n     *  return pet1.name === pet2.name;\r\n     * }\r\n     * </pre>\r\n     * @param {Object} item element to search for.\r\n     * @param {function(Object,Object):boolean=} equalsFunction Optional\r\n     * function used to check if two elements are equal.\r\n     * @return {number} the index in this list of the first occurrence\r\n     * of the specified element, or -1 if this list does not contain the\r\n     * element.\r\n     */\r\n    LinkedList.prototype.indexOf = function (item, equalsFunction) {\r\n        var equalsF = equalsFunction || util.defaultEquals;\r\n        if (util.isUndefined(item)) {\r\n            return -1;\r\n        }\r\n        var currentNode = this.firstNode;\r\n        var index = 0;\r\n        while (currentNode !== null) {\r\n            if (equalsF(currentNode.element, item)) {\r\n                return index;\r\n            }\r\n            index++;\r\n            currentNode = currentNode.next;\r\n        }\r\n        return -1;\r\n    };\r\n    /**\r\n       * Returns true if this list contains the specified element.\r\n       * <p>If the elements inside the list are\r\n       * not comparable with the === operator a custom equals function should be\r\n       * provided to perform searches, the function must receive two arguments and\r\n       * return true if they are equal, false otherwise. Example:</p>\r\n       *\r\n       * <pre>\r\n       * const petsAreEqualByName = function(pet1, pet2) {\r\n       *  return pet1.name === pet2.name;\r\n       * }\r\n       * </pre>\r\n       * @param {Object} item element to search for.\r\n       * @param {function(Object,Object):boolean=} equalsFunction Optional\r\n       * function used to check if two elements are equal.\r\n       * @return {boolean} true if this list contains the specified element, false\r\n       * otherwise.\r\n       */\r\n    LinkedList.prototype.contains = function (item, equalsFunction) {\r\n        return (this.indexOf(item, equalsFunction) >= 0);\r\n    };\r\n    /**\r\n     * Removes the first occurrence of the specified element in this list.\r\n     * <p>If the elements inside the list are\r\n     * not comparable with the === operator a custom equals function should be\r\n     * provided to perform searches, the function must receive two arguments and\r\n     * return true if they are equal, false otherwise. Example:</p>\r\n     *\r\n     * <pre>\r\n     * const petsAreEqualByName = function(pet1, pet2) {\r\n     *  return pet1.name === pet2.name;\r\n     * }\r\n     * </pre>\r\n     * @param {Object} item element to be removed from this list, if present.\r\n     * @return {boolean} true if the list contained the specified element.\r\n     */\r\n    LinkedList.prototype.remove = function (item, equalsFunction) {\r\n        var equalsF = equalsFunction || util.defaultEquals;\r\n        if (this.nElements < 1 || util.isUndefined(item)) {\r\n            return false;\r\n        }\r\n        var previous = null;\r\n        var currentNode = this.firstNode;\r\n        while (currentNode !== null) {\r\n            if (equalsF(currentNode.element, item)) {\r\n                if (currentNode === this.firstNode) {\r\n                    this.firstNode = this.firstNode.next;\r\n                    if (currentNode === this.lastNode) {\r\n                        this.lastNode = null;\r\n                    }\r\n                }\r\n                else if (currentNode === this.lastNode) {\r\n                    this.lastNode = previous;\r\n                    previous.next = currentNode.next;\r\n                    currentNode.next = null;\r\n                }\r\n                else {\r\n                    previous.next = currentNode.next;\r\n                    currentNode.next = null;\r\n                }\r\n                this.nElements--;\r\n                return true;\r\n            }\r\n            previous = currentNode;\r\n            currentNode = currentNode.next;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Removes all of the elements from this list.\r\n     */\r\n    LinkedList.prototype.clear = function () {\r\n        this.firstNode = null;\r\n        this.lastNode = null;\r\n        this.nElements = 0;\r\n    };\r\n    /**\r\n     * Returns true if this list is equal to the given list.\r\n     * Two lists are equal if they have the same elements in the same order.\r\n     * @param {LinkedList} other the other list.\r\n     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n     * function used to check if two elements are equal. If the elements in the lists\r\n     * are custom objects you should provide a function, otherwise\r\n     * the === operator is used to check equality between elements.\r\n     * @return {boolean} true if this list is equal to the given list.\r\n     */\r\n    LinkedList.prototype.equals = function (other, equalsFunction) {\r\n        var eqF = equalsFunction || util.defaultEquals;\r\n        if (!(other instanceof LinkedList)) {\r\n            return false;\r\n        }\r\n        if (this.size() !== other.size()) {\r\n            return false;\r\n        }\r\n        return this.equalsAux(this.firstNode, other.firstNode, eqF);\r\n    };\r\n    /**\r\n    * @private\r\n    */\r\n    LinkedList.prototype.equalsAux = function (n1, n2, eqF) {\r\n        while (n1 !== null) {\r\n            if (!eqF(n1.element, n2.element)) {\r\n                return false;\r\n            }\r\n            n1 = n1.next;\r\n            n2 = n2.next;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n     * Removes the element at the specified position in this list.\r\n     * @param {number} index given index.\r\n     * @return {*} removed element or undefined if the index is out of bounds.\r\n     */\r\n    LinkedList.prototype.removeElementAtIndex = function (index) {\r\n        if (index < 0 || index >= this.nElements) {\r\n            return undefined;\r\n        }\r\n        var element;\r\n        if (this.nElements === 1) {\r\n            //First node in the list.\r\n            element = this.firstNode.element;\r\n            this.firstNode = null;\r\n            this.lastNode = null;\r\n        }\r\n        else {\r\n            var previous = this.nodeAtIndex(index - 1);\r\n            if (previous === null) {\r\n                element = this.firstNode.element;\r\n                this.firstNode = this.firstNode.next;\r\n            }\r\n            else if (previous.next === this.lastNode) {\r\n                element = this.lastNode.element;\r\n                this.lastNode = previous;\r\n            }\r\n            if (previous !== null) {\r\n                element = previous.next.element;\r\n                previous.next = previous.next.next;\r\n            }\r\n        }\r\n        this.nElements--;\r\n        return element;\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this list in order.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    LinkedList.prototype.forEach = function (callback) {\r\n        var currentNode = this.firstNode;\r\n        while (currentNode !== null) {\r\n            if (callback(currentNode.element) === false) {\r\n                break;\r\n            }\r\n            currentNode = currentNode.next;\r\n        }\r\n    };\r\n    /**\r\n     * Reverses the order of the elements in this linked list (makes the last\r\n     * element first, and the first element last).\r\n     */\r\n    LinkedList.prototype.reverse = function () {\r\n        var previous = null;\r\n        var current = this.firstNode;\r\n        var temp = null;\r\n        while (current !== null) {\r\n            temp = current.next;\r\n            current.next = previous;\r\n            previous = current;\r\n            current = temp;\r\n        }\r\n        temp = this.firstNode;\r\n        this.firstNode = this.lastNode;\r\n        this.lastNode = temp;\r\n    };\r\n    /**\r\n     * Returns an array containing all of the elements in this list in proper\r\n     * sequence.\r\n     * @return {Array.<*>} an array containing all of the elements in this list,\r\n     * in proper sequence.\r\n     */\r\n    LinkedList.prototype.toArray = function () {\r\n        var array = [];\r\n        var currentNode = this.firstNode;\r\n        while (currentNode !== null) {\r\n            array.push(currentNode.element);\r\n            currentNode = currentNode.next;\r\n        }\r\n        return array;\r\n    };\r\n    /**\r\n     * Returns the number of elements in this list.\r\n     * @return {number} the number of elements in this list.\r\n     */\r\n    LinkedList.prototype.size = function () {\r\n        return this.nElements;\r\n    };\r\n    /**\r\n     * Returns true if this list contains no elements.\r\n     * @return {boolean} true if this list contains no elements.\r\n     */\r\n    LinkedList.prototype.isEmpty = function () {\r\n        return this.nElements <= 0;\r\n    };\r\n    LinkedList.prototype.toString = function () {\r\n        return arrays.toString(this.toArray());\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    LinkedList.prototype.nodeAtIndex = function (index) {\r\n        if (index < 0 || index >= this.nElements) {\r\n            return null;\r\n        }\r\n        if (index === (this.nElements - 1)) {\r\n            return this.lastNode;\r\n        }\r\n        var node = this.firstNode;\r\n        for (var i = 0; i < index; i++) {\r\n            node = node.next;\r\n        }\r\n        return node;\r\n    };\r\n    /**\r\n     * @private\r\n     */\r\n    LinkedList.prototype.createNode = function (item) {\r\n        return {\r\n            element: item,\r\n            next: null\r\n        };\r\n    };\r\n    return LinkedList;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = LinkedList; // End of linked list\r\n//# sourceMappingURL=LinkedList.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/LinkedList.js\n ** module id = 13\n ** module chunks = 0\n **/","\"use strict\";\r\nvar collections = require('./util');\r\nvar arrays = require('./arrays');\r\nvar Heap = (function () {\r\n    /**\r\n     * Creates an empty Heap.\r\n     * @class\r\n     * <p>A heap is a binary tree, where the nodes maintain the heap property:\r\n     * each node is smaller than each of its children and therefore a MinHeap\r\n     * This implementation uses an array to store elements.</p>\r\n     * <p>If the inserted elements are custom objects a compare function must be provided,\r\n     *  at construction time, otherwise the <=, === and >= operators are\r\n     * used to compare elements. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function compare(a, b) {\r\n     *  if (a is less than b by some ordering criterion) {\r\n     *     return -1;\r\n     *  } if (a is greater than b by the ordering criterion) {\r\n     *     return 1;\r\n     *  }\r\n     *  // a must be equal to b\r\n     *  return 0;\r\n     * }\r\n     * </pre>\r\n     *\r\n     * <p>If a Max-Heap is wanted (greater elements on top) you can a provide a\r\n     * reverse compare function to accomplish that behavior. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function reverseCompare(a, b) {\r\n     *  if (a is less than b by some ordering criterion) {\r\n     *     return 1;\r\n     *  } if (a is greater than b by the ordering criterion) {\r\n     *     return -1;\r\n     *  }\r\n     *  // a must be equal to b\r\n     *  return 0;\r\n     * }\r\n     * </pre>\r\n     *\r\n     * @constructor\r\n     * @param {function(Object,Object):number=} compareFunction optional\r\n     * function used to compare two elements. Must return a negative integer,\r\n     * zero, or a positive integer as the first argument is less than, equal to,\r\n     * or greater than the second.\r\n     */\r\n    function Heap(compareFunction) {\r\n        /**\r\n         * Array used to store the elements od the heap.\r\n         * @type {Array.<Object>}\r\n         * @private\r\n         */\r\n        this.data = [];\r\n        this.compare = compareFunction || collections.defaultCompare;\r\n    }\r\n    /**\r\n     * Returns the index of the left child of the node at the given index.\r\n     * @param {number} nodeIndex The index of the node to get the left child\r\n     * for.\r\n     * @return {number} The index of the left child.\r\n     * @private\r\n     */\r\n    Heap.prototype.leftChildIndex = function (nodeIndex) {\r\n        return (2 * nodeIndex) + 1;\r\n    };\r\n    /**\r\n     * Returns the index of the right child of the node at the given index.\r\n     * @param {number} nodeIndex The index of the node to get the right child\r\n     * for.\r\n     * @return {number} The index of the right child.\r\n     * @private\r\n     */\r\n    Heap.prototype.rightChildIndex = function (nodeIndex) {\r\n        return (2 * nodeIndex) + 2;\r\n    };\r\n    /**\r\n     * Returns the index of the parent of the node at the given index.\r\n     * @param {number} nodeIndex The index of the node to get the parent for.\r\n     * @return {number} The index of the parent.\r\n     * @private\r\n     */\r\n    Heap.prototype.parentIndex = function (nodeIndex) {\r\n        return Math.floor((nodeIndex - 1) / 2);\r\n    };\r\n    /**\r\n     * Returns the index of the smaller child node (if it exists).\r\n     * @param {number} leftChild left child index.\r\n     * @param {number} rightChild right child index.\r\n     * @return {number} the index with the minimum value or -1 if it doesn't\r\n     * exists.\r\n     * @private\r\n     */\r\n    Heap.prototype.minIndex = function (leftChild, rightChild) {\r\n        if (rightChild >= this.data.length) {\r\n            if (leftChild >= this.data.length) {\r\n                return -1;\r\n            }\r\n            else {\r\n                return leftChild;\r\n            }\r\n        }\r\n        else {\r\n            if (this.compare(this.data[leftChild], this.data[rightChild]) <= 0) {\r\n                return leftChild;\r\n            }\r\n            else {\r\n                return rightChild;\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Moves the node at the given index up to its proper place in the heap.\r\n     * @param {number} index The index of the node to move up.\r\n     * @private\r\n     */\r\n    Heap.prototype.siftUp = function (index) {\r\n        var parent = this.parentIndex(index);\r\n        while (index > 0 && this.compare(this.data[parent], this.data[index]) > 0) {\r\n            arrays.swap(this.data, parent, index);\r\n            index = parent;\r\n            parent = this.parentIndex(index);\r\n        }\r\n    };\r\n    /**\r\n     * Moves the node at the given index down to its proper place in the heap.\r\n     * @param {number} nodeIndex The index of the node to move down.\r\n     * @private\r\n     */\r\n    Heap.prototype.siftDown = function (nodeIndex) {\r\n        //smaller child index\r\n        var min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\r\n        while (min >= 0 && this.compare(this.data[nodeIndex], this.data[min]) > 0) {\r\n            arrays.swap(this.data, min, nodeIndex);\r\n            nodeIndex = min;\r\n            min = this.minIndex(this.leftChildIndex(nodeIndex), this.rightChildIndex(nodeIndex));\r\n        }\r\n    };\r\n    /**\r\n     * Retrieves but does not remove the root element of this heap.\r\n     * @return {*} The value at the root of the heap. Returns undefined if the\r\n     * heap is empty.\r\n     */\r\n    Heap.prototype.peek = function () {\r\n        if (this.data.length > 0) {\r\n            return this.data[0];\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    };\r\n    /**\r\n     * Adds the given element into the heap.\r\n     * @param {*} element the element.\r\n     * @return true if the element was added or fals if it is undefined.\r\n     */\r\n    Heap.prototype.add = function (element) {\r\n        if (collections.isUndefined(element)) {\r\n            return undefined;\r\n        }\r\n        this.data.push(element);\r\n        this.siftUp(this.data.length - 1);\r\n        return true;\r\n    };\r\n    /**\r\n     * Retrieves and removes the root element of this heap.\r\n     * @return {*} The value removed from the root of the heap. Returns\r\n     * undefined if the heap is empty.\r\n     */\r\n    Heap.prototype.removeRoot = function () {\r\n        if (this.data.length > 0) {\r\n            var obj = this.data[0];\r\n            this.data[0] = this.data[this.data.length - 1];\r\n            this.data.splice(this.data.length - 1, 1);\r\n            if (this.data.length > 0) {\r\n                this.siftDown(0);\r\n            }\r\n            return obj;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Returns true if this heap contains the specified element.\r\n     * @param {Object} element element to search for.\r\n     * @return {boolean} true if this Heap contains the specified element, false\r\n     * otherwise.\r\n     */\r\n    Heap.prototype.contains = function (element) {\r\n        var equF = collections.compareToEquals(this.compare);\r\n        return arrays.contains(this.data, element, equF);\r\n    };\r\n    /**\r\n     * Returns the number of elements in this heap.\r\n     * @return {number} the number of elements in this heap.\r\n     */\r\n    Heap.prototype.size = function () {\r\n        return this.data.length;\r\n    };\r\n    /**\r\n     * Checks if this heap is empty.\r\n     * @return {boolean} true if and only if this heap contains no items; false\r\n     * otherwise.\r\n     */\r\n    Heap.prototype.isEmpty = function () {\r\n        return this.data.length <= 0;\r\n    };\r\n    /**\r\n     * Removes all of the elements from this heap.\r\n     */\r\n    Heap.prototype.clear = function () {\r\n        this.data.length = 0;\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this heap in\r\n     * no particular order.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    Heap.prototype.forEach = function (callback) {\r\n        arrays.forEach(this.data, callback);\r\n    };\r\n    return Heap;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Heap;\r\n//# sourceMappingURL=Heap.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Heap.js\n ** module id = 14\n ** module chunks = 0\n **/","\"use strict\";\r\nvar __extends = (this && this.__extends) || function (d, b) {\r\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n};\r\nvar Dictionary_1 = require('./Dictionary');\r\nvar util = require('./util');\r\n/**\r\n * This class is used by the LinkedDictionary Internally\r\n * Has to be a class, not an interface, because it needs to have\r\n * the 'unlink' function defined.\r\n */\r\nvar LinkedDictionaryPair = (function () {\r\n    function LinkedDictionaryPair(key, value) {\r\n        this.key = key;\r\n        this.value = value;\r\n    }\r\n    LinkedDictionaryPair.prototype.unlink = function () {\r\n        this.prev.next = this.next;\r\n        this.next.prev = this.prev;\r\n    };\r\n    return LinkedDictionaryPair;\r\n}());\r\nvar LinkedDictionary = (function (_super) {\r\n    __extends(LinkedDictionary, _super);\r\n    function LinkedDictionary(toStrFunction) {\r\n        _super.call(this, toStrFunction);\r\n        this.head = new LinkedDictionaryPair(null, null);\r\n        this.tail = new LinkedDictionaryPair(null, null);\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n    }\r\n    /**\r\n     * Inserts the new node to the 'tail' of the list, updating the\r\n     * neighbors, and moving 'this.tail' (the End of List indicator) that\r\n     * to the end.\r\n     */\r\n    LinkedDictionary.prototype.appendToTail = function (entry) {\r\n        var lastNode = this.tail.prev;\r\n        lastNode.next = entry;\r\n        entry.prev = lastNode;\r\n        entry.next = this.tail;\r\n        this.tail.prev = entry;\r\n    };\r\n    /**\r\n     * Retrieves a linked dictionary from the table internally\r\n     */\r\n    LinkedDictionary.prototype.getLinkedDictionaryPair = function (key) {\r\n        if (util.isUndefined(key)) {\r\n            return undefined;\r\n        }\r\n        var k = '$' + this.toStr(key);\r\n        var pair = (this.table[k]);\r\n        return pair;\r\n    };\r\n    /**\r\n     * Returns the value to which this dictionary maps the specified key.\r\n     * Returns undefined if this dictionary contains no mapping for this key.\r\n     * @param {Object} key key whose associated value is to be returned.\r\n     * @return {*} the value to which this dictionary maps the specified key or\r\n     * undefined if the map contains no mapping for this key.\r\n     */\r\n    LinkedDictionary.prototype.getValue = function (key) {\r\n        var pair = this.getLinkedDictionaryPair(key);\r\n        if (!util.isUndefined(pair)) {\r\n            return pair.value;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Removes the mapping for this key from this dictionary if it is present.\r\n     * Also, if a value is present for this key, the entry is removed from the\r\n     * insertion ordering.\r\n     * @param {Object} key key whose mapping is to be removed from the\r\n     * dictionary.\r\n     * @return {*} previous value associated with specified key, or undefined if\r\n     * there was no mapping for key.\r\n     */\r\n    LinkedDictionary.prototype.remove = function (key) {\r\n        var pair = this.getLinkedDictionaryPair(key);\r\n        if (!util.isUndefined(pair)) {\r\n            _super.prototype.remove.call(this, key); // This will remove it from the table\r\n            pair.unlink(); // This will unlink it from the chain\r\n            return pair.value;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n    * Removes all mappings from this LinkedDictionary.\r\n    * @this {collections.LinkedDictionary}\r\n    */\r\n    LinkedDictionary.prototype.clear = function () {\r\n        _super.prototype.clear.call(this);\r\n        this.head.next = this.tail;\r\n        this.tail.prev = this.head;\r\n    };\r\n    /**\r\n     * Internal function used when updating an existing KeyValue pair.\r\n     * It places the new value indexed by key into the table, but maintains\r\n     * its place in the linked ordering.\r\n     */\r\n    LinkedDictionary.prototype.replace = function (oldPair, newPair) {\r\n        var k = '$' + this.toStr(newPair.key);\r\n        // set the new Pair's links to existingPair's links\r\n        newPair.next = oldPair.next;\r\n        newPair.prev = oldPair.prev;\r\n        // Delete Existing Pair from the table, unlink it from chain.\r\n        // As a result, the nElements gets decremented by this operation\r\n        this.remove(oldPair.key);\r\n        // Link new Pair in place of where oldPair was,\r\n        // by pointing the old pair's neighbors to it.\r\n        newPair.prev.next = newPair;\r\n        newPair.next.prev = newPair;\r\n        this.table[k] = newPair;\r\n        // To make up for the fact that the number of elements was decremented,\r\n        // We need to increase it by one.\r\n        ++this.nElements;\r\n    };\r\n    /**\r\n     * Associates the specified value with the specified key in this dictionary.\r\n     * If the dictionary previously contained a mapping for this key, the old\r\n     * value is replaced by the specified value.\r\n     * Updating of a key that already exists maintains its place in the\r\n     * insertion order into the map.\r\n     * @param {Object} key key with which the specified value is to be\r\n     * associated.\r\n     * @param {Object} value value to be associated with the specified key.\r\n     * @return {*} previous value associated with the specified key, or undefined if\r\n     * there was no mapping for the key or if the key/value are undefined.\r\n     */\r\n    LinkedDictionary.prototype.setValue = function (key, value) {\r\n        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n            return undefined;\r\n        }\r\n        var existingPair = this.getLinkedDictionaryPair(key);\r\n        var newPair = new LinkedDictionaryPair(key, value);\r\n        var k = '$' + this.toStr(key);\r\n        // If there is already an element for that key, we\r\n        // keep it's place in the LinkedList\r\n        if (!util.isUndefined(existingPair)) {\r\n            this.replace(existingPair, newPair);\r\n            return existingPair.value;\r\n        }\r\n        else {\r\n            this.appendToTail(newPair);\r\n            this.table[k] = newPair;\r\n            ++this.nElements;\r\n            return undefined;\r\n        }\r\n    };\r\n    /**\r\n     * Returns an array containing all of the keys in this LinkedDictionary, ordered\r\n     * by insertion order.\r\n     * @return {Array} an array containing all of the keys in this LinkedDictionary,\r\n     * ordered by insertion order.\r\n     */\r\n    LinkedDictionary.prototype.keys = function () {\r\n        var array = [];\r\n        this.forEach(function (key, value) {\r\n            array.push(key);\r\n        });\r\n        return array;\r\n    };\r\n    /**\r\n     * Returns an array containing all of the values in this LinkedDictionary, ordered by\r\n     * insertion order.\r\n     * @return {Array} an array containing all of the values in this LinkedDictionary,\r\n     * ordered by insertion order.\r\n     */\r\n    LinkedDictionary.prototype.values = function () {\r\n        var array = [];\r\n        this.forEach(function (key, value) {\r\n            array.push(value);\r\n        });\r\n        return array;\r\n    };\r\n    /**\r\n    * Executes the provided function once for each key-value pair\r\n    * present in this LinkedDictionary. It is done in the order of insertion\r\n    * into the LinkedDictionary\r\n    * @param {function(Object,Object):*} callback function to execute, it is\r\n    * invoked with two arguments: key and value. To break the iteration you can\r\n    * optionally return false.\r\n    */\r\n    LinkedDictionary.prototype.forEach = function (callback) {\r\n        var crawlNode = this.head.next;\r\n        while (crawlNode.next != null) {\r\n            var ret = callback(crawlNode.key, crawlNode.value);\r\n            if (ret === false) {\r\n                return;\r\n            }\r\n            crawlNode = crawlNode.next;\r\n        }\r\n    };\r\n    return LinkedDictionary;\r\n}(Dictionary_1.default));\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = LinkedDictionary; // End of LinkedDictionary\r\n// /**\r\n//  * Returns true if this dictionary is equal to the given dictionary.\r\n//  * Two dictionaries are equal if they contain the same mappings.\r\n//  * @param {collections.Dictionary} other the other dictionary.\r\n//  * @param {function(Object,Object):boolean=} valuesEqualFunction optional\r\n//  * function used to check if two values are equal.\r\n//  * @return {boolean} true if this dictionary is equal to the given dictionary.\r\n//  */\r\n// collections.Dictionary.prototype.equals = function(other,valuesEqualFunction) {\r\n// \tconst eqF = valuesEqualFunction || collections.defaultEquals;\r\n// \tif(!(other instanceof collections.Dictionary)){\r\n// \t\treturn false;\r\n// \t}\r\n// \tif(this.size() !== other.size()){\r\n// \t\treturn false;\r\n// \t}\r\n// \treturn this.equalsAux(this.firstNode,other.firstNode,eqF);\r\n// }\r\n//# sourceMappingURL=LinkedDictionary.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/LinkedDictionary.js\n ** module id = 15\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar Dictionary_1 = require('./Dictionary');\r\nvar arrays = require('./arrays');\r\nvar MultiDictionary = (function () {\r\n    /**\r\n     * Creates an empty multi dictionary.\r\n     * @class <p>A multi dictionary is a special kind of dictionary that holds\r\n     * multiple values against each key. Setting a value into the dictionary will\r\n     * add the value to an array at that key. Getting a key will return an array,\r\n     * holding all the values set to that key.\r\n     * You can configure to allow duplicates in the values.\r\n     * This implementation accepts any kind of objects as keys.</p>\r\n     *\r\n     * <p>If the keys are custom objects a function which converts keys to strings must be\r\n     * provided. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function petToString(pet) {\r\n       *  return pet.name;\r\n       * }\r\n     * </pre>\r\n     * <p>If the values are custom objects a function to check equality between values\r\n     * must be provided. Example:</p>\r\n     *\r\n     * <pre>\r\n     * function petsAreEqualByAge(pet1,pet2) {\r\n       *  return pet1.age===pet2.age;\r\n       * }\r\n     * </pre>\r\n     * @constructor\r\n     * @param {function(Object):string=} toStrFunction optional function\r\n     * to convert keys to strings. If the keys aren't strings or if toString()\r\n     * is not appropriate, a custom function which receives a key and returns a\r\n     * unique string must be provided.\r\n     * @param {function(Object,Object):boolean=} valuesEqualsFunction optional\r\n     * function to check if two values are equal.\r\n     *\r\n     * @param allowDuplicateValues\r\n     */\r\n    function MultiDictionary(toStrFunction, valuesEqualsFunction, allowDuplicateValues) {\r\n        if (allowDuplicateValues === void 0) { allowDuplicateValues = false; }\r\n        this.dict = new Dictionary_1.default(toStrFunction);\r\n        this.equalsF = valuesEqualsFunction || util.defaultEquals;\r\n        this.allowDuplicate = allowDuplicateValues;\r\n    }\r\n    /**\r\n    * Returns an array holding the values to which this dictionary maps\r\n    * the specified key.\r\n    * Returns an empty array if this dictionary contains no mappings for this key.\r\n    * @param {Object} key key whose associated values are to be returned.\r\n    * @return {Array} an array holding the values to which this dictionary maps\r\n    * the specified key.\r\n    */\r\n    MultiDictionary.prototype.getValue = function (key) {\r\n        var values = this.dict.getValue(key);\r\n        if (util.isUndefined(values)) {\r\n            return [];\r\n        }\r\n        return arrays.copy(values);\r\n    };\r\n    /**\r\n     * Adds the value to the array associated with the specified key, if\r\n     * it is not already present.\r\n     * @param {Object} key key with which the specified value is to be\r\n     * associated.\r\n     * @param {Object} value the value to add to the array at the key\r\n     * @return {boolean} true if the value was not already associated with that key.\r\n     */\r\n    MultiDictionary.prototype.setValue = function (key, value) {\r\n        if (util.isUndefined(key) || util.isUndefined(value)) {\r\n            return false;\r\n        }\r\n        if (!this.containsKey(key)) {\r\n            this.dict.setValue(key, [value]);\r\n            return true;\r\n        }\r\n        var array = this.dict.getValue(key);\r\n        if (!this.allowDuplicate) {\r\n            if (arrays.contains(array, value, this.equalsF)) {\r\n                return false;\r\n            }\r\n        }\r\n        array.push(value);\r\n        return true;\r\n    };\r\n    /**\r\n     * Removes the specified values from the array of values associated with the\r\n     * specified key. If a value isn't given, all values associated with the specified\r\n     * key are removed.\r\n     * @param {Object} key key whose mapping is to be removed from the\r\n     * dictionary.\r\n     * @param {Object=} value optional argument to specify the value to remove\r\n     * from the array associated with the specified key.\r\n     * @return {*} true if the dictionary changed, false if the key doesn't exist or\r\n     * if the specified value isn't associated with the specified key.\r\n     */\r\n    MultiDictionary.prototype.remove = function (key, value) {\r\n        if (util.isUndefined(value)) {\r\n            var v = this.dict.remove(key);\r\n            return !util.isUndefined(v);\r\n        }\r\n        var array = this.dict.getValue(key);\r\n        if (arrays.remove(array, value, this.equalsF)) {\r\n            if (array.length === 0) {\r\n                this.dict.remove(key);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * Returns an array containing all of the keys in this dictionary.\r\n     * @return {Array} an array containing all of the keys in this dictionary.\r\n     */\r\n    MultiDictionary.prototype.keys = function () {\r\n        return this.dict.keys();\r\n    };\r\n    /**\r\n     * Returns an array containing all of the values in this dictionary.\r\n     * @return {Array} an array containing all of the values in this dictionary.\r\n     */\r\n    MultiDictionary.prototype.values = function () {\r\n        var values = this.dict.values();\r\n        var array = [];\r\n        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {\r\n            var v = values_1[_i];\r\n            for (var _a = 0, v_1 = v; _a < v_1.length; _a++) {\r\n                var w = v_1[_a];\r\n                array.push(w);\r\n            }\r\n        }\r\n        return array;\r\n    };\r\n    /**\r\n     * Returns true if this dictionary at least one value associatted the specified key.\r\n     * @param {Object} key key whose presence in this dictionary is to be\r\n     * tested.\r\n     * @return {boolean} true if this dictionary at least one value associatted\r\n     * the specified key.\r\n     */\r\n    MultiDictionary.prototype.containsKey = function (key) {\r\n        return this.dict.containsKey(key);\r\n    };\r\n    /**\r\n     * Removes all mappings from this dictionary.\r\n     */\r\n    MultiDictionary.prototype.clear = function () {\r\n        this.dict.clear();\r\n    };\r\n    /**\r\n     * Returns the number of keys in this dictionary.\r\n     * @return {number} the number of key-value mappings in this dictionary.\r\n     */\r\n    MultiDictionary.prototype.size = function () {\r\n        return this.dict.size();\r\n    };\r\n    /**\r\n     * Returns true if this dictionary contains no mappings.\r\n     * @return {boolean} true if this dictionary contains no mappings.\r\n     */\r\n    MultiDictionary.prototype.isEmpty = function () {\r\n        return this.dict.isEmpty();\r\n    };\r\n    return MultiDictionary;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = MultiDictionary; // end of multi dictionary\r\n//# sourceMappingURL=MultiDictionary.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/MultiDictionary.js\n ** module id = 16\n ** module chunks = 0\n **/","\"use strict\";\r\nvar util = require('./util');\r\nvar Heap_1 = require('./Heap');\r\nvar PriorityQueue = (function () {\r\n    /**\r\n     * Creates an empty priority queue.\r\n     * @class <p>In a priority queue each element is associated with a \"priority\",\r\n     * elements are dequeued in highest-priority-first order (the elements with the\r\n     * highest priority are dequeued first). Priority Queues are implemented as heaps.\r\n     * If the inserted elements are custom objects a compare function must be provided,\r\n     * otherwise the <=, === and >= operators are used to compare object priority.</p>\r\n     * <pre>\r\n     * function compare(a, b) {\r\n     *  if (a is less than b by some ordering criterion) {\r\n     *     return -1;\r\n     *  } if (a is greater than b by the ordering criterion) {\r\n     *     return 1;\r\n     *  }\r\n     *  // a must be equal to b\r\n     *  return 0;\r\n     * }\r\n     * </pre>\r\n     * @constructor\r\n     * @param {function(Object,Object):number=} compareFunction optional\r\n     * function used to compare two element priorities. Must return a negative integer,\r\n     * zero, or a positive integer as the first argument is less than, equal to,\r\n     * or greater than the second.\r\n     */\r\n    function PriorityQueue(compareFunction) {\r\n        this.heap = new Heap_1.default(util.reverseCompareFunction(compareFunction));\r\n    }\r\n    /**\r\n     * Inserts the specified element into this priority queue.\r\n     * @param {Object} element the element to insert.\r\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n     */\r\n    PriorityQueue.prototype.enqueue = function (element) {\r\n        return this.heap.add(element);\r\n    };\r\n    /**\r\n     * Inserts the specified element into this priority queue.\r\n     * @param {Object} element the element to insert.\r\n     * @return {boolean} true if the element was inserted, or false if it is undefined.\r\n     */\r\n    PriorityQueue.prototype.add = function (element) {\r\n        return this.heap.add(element);\r\n    };\r\n    /**\r\n     * Retrieves and removes the highest priority element of this queue.\r\n     * @return {*} the the highest priority element of this queue,\r\n     *  or undefined if this queue is empty.\r\n     */\r\n    PriorityQueue.prototype.dequeue = function () {\r\n        if (this.heap.size() !== 0) {\r\n            var el = this.heap.peek();\r\n            this.heap.removeRoot();\r\n            return el;\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Retrieves, but does not remove, the highest priority element of this queue.\r\n     * @return {*} the highest priority element of this queue, or undefined if this queue is empty.\r\n     */\r\n    PriorityQueue.prototype.peek = function () {\r\n        return this.heap.peek();\r\n    };\r\n    /**\r\n     * Returns true if this priority queue contains the specified element.\r\n     * @param {Object} element element to search for.\r\n     * @return {boolean} true if this priority queue contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    PriorityQueue.prototype.contains = function (element) {\r\n        return this.heap.contains(element);\r\n    };\r\n    /**\r\n     * Checks if this priority queue is empty.\r\n     * @return {boolean} true if and only if this priority queue contains no items; false\r\n     * otherwise.\r\n     */\r\n    PriorityQueue.prototype.isEmpty = function () {\r\n        return this.heap.isEmpty();\r\n    };\r\n    /**\r\n     * Returns the number of elements in this priority queue.\r\n     * @return {number} the number of elements in this priority queue.\r\n     */\r\n    PriorityQueue.prototype.size = function () {\r\n        return this.heap.size();\r\n    };\r\n    /**\r\n     * Removes all of the elements from this priority queue.\r\n     */\r\n    PriorityQueue.prototype.clear = function () {\r\n        this.heap.clear();\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this queue in\r\n     * no particular order.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    PriorityQueue.prototype.forEach = function (callback) {\r\n        this.heap.forEach(callback);\r\n    };\r\n    return PriorityQueue;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = PriorityQueue; // end of priority queue\r\n//# sourceMappingURL=PriorityQueue.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/PriorityQueue.js\n ** module id = 17\n ** module chunks = 0\n **/","\"use strict\";\r\nvar LinkedList_1 = require('./LinkedList');\r\nvar Stack = (function () {\r\n    /**\r\n     * Creates an empty Stack.\r\n     * @class A Stack is a Last-In-First-Out (LIFO) data structure, the last\r\n     * element added to the stack will be the first one to be removed. This\r\n     * implementation uses a linked list as a container.\r\n     * @constructor\r\n     */\r\n    function Stack() {\r\n        this.list = new LinkedList_1.default();\r\n    }\r\n    /**\r\n     * Pushes an item onto the top of this stack.\r\n     * @param {Object} elem the element to be pushed onto this stack.\r\n     * @return {boolean} true if the element was pushed or false if it is undefined.\r\n     */\r\n    Stack.prototype.push = function (elem) {\r\n        return this.list.add(elem, 0);\r\n    };\r\n    /**\r\n     * Pushes an item onto the top of this stack.\r\n     * @param {Object} elem the element to be pushed onto this stack.\r\n     * @return {boolean} true if the element was pushed or false if it is undefined.\r\n     */\r\n    Stack.prototype.add = function (elem) {\r\n        return this.list.add(elem, 0);\r\n    };\r\n    /**\r\n     * Removes the object at the top of this stack and returns that object.\r\n     * @return {*} the object at the top of this stack or undefined if the\r\n     * stack is empty.\r\n     */\r\n    Stack.prototype.pop = function () {\r\n        return this.list.removeElementAtIndex(0);\r\n    };\r\n    /**\r\n     * Looks at the object at the top of this stack without removing it from the\r\n     * stack.\r\n     * @return {*} the object at the top of this stack or undefined if the\r\n     * stack is empty.\r\n     */\r\n    Stack.prototype.peek = function () {\r\n        return this.list.first();\r\n    };\r\n    /**\r\n     * Returns the number of elements in this stack.\r\n     * @return {number} the number of elements in this stack.\r\n     */\r\n    Stack.prototype.size = function () {\r\n        return this.list.size();\r\n    };\r\n    /**\r\n     * Returns true if this stack contains the specified element.\r\n     * <p>If the elements inside this stack are\r\n     * not comparable with the === operator, a custom equals function should be\r\n     * provided to perform searches, the function must receive two arguments and\r\n     * return true if they are equal, false otherwise. Example:</p>\r\n     *\r\n     * <pre>\r\n     * const petsAreEqualByName (pet1, pet2) {\r\n     *  return pet1.name === pet2.name;\r\n     * }\r\n     * </pre>\r\n     * @param {Object} elem element to search for.\r\n     * @param {function(Object,Object):boolean=} equalsFunction optional\r\n     * function to check if two elements are equal.\r\n     * @return {boolean} true if this stack contains the specified element,\r\n     * false otherwise.\r\n     */\r\n    Stack.prototype.contains = function (elem, equalsFunction) {\r\n        return this.list.contains(elem, equalsFunction);\r\n    };\r\n    /**\r\n     * Checks if this stack is empty.\r\n     * @return {boolean} true if and only if this stack contains no items; false\r\n     * otherwise.\r\n     */\r\n    Stack.prototype.isEmpty = function () {\r\n        return this.list.isEmpty();\r\n    };\r\n    /**\r\n     * Removes all of the elements from this stack.\r\n     */\r\n    Stack.prototype.clear = function () {\r\n        this.list.clear();\r\n    };\r\n    /**\r\n     * Executes the provided function once for each element present in this stack in\r\n     * LIFO order.\r\n     * @param {function(Object):*} callback function to execute, it is\r\n     * invoked with one argument: the element value, to break the iteration you can\r\n     * optionally return false.\r\n     */\r\n    Stack.prototype.forEach = function (callback) {\r\n        this.list.forEach(callback);\r\n    };\r\n    return Stack;\r\n}());\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.default = Stack; // End of stack\r\n//# sourceMappingURL=Stack.js.map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/typescript-collections/dist/lib/Stack.js\n ** module id = 18\n ** module chunks = 0\n **/","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         toSources } from \"./Lambda\";\nimport { Transaction, transactionally, currentTransaction } from \"./Transaction\";\nimport { StreamWithSend } from \"./Stream\";\nimport { Vertex } from \"./Vertex\";\n\nexport class CoalesceHandler<A>\n{\n\tconstructor(f : ((l : A, r : A) => A) | Lambda2<A,A,A>, out : StreamWithSend<A>)\n\t{\n\t    this.f = Lambda2_toFunction(f);\n\t    this.out = out;\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(\n            toSources(Lambda2_deps(f)));\n        this.accumValid = false;\n    }\n\tprivate f : (l : A, r : A) => A;\n\tprivate out : StreamWithSend<A>;\n\tprivate accumValid : boolean;\n    private accum : A;\n    private verbose : boolean;\n    send_(a : A) {\n        if (this.accumValid)\n            this.accum = this.f(this.accum, a);\n        else {\n            currentTransaction.prioritized(this.out.getVertex__(), () => {\n                this.out.send_(this.accum);\n                this.accumValid = false;\n                this.accum = null;\n            });\n            this.accum = a;\n            this.accumValid = true;\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/CoalesceHandler.ts\n **/","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction, transactionally, currentTransaction } from \"./Transaction\";\nimport { Lazy } from \"./Lazy\";\nimport { Listener } from \"./Listener\";\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { Operational } from \"./Operational\";\n\nclass LazySample<A> {\n    constructor(cell : Cell<A>) {\n        this.cell = cell;\n    }\n    cell : Cell<A>;\n    hasValue : boolean = false;\n    value : A = null;\n}\n\nclass ApplyState<A,B> {\n    constructor() {}\n    f : (a : A) => B = null;\n    f_present : boolean = false;\n    a : A = null;\n    a_present : boolean = false;\n}\n\nexport class Cell<A> {\n\tprivate str : Stream<A>;\n\tprotected value : A;\n\tprotected valueUpdate : A;\n\tprivate cleanup : () => void;\n\tprotected lazyInitValue : Lazy<A>;  // Used by LazyCell\n\tprivate vertex : Vertex;\n\n    constructor(initValue : A, str? : Stream<A>) {\n        this.value = initValue;\n        if (!str) {\n            this.str = new Stream<A>();\n            this.vertex = new Vertex(\"ConstCell\", 0, []);\n        }\n        else\n            transactionally(() => this.setStream(str));\n    }\n\n    protected setStream(str : Stream<A>) {\n        this.str = str;\n        const me = this,\n              src = new Source(\n                str.getVertex__(),\n                () => {\n                    return str.listen_(me.vertex, (a : A) => {\n                        if (me.valueUpdate == null) {\n                            currentTransaction.last(() => {\n                                me.value = me.valueUpdate;\n                                me.lazyInitValue = null;\n                                me.valueUpdate = null;\n                            });\n                        }\n                        me.valueUpdate = a;\n                    }, false);\n                }\n            );\n        this.vertex = new Vertex(\"Cell\", 0, [src]);\n        // We do a trick here of registering the source for the duration of the current\n        // transaction so that we are guaranteed to catch any stream events that\n        // occur in the same transaction.\n        this.vertex.register(Vertex.NULL);\n        currentTransaction.last(() => {\n            this.vertex.deregister(Vertex.NULL);\n        });\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    getStream__() : Stream<A> {  // TO DO: Figure out how to hide this\n        return this.str;\n    }\n\n    /**\n     * Sample the cell's current value.\n     * <p>\n     * It may be used inside the functions passed to primitives that apply them to {@link Stream}s,\n     * including {@link Stream#map(Lambda1)} in which case it is equivalent to snapshotting the cell,\n     * {@link Stream#snapshot(Cell, Lambda2)}, {@link Stream#filter(Lambda1)} and\n     * {@link Stream#merge(Stream, Lambda2)}.\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\n     * miss any updates, but in many circumstances it makes sense.\n     */\n    sample() : A {\n        return transactionally(() => { return this.sampleNoTrans__(); });\n    }\n\n    sampleNoTrans__() : A {  // TO DO figure out how to hide this\n        return this.value;\n    }\n\n    /**\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\n     */\n    sampleLazy() : Lazy<A> {\n        const me = this;\n        return transactionally(() => me.sampleLazyNoTrans__());\n    }\n\n    sampleLazyNoTrans__() : Lazy<A> {  // TO DO figure out how to hide this\n        const me = this,\n            s = new LazySample<A>(me);\n        currentTransaction.last(() => {\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\n            s.hasValue = true;\n            s.cell = null;\n        });\n        return new Lazy<A>(() => {\n            if (s.hasValue)\n                return s.value;\n            else\n                return s.cell.sample();\n        });\n    }\n\n    /**\n     * Transform the cell's value according to the supplied function, so the returned Cell\n     * always reflects the value of the function applied to the input Cell's value.\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Cell<B> {\n        const c = this;\n        return transactionally(() =>\n            Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda1_toFunction(f)))\n        );\n    }\n\n\t/**\n\t * Lift a binary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift<B,C>(b : Cell<B>,\n\t          fn0 : ((a : A, b : B) => C) |\n\t                Lambda2<A,B,C>) : Cell<C> {\n        const fn = Lambda2_toFunction(fn0),\n            cf = this.map((aa : A) => (bb : B) => fn(aa, bb));\n        return Cell.apply(cf, b,\n            toSources(Lambda2_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a ternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift3<B,C,D>(b : Cell<B>, c : Cell<C>,\n\t             fn0 : ((a : A, b : B, c : C) => D) |\n\t                   Lambda3<A,B,C,D>) : Cell<D> {\n        const fn = Lambda3_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => D =\n                 (aa : A) => (bb : B) => (cc : C) => fn(aa, bb, cc),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply<B, (c : C) => D>(cf, b),\n                   c,\n                   toSources(Lambda3_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a quaternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\n\t               fn0 : ((a : A, b : B, c : C, d : D) => E) |\n\t                     Lambda4<A,B,C,D,E>) : Cell<E> {\n        const fn = Lambda4_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => E =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => fn(aa, bb, cc, dd),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply<B, (c : C) => (d : D) => E>(cf, b),\n                       c),\n                   d,\n                   toSources(Lambda4_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\n\t                 fn0 : ((a : A, b : B, c : C, d : D, e : E) => F) |\n\t                       Lambda5<A,B,C,D,E,F>) : Cell<F> {\n        const fn = Lambda5_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => F =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => fn(aa, bb, cc, dd, ee),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply<B, (c : C) => (d : D) => (e : E) => F>(cf, b),\n                           c),\n                       d),\n                   e,\n                   toSources(Lambda5_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\n\t                   fn0 : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) |\n\t                         Lambda6<A,B,C,D,E,F,G>) : Cell<G> {\n        const fn = Lambda6_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => G =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => fn(aa, bb, cc, dd, ee, ff),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply(\n                               Cell.apply<B, (c : C) => (d : D) => (e : E) => (f : F) => G>(cf, b),\n                               c),\n                           d),\n                       e),\n                   f,\n                   toSources(Lambda6_deps(fn0)));\n\t}\n\n\t/**\n\t * Apply a value inside a cell to a function inside a cell. This is the\n\t * primitive for all function lifting.\n\t */\n\tstatic apply<A,B>(cf : Cell<(a : A) => B>, ca : Cell<A>, sources? : Source[]) : Cell<B> {\n    \treturn transactionally(() => {\n    \t    const state = new ApplyState<A,B>(),\n                out = new StreamWithSend<B>(),\n                cf_value = Operational.value(cf),\n                ca_value = Operational.value(ca),\n                src1 = new Source(\n                        cf_value.getVertex__(),\n                        () => {\n                            return cf_value.listen_(out.getVertex__(), (f : (a : A) => B) => {\n                                state.f = f;\n                                state.f_present = true;\n                                if (state.a_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    ),\n                src2 = new Source(\n                        ca_value.getVertex__(),\n                        () => {\n                            return ca_value.listen_(out.getVertex__(), (a : A) => {\n                                state.a = a;\n                                state.a_present = true;\n                                if (state.f_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    );\n            out.setVertex__(new Vertex(\"apply\", 0,\n                [src1, src2].concat(sources ? sources : []) \n            ));\n            return out.coalesce__((l, r) => r).holdLazy(new Lazy<B>(() =>\n                    cf.sampleNoTrans__()(ca.sampleNoTrans__())\n                ));\n        });\n\t}\n\n\t/**\n\t * Unwrap a cell inside another cell to give a time-varying cell implementation.\n\t */\n    static switchC<A>(cca : Cell<Cell<A>>) : Cell<A> {\n\t    return transactionally(() => {\n            const za = cca.sampleLazy().map((ba : Cell<A>) => ba.sample()),\n                out = new StreamWithSend<A>();\n            let last_ca : Cell<A> = null;\n            const cca_value = Operational.value(cca),\n                  src = new Source(\n                        cca_value.getVertex__(),\n                        () => {\n                            let kill2 : () => void = last_ca === null ? null :\n                                    Operational.value(last_ca).listen_(out.getVertex__(),\n                                        (a : A) => out.send_(a), false);\n                            const kill1 = cca_value.listen_(out.getVertex__(), (ca : Cell<A>) => {\n                                // Note: If any switch takes place during a transaction, then the\n                                // coalesce__() below will always cause a sample to be fetched\n                                // from the one we just switched to. So anything from the old input cell\n                                // that might have happened during this transaction will be suppressed.\n                                last_ca = ca;\n                                if (kill2 !== null)\n                                    kill2();\n                                kill2 = Operational.value(ca).listen_(out.getVertex__(),\n                                    (a : A) => out.send_(a), false);\n                            }, false);\n                            return () => { kill1(); kill2(); }; \n                        }\n                    );\n            out.setVertex__(new Vertex(\"switchC\", 0, [src]));\n            return out.coalesce__((l, r) => r).holdLazy(za);\n        });\n\t}\n\n\t/**\n\t * Unwrap a stream inside a cell to give a time-varying stream implementation.\n\t */\n\tstatic switchS<A>(csa : Cell<Stream<A>>) : Stream<A> {\n\t    return transactionally(() => {\n            const out = new StreamWithSend<A>(),\n                  h2 = (a : A) => {\n                          out.send_(a);\n                      },\n                  src = new Source(\n                      csa.getVertex__(),\n                      () => {\n                          let kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\n                          const kill1 = csa.getStream__().listen_(out.getVertex__(), (sa : Stream<A>) => {\n                              kill2();\n                              kill2 = sa.listen_(out.getVertex__(), h2, true);\n                          }, false);\n                          return () => { kill1(); kill2(); }; \n                      }\n                  );\n\t        out.setVertex__(new Vertex(\"switchS\", 0, [src]));\n\t        return out;\n\t    });\n    }\n\n\t/**\n\t * Listen for updates to the value of this cell. This is the observer pattern. The\n\t * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\n\t * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\n\t * the world of I/O and for FRP.\n\t * @param h The handler to execute when there's a new value.\n\t *   You should make no assumptions about what thread you are called on, and the\n\t *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\n\t *   or {@link StreamSink#send(Object)} in the handler.\n\t *   An exception will be thrown, because you are not meant to use this to create\n\t *   your own primitives.\n     */\n    listen(h : (a : A) => void) : () => void {\n        return transactionally(() => {\n            return Operational.value(this).listen(h);\n        });\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Cell.ts\n **/","/**\n * A representation for a value that may not be available until the current\n * transaction is closed.\n */\nexport class Lazy<A> {\n    constructor(f : () => A) {\n        this.f = f;\n    }\n\n    private f : () => A;\n\n    /**\n     * Get the value if available, throwing an exception if not.\n     * In the general case this should only be used in subsequent transactions to\n     * when the Lazy was obtained.\n     */\n    get() : A {\n        return this.f();\n    }\n\n    /**\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\n     * the value of the function applied to the input Lazy's value.\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : (a : A) => B) {\n        return new Lazy<B>(() => { return f(this.f()); });\n    }\n\n\t/**\n\t * Lift a binary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift<B,C>(b : Lazy<B>, f : (a : A, b : B) => C) : Lazy<C> {\n        return new Lazy<C>(() => { return f(this.f(), b.f()); });\n    }\n\n\t/**\n\t * Lift a ternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift3<B,C,D>(b : Lazy<B>, c : Lazy<C>, f : (a : A, b : B, c : C) => D) : Lazy<D> {\n        return new Lazy<D>(() => { return f(this.f(), b.f(), c.f()); });\n    }\n\n\t/**\n\t * Lift a quaternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift4<B,C,D,E>(b : Lazy<B>, c : Lazy<C>, d : Lazy<D>, f : (a : A, b : B, c : C, d : D) => E) : Lazy<E> {\n        return new Lazy<E>(() => { return f(this.f(), b.f(), c.f(), d.f()); });\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Lazy.ts\n **/","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { transactionally, currentTransaction } from \"./Transaction\";\nimport { Unit } from \"./Unit\";\nimport { Source, Vertex } from \"./Vertex\";\n\nexport class Operational {\n    /**\n     * A stream that gives the updates/steps for a {@link Cell}.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static updates<A>(c : Cell<A>) : Stream<A> {\n        /*  Don't think this is needed\n        const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"updates\", 0, [\n                new Source(\n                    c.getStream__().getVertex__(),\n                    () => {\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                ),\n                new Source(\n                    c.getVertex__(),\n                    () => {\n                        return () => { };\n                    }\n                )\n            ]\n        ));\n        return out;\n        */\n        return c.getStream__();\n    }\n\n    /**\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\n     * firing for each update/step of the cell's value.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static value<A>(c : Cell<A>) : Stream<A> {\n        return transactionally(() => {\n            const sSpark = new StreamWithSend<Unit>();\n            currentTransaction.prioritized(sSpark.getVertex__(), () => {\n                sSpark.send_(Unit.UNIT);\n            });\n            const sInitial = sSpark.snapshot1(c);\n            return Operational.updates(c).orElse(sInitial);\n        });\n    }\n\n\t/**\n\t * Push each event onto a new transaction guaranteed to come before the next externally\n\t * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\n\t */\n\tstatic defer<A>(s : Stream<A>) : Stream<A> {\n\t    return Operational.split<A>(s.map((a : A) => {\n\t        return [a];\n\t    }));\n    }\n\n\t/**\n\t * Push each event in the list onto a newly created transaction guaranteed\n\t * to come before the next externally initiated transaction. Note that the semantics\n\t * are such that two different invocations of split() can put events into the same\n\t * new transaction, so the resulting stream's events could be simultaneous with\n\t * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\n\t */\n\tstatic split<A>(s : Stream<Array<A>>) : Stream<A> {\n\t    const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"split\", 0, [\n                new Source(\n                    s.getVertex__(),\n                    () => {\n                        return s.listen_(out.getVertex__(), (as : Array<A>) => {\n                            for (let i = 0; i < as.length; i++) {\n                                currentTransaction.post(i, () => {\n                                    transactionally(() => {\n                                        out.send_(as[i]);\n                                    });\n                                });\n                            }\n                        }, false);\n                    }\n                )\n            ]\n        ));\n        return out;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Operational.ts\n **/","export class Unit {\n    static UNIT : Unit = new Unit();\n    constructor() {}\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Unit.ts\n **/","import { Source, Vertex } from \"./Vertex\";\n\nexport class Listener<A> {\n    constructor(h : (a : A) => void, target : Vertex) {\n        this.h = h;\n        this.target = target;\n    }\n    h : (a : A) => void;\n    target : Vertex;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Listener.ts\n **/","import { Lazy } from \"./Lazy\";\nimport { Cell } from \"./Cell\";\nimport { Stream } from \"./Stream\";\nimport { transactionally } from \"./Transaction\";\n\nexport class LazyCell<A> extends Cell<A> {\n    constructor(lazyInitValue : Lazy<A>, str? : Stream<A>) {\n        super(null, null);\n        transactionally(() => {\n            if (str)\n                this.setStream(str);\n            this.lazyInitValue = lazyInitValue;\n        });\n    }\n\n    sampleNoTrans__() : A {  // Override\n        if (this.value == null && this.lazyInitValue != null) {\n            this.value = this.lazyInitValue.get();\n            this.lazyInitValue = null;\n        }\n        return this.value;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/LazyCell.ts\n **/","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { StreamWithSend } from \"./Stream\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { transactionally, currentTransaction } from \"./Transaction\";\n\n/**\n * A stream that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\n * should downcast to {@link Stream}.\n */\nexport class StreamSink<A> extends StreamWithSend<A> {\n    constructor(f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n        super();\n        if (!f)\n            f = <(l : A, r : A) => A>((l : A, r : A) => {\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\n            });\n        this.coalescer = new CoalesceHandler<A>(f, this);\n    }\n\n    private coalescer : CoalesceHandler<A>;\n\n    send(a : A) : void {\n        transactionally<void>(\n            () => {\n                if (currentTransaction.inCallback > 0)\n                    throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\n                this.coalescer.send_(a);\n            }\n        )\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/StreamSink.ts\n **/","import { Cell } from \"./Cell\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\nimport { transactionally } from \"./Transaction\";\nimport { StreamLoop } from \"./Stream\";\n\n/**\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced. \n */\nexport class CellLoop<A> extends LazyCell<A> {\n    constructor() {\n    \tsuper(null, new StreamLoop<A>());\n    }\n\n    /**\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(a_out : Cell<A>) : void {\n        const me = this;\n        transactionally(() => {\n            (<StreamLoop<A>>me.getStream__()).loop(a_out.getStream__());\n            me.lazyInitValue = a_out.sampleLazy();\n        });\n    }\n\n    sampleNoTrans__() : A\n    {\n        if (!(<StreamLoop<A>>this.getStream__()).assigned__)\n            throw new Error(\"CellLoop sampled before it was looped\");\n        return super.sampleNoTrans__();\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/CellLoop.ts\n **/","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { Cell } from \"./Cell\";\nimport { StreamSink } from \"./StreamSink\";\nimport { transactionally } from \"./Transaction\";\n\n/**\n * A cell that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\n * should downcast to {@link Cell}.\n */\nexport class CellSink<A> extends Cell<A> {\n    /**\n     * Construct a writable cell with the specified initial value. If multiple values are\n     * sent in the same transaction, the specified function is used to combine them.\n     *\n     * If the function is not supplied, then an exception will be thrown in this case.\n     */\n    constructor(initValue : A, f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n    \tsuper(initValue, new StreamSink<A>(f));\n    }\n\n    /**\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\n     * You are not meant to use this to define your own primitives.\n     * @param a Value to push into the cell.\n     */\n    send(a : A) : void {\n        (<StreamSink<A>>this.getStream__()).send(a);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/CellSink.ts\n **/","export class Tuple2<A,B> {\n    constructor(a : A, b : B) {\n        this.a = a;\n        this.b = b;\n    }\n    a : A;\n    b : B;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/Tuple2.ts\n **/","import { Vertex, Source } from \"./Vertex\";\nimport { BSTree } from 'typescript-collections';\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { StreamSink } from \"./StreamSink\";\nimport { Cell } from \"./Cell\";\nimport { CellSink } from \"./CellSink\";\nimport { Transaction, transactionally, currentTransaction } from \"./Transaction\";\n\n/**\n * An interface for implementations of FRP timer systems.\n */\nexport abstract class TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    abstract setTimer(t : number, callback : () => void) : () => void;\n\n    /**\n     * Return the current clock time.\n     */\n    abstract now() : number;\n}\n\nlet nextSeq : number = 0;\n\nclass Event {\n    constructor(t : number, sAlarm : StreamWithSend<number>) {\n        this.t = t;\n        this.sAlarm = sAlarm;\n        this.seq = ++nextSeq;\n    }\n    t : number;\n    sAlarm : StreamWithSend<number>;\n    seq : number;  // Used to guarantee uniqueness\n}\n\nexport class TimerSystem {\n    constructor(impl : TimerSystemImpl) {\n        transactionally(() => {\n            this.impl = impl;\n            const timeSnk = new CellSink<number>(impl.now());\n            this.time = timeSnk;\n            // A dummy listener to time to keep it alive even when there are no other listeners.\n            this.time.listen((t : number) => { });\n            Transaction.onStart(() => {\n                const t = impl.now();\n                // Pop and execute all events earlier than or equal to t (the current time).\n                while (true) {\n                    let ev : Event = null;\n                    if (!this.eventQueue.isEmpty()) {\n                        let mev = this.eventQueue.minimum();\n                        if (mev.t <= t) {\n                            ev = mev;\n                            // TO DO: Detect infinite loops!\n                            //this.eventQueue.remove(mev);\n                        }\n                    }\n                    if (ev != null) {\n                        timeSnk.send(ev.t);\n                        transactionally(() => ev.sAlarm.send_(ev.t));\n                    }\n                    else\n                        break;\n                }\n                timeSnk.send(t);\n            });\n        });\n    }\n\n    private impl : TimerSystemImpl;\n\n    /**\n     * A cell giving the current clock time.\n     */\n    time : Cell<number>;\n\n    private eventQueue : BSTree<Event> = new BSTree<Event>((a, b) => {\n        if (a.t < b.t) return -1;\n        if (a.t > b.t) return 1;\n        if (a.seq < b.seq) return -1;\n        if (a.seq > b.seq) return 1;\n        return 0;\n    });\n\n    /**\n     * A timer that fires at the specified time, which can be null, meaning\n     * that the alarm is not set.\n     */\n    at(tAlarm : Cell<number>) : Stream<number> {\n        let current : Event = null,\n            cancelCurrent : () => void = null,\n            active : boolean = false,\n            tAl : number = null,\n            sampled : boolean = false;\n        const sAlarm = new StreamWithSend<number>(null),\n            updateTimer = () => {\n                if (cancelCurrent !== null) {\n                    cancelCurrent();\n                    this.eventQueue.remove(current);\n                }\n                cancelCurrent = null;\n                current = null;\n                if (active) {\n                    if (!sampled) {\n                        sampled = true;\n                        tAl = tAlarm.sampleNoTrans__();\n                    }\n                    if (tAl !== null) {\n                        current = new Event(tAl, sAlarm);\n                        this.eventQueue.add(current);\n                        cancelCurrent = this.impl.setTimer(tAl, () => {\n                                    // Open and close a transaction to trigger queued\n                                    // events to run.\n                                    transactionally(() => {});\n                                });\n                    }\n                }\n            };\n        sAlarm.setVertex__(new Vertex(\"at\", 0, [\n                new Source(\n                    tAlarm.getVertex__(),\n                    () => {\n                        active = true;\n                        sampled = false;\n                        currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\n                        const kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), (oAlarm : number) => {\n                            tAl = oAlarm;\n                            sampled = true;\n                            updateTimer();\n                        }, false);\n                        return () => {\n                            active = false;\n                            updateTimer();\n                            kill();\n                        };\n                    }\n                )\n            ]\n        ));\n        return sAlarm;\n    }\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/TimerSystem.ts\n **/","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using seconds as the time unit.\n */\nexport class SecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new SecondsTimerSystemImpl());\n    }\n}\n\nclass SecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, (t - this.now()) * 1000);\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now() * 0.001;\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/SecondsTimerSystem.ts\n **/","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using milliseconds as the time unit.\n */\nexport class MillisecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new MillisecondsTimerSystemImpl());\n    }\n}\n\nclass MillisecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, t - this.now());\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now();\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/MillisecondsTimerSystem.ts\n **/","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Vertex, Source } from \"./Vertex\";\nimport { transactionally } from \"./Transaction\";\n\nexport class IOAction {\n    /*!\n     * Convert a function that performs asynchronous I/O taking input A\n     * and returning a value of type B into an I/O action of type\n     * (sa : Stream<A>) => Stream<B>\n     */\n    static fromAsync<A,B>(performIO : (a : A, result : (b : B) => void) => void)\n            : (sa : Stream<A>) => Stream<B> {\n        return (sa : Stream<A>) => {\n            const out = new StreamWithSend<B>(null);\n            out.setVertex__(new Vertex(\"map\", 0, [\n                    new Source(\n                        sa.getVertex__(),\n                        () => {\n                            return sa.listen_(out.getVertex__(), (a : A) => {\n                                performIO(a, (b : B) => {\n                                    transactionally(() => {\n                                        out.send_(b);\n                                    });\n                                });\n                            }, false);\n                        }\n                    )\n                ]\n            ));\n            return out;\n        }\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./src/lib/IOAction.ts\n **/"],"sourceRoot":""}