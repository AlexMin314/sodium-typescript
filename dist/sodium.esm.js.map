{"version":3,"file":"sodium.esm.js","sources":["../src/lib/sodium/Vertex.ts","../src/lib/sodium/Lambda.ts","../src/lib/sodium/Transaction.ts","../src/lib/sodium/CoalesceHandler.ts","../src/lib/sodium/Lazy.ts","../src/lib/sodium/Unit.ts","../src/lib/sodium/Operational.ts","../src/lib/sodium/Cell.ts","../src/lib/sodium/Listener.ts","../src/lib/sodium/LazyCell.ts","../src/lib/sodium/Stream.ts","../src/lib/sodium/StreamSink.ts","../src/lib/sodium/CellLoop.ts","../src/lib/sodium/CellSink.ts","../src/lib/sodium/Tuple2.ts","../src/lib/sodium/TimerSystem.ts","../src/lib/sodium/SecondsTimerSystem.ts","../src/lib/sodium/MillisecondsTimerSystem.ts","../src/lib/sodium/IOAction.ts"],"sourcesContent":["import { Set } from \"typescript-collections\";\n\nlet totalRegistrations : number = 0;\nexport function getTotalRegistrations() : number {\n    return totalRegistrations;\n}\n\nexport class Source {\n    constructor(\n        origin : Vertex,\n        register_ : () => () => void\n    ) {\n        if (origin === null)\n            throw new Error(\"null origin!\");\n        this.origin = origin;\n        this.register_ = register_;\n    }\n    origin : Vertex;\n    private register_ : () => () => void;\n    private registered : boolean = false;\n    private deregister_ : () => void = null;\n\n    register(target : Vertex) : void {\n        if (!this.registered) {\n            this.registered = true;\n            if (this.register_ !== null)\n                this.deregister_ = this.register_();\n            else {\n                this.origin.increment(target);\n                this.deregister_ = () => this.origin.decrement(target);\n            }\n        }\n    }\n    deregister(target : Vertex) : void {\n        if (this.registered) {\n            this.registered = false;\n            if (this.deregister_ !== null)\n                this.deregister_();\n        }\n    }\n}\n\nexport enum Color { black, gray, white, purple };\nlet roots : Vertex[] = [];\nlet nextID : number = 0;\nlet verbose : boolean = false;\n\nexport function setVerbose(v : boolean) : void { verbose = v; }\n\nexport function describeAll(v : Vertex, visited : Set<number>)\n{\n    if (visited.contains(v.id)) return;\n    console.log(v.descr());\n    visited.add(v.id);\n    let chs = v.children();\n    for (let i = 0; i < chs.length; i++)\n        describeAll(chs[i], visited);\n}\n\nexport class Vertex {\n    static NULL : Vertex = new Vertex(\"user\", 1e12, []);\n    id : number;\n\n\tconstructor(name : string, rank : number, sources : Source[]) {\n\t    this.name = name;\n\t\tthis.rank = rank;\n\t\tthis.sources = sources;\n\t\tthis.id = nextID++;\n\t}\n\tname : string;\n    rank : number;\n    sources : Source[];\n    targets : Vertex[] = [];\n    childrn : Vertex[] = [];\n    refCount() : number { return this.targets.length; };\n    visited : boolean = false;\n    register(target : Vertex) : boolean {\n        return this.increment(target);\n    }\n    deregister(target : Vertex) : void {\n        if (verbose)\n            console.log(\"deregister \"+this.descr()+\" => \"+target.descr());\n        this.decrement(target);\n        Vertex.collectCycles();\n    }\n    private incRefCount(target : Vertex) : boolean {\n        let anyChanged : boolean = false;\n        if (this.refCount() == 0) {\n            for (let i = 0; i < this.sources.length; i++)\n                this.sources[i].register(this);\n        }\n        this.targets.push(target);\n        target.childrn.push(this);\n        if (target.ensureBiggerThan(this.rank))\n            anyChanged = true;\n        totalRegistrations++;\n        return anyChanged;\n    }\n\n    private decRefCount(target : Vertex) : void {\n        if (verbose)\n            console.log(\"DEC \"+this.descr());\n        let matched = false;\n        for (let i = 0; i < target.childrn.length; i++)\n            if (target.childrn[i] === this) {\n                target.childrn.splice(i, 1);\n            }\n        for (let i = 0; i < this.targets.length; i++)\n            if (this.targets[i] === target) {\n                this.targets.splice(i, 1);\n                matched = true;\n                break;\n            }\n        if (matched) {\n            if (this.refCount() == 0) {\n                for (let i = 0; i < this.sources.length; i++)\n                    this.sources[i].deregister(this);\n            }\n            totalRegistrations--;\n        }\n    }\n\n    addSource(src : Source) : void {\n        this.sources.push(src);\n        if (this.refCount() > 0)\n            src.register(this);\n    }\n\n\tprivate ensureBiggerThan(limit : number) : boolean {\n\t\tif (this.rank > limit || this.visited)\n\t\t\treturn false;\n\n        this.visited = true;\n\t\tthis.rank = limit + 1;\n\t\tfor (let i = 0; i < this.targets.length; i++)\n\t\t\tthis.targets[i].ensureBiggerThan(this.rank);\n        this.visited = false;\n\t\treturn true;\n\t}\n\n\tdescr() : string {\n        let colStr : string = null;\n        switch (this.color) {\n        case Color.black: colStr = \"black\"; break;\n        case Color.gray:  colStr = \"gray\"; break;\n        case Color.white: colStr = \"white\"; break;\n        case Color.purple: colStr = \"purple\"; break;\n        }\n        let str = this.id+\" \"+this.name+\" [\"+this.refCount()+\"/\"+this.refCountAdj+\"] \"+colStr+\" ->\";\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            str = str + \" \" + chs[i].id;\n        }\n        return str;\n\t}\n\n\t// --------------------------------------------------------\n\t// Synchronous Cycle Collection algorithm presented in \"Concurrent\n\t// Cycle Collection in Reference Counted Systems\" by David F. Bacon\n\t// and V.T. Rajan.\n\n    color : Color = Color.black;\n    buffered : boolean = false;\n    refCountAdj : number = 0;\n\n\tchildren() : Vertex[] { return this.childrn; }\n\n\tincrement(referrer : Vertex) : boolean {\n\t    return this.incRefCount(referrer);\n\t}\n\n\tdecrement(referrer : Vertex) : void {\n\t    this.decRefCount(referrer);\n\t    if (this.refCount() == 0)\n\t        this.release();\n        else\n            this.possibleRoots();\n\t}\n\n    release() : void {\n        this.color = Color.black;\n        if (!this.buffered)\n            this.free();\n    }\n\n    free() : void {\n        while (this.targets.length > 0)\n            this.decRefCount(this.targets[0]);\n    }\n\n\tpossibleRoots() : void {\n\t    if (this.color != Color.purple) {\n\t        this.color = Color.purple;\n\t        if (!this.buffered) {\n                this.buffered = true;\n                roots.push(this);\n            }\n        }\n\t}\n\n\tstatic collectCycles() : void {\n\t    Vertex.markRoots();\n\t    Vertex.scanRoots();\n\t    Vertex.collectRoots();\n\t}\n\n\tstatic markRoots() : void {\n\t    const newRoots : Vertex[] = [];\n\t    for (let i = 0; i < roots.length; i++) {\n            if (verbose)\n                console.log(\"markRoots \"+roots[i].descr());  // ###\n\t        if (roots[i].color == Color.purple) {\n\t            roots[i].markGray();\n\t            newRoots.push(roots[i]);\n            }\n\t        else {\n\t            roots[i].buffered = false;\n\t            if (roots[i].color == Color.black && roots[i].refCount() == 0)\n\t                roots[i].free();\n            }\n\t    }\n\t    roots = newRoots;\n\t}\n\n\tstatic scanRoots() : void {\n\t    for (let i = 0; i < roots.length; i++)\n\t        roots[i].scan();\n\t}\n\n\tstatic collectRoots() : void {\n\t    for (let i = 0; i < roots.length; i++) {\n\t        roots[i].buffered = false;\n\t        roots[i].collectWhite();\n\t    }\n\t    roots = [];\n\t}\n\n\tmarkGray() : void {\n\t    if (this.color != Color.gray) {\n\t        this.color = Color.gray;\n\t        let chs = this.children();\n\t        for (let i = 0; i < chs.length; i++) {\n\t            chs[i].refCountAdj--;\n                if (verbose)\n                    console.log(\"markGray \"+this.descr());\n\t            chs[i].markGray();\n            }\n\t    }\n\t}\n\n\tscan() : void {\n\t    if (verbose)\n            console.log(\"scan \"+this.descr());\n\t    if (this.color == Color.gray) {\n\t        if (this.refCount()+this.refCountAdj > 0)\n\t            this.scanBlack();\n\t        else {\n\t            this.color = Color.white;\n                if (verbose)\n                    console.log(\"scan WHITE \"+this.descr());\n                let chs = this.children();\n                for (let i = 0; i < chs.length; i++)\n                    chs[i].scan();\n\t        }\n\t    }\n\t}\n\n\tscanBlack() : void {\n\t    this.color = Color.black;\n        let chs = this.children();\n        for (let i = 0; i < chs.length; i++) {\n            chs[i].refCountAdj++;\n            if (verbose)\n                console.log(\"scanBlack \"+this.descr());\n            if (chs[i].color != Color.black)\n                chs[i].scanBlack();\n        }\n\t}\n\n\tcollectWhite() : void {\n\t    if (this.color == Color.white && !this.buffered) {\n            if (verbose)\n                console.log(\"collectWhite \"+this.descr());\n\t        this.color = Color.black;\n\t        this.refCountAdj = 0;\n            let chs = this.children();\n            for (let i = 0; i < chs.length; i++)\n                chs[i].collectWhite();\n            this.free();\n\t    }\n\t}\n}\n","import { Stream } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { Source } from \"./Vertex\";\n\nexport class Lambda1<A,B> {\n    constructor(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A) => B;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda1<A,B>(f : (a : A) => B,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda1<A,B>\n{\n    return new Lambda1(f, deps);\n}\n\nexport function Lambda1_deps<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda1)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda1_toFunction<A,B>(f : ((a : A) => B) | Lambda1<A,B>) : (a : A) => B {\n    if (f instanceof Lambda1)\n        return f.f;\n    else\n        return <(a : A) => B>f;\n}\n\nexport class Lambda2<A,B,C> {\n    constructor(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B) => C;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda2<A,B,C>(f : (a : A, b : B) => C,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda2<A,B,C>\n{\n    return new Lambda2(f, deps);\n}\n\nexport function Lambda2_deps<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda2)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda2_toFunction<A,B,C>(f : ((a : A, b : B) => C) | Lambda2<A,B,C>) : (a : A, b : B) => C {\n    if (f instanceof Lambda2)\n        return f.f;\n    else\n        return <(a : A, b : B) => C>f;\n}\n\nexport class Lambda3<A,B,C,D> {\n    constructor(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C) => D;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda3<A,B,C,D>(f : (a : A, b : B, c : C) => D,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda3<A,B,C,D>\n{\n    return new Lambda3(f, deps);\n}\n\nexport function Lambda3_deps<A,B,C,D>(f : ((a : A, b : B, c : C) => D)\n        | Lambda3<A,B,C,D>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda3)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda3_toFunction<A,B,C,D>(f : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : (a : A, b : B, c : C) => D {\n    if (f instanceof Lambda3)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C) => D>f;\n}\n\nexport class Lambda4<A,B,C,D,E> {\n    constructor(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D) => E;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda4<A,B,C,D,E>(f : (a : A, b : B, c : C, d : D) => E,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda4<A,B,C,D,E>\n{\n    return new Lambda4(f, deps);\n}\n\nexport function Lambda4_deps<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda4)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda4_toFunction<A,B,C,D,E>(f : ((a : A, b : B, c : C, d : D) => E)\n        | Lambda4<A,B,C,D,E>) : (a : A, b : B, c : C, d : D) => E {\n    if (f instanceof Lambda4)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D) => E>f;\n}\n\nexport class Lambda5<A,B,C,D,E,F> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E) => F;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda5<A,B,C,D,E,F>(f : (a : A, b : B, c : C, d : D, e : E) => F,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda5<A,B,C,D,E,F>\n{\n    return new Lambda5(f, deps);\n}\n\nexport function Lambda5_deps<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda5)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda5_toFunction<A,B,C,D,E,F>(f : ((a : A, b : B, c : C, d : D, e : E) => F)\n        | Lambda5<A,B,C,D,E,F>) : (a : A, b : B, c : C, d : D, e : E) => F {\n    if (f instanceof Lambda5)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E) => F>f;\n}\n\nexport class Lambda6<A,B,C,D,E,F,G> {\n    constructor(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) {\n        this.f = f;\n        this.deps = deps;\n    }\n    f : (a : A, b : B, c : C, d : D, e : E, f : F) => G;\n    deps : Array<Stream<any>|Cell<any>>;\n}\n\nexport function lambda6<A,B,C,D,E,F,G>(f : (a : A, b : B, c : C, d : D, e : E, f : F) => G,\n                deps : Array<Stream<any>|Cell<any>>) : Lambda6<A,B,C,D,E,F,G>\n{\n    return new Lambda6(f, deps);\n}\n\nexport function Lambda6_deps<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : Array<Stream<any>|Cell<any>> {\n    if (f instanceof Lambda6)\n        return f.deps;\n    else\n        return [];\n}\n\nexport function Lambda6_toFunction<A,B,C,D,E,F,G>(f : ((a : A, b : B, c : C, d : D, e : E, f : F) => G)\n        | Lambda6<A,B,C,D,E,F,G>) : (a : A, b : B, c : C, d : D, e : E, f : F) => G {\n    if (f instanceof Lambda6)\n        return f.f;\n    else\n        return <(a : A, b : B, c : C, d : D, e : E, f : F) => G>f;\n}\n\nexport function toSources(deps : Array<Stream<any>|Cell<any>>) : Source[] {\n    const ss : Source[] = [];\n    for (let i = 0; i < deps.length; i++) {\n        const dep = deps[i];\n        ss.push(new Source(dep.getVertex__(), null));\n    }\n    return ss;\n}\n","import {Vertex} from './Vertex';\nimport * as Collections from 'typescript-collections';\n\nexport class Entry\n{\n  constructor(rank: Vertex, action: () => void)\n  {\n    this.rank = rank;\n    this.action = action;\n    this.seq = Entry.nextSeq++;\n  }\n\n  private static nextSeq: number = 0;\n  rank: Vertex;\n  action: () => void;\n  seq: number;\n\n  toString(): string\n  {\n    return this.seq.toString();\n  }\n}\n\nexport class Transaction\n{\n  public static currentTransaction: Transaction = null;\n  private static onStartHooks: (() => void)[] = [];\n  private static runningOnStartHooks: boolean = false;\n\n  constructor() {}\n\n  inCallback: number = 0;\n  private toRegen: boolean = false;\n\n  requestRegen(): void\n  {\n    this.toRegen = true;\n  }\n\n  prioritizedQ: Collections.PriorityQueue<Entry> = new Collections.PriorityQueue<Entry>((a, b) =>\n  {\n    // Note: Low priority numbers are treated as \"greater\" according to this\n    // comparison, so that the lowest numbers are highest priority and go first.\n    if (a.rank.rank < b.rank.rank) return 1;\n    if (a.rank.rank > b.rank.rank) return -1;\n    if (a.seq < b.seq) return 1;\n    if (a.seq > b.seq) return -1;\n    return 0;\n  });\n  private entries: Collections.Set<Entry> = new Collections.Set<Entry>((a) => a.toString());\n  private sampleQ: Array<() => void> = [];\n  private lastQ: Array<() => void> = [];\n  private postQ: Array<() => void> = null;\n\n  prioritized(target: Vertex, action: () => void): void\n  {\n    const e = new Entry(target, action);\n    this.prioritizedQ.enqueue(e);\n    this.entries.add(e);\n  }\n\n  sample(h: () => void): void\n  {\n    this.sampleQ.push(h);\n  }\n\n  last(h: () => void): void\n  {\n    this.lastQ.push(h);\n  }\n\n  /**\n   * Add an action to run after all last() actions.\n   */\n  post(childIx: number, action: () => void): void\n  {\n    if (this.postQ == null)\n      this.postQ = [];\n    // If an entry exists already, combine the old one with the new one.\n    while (this.postQ.length <= childIx)\n      this.postQ.push(null);\n    const existing = this.postQ[childIx],\n      neu =\n        existing === null ? action\n          : () =>\n        {\n          existing();\n          action();\n        };\n    this.postQ[childIx] = neu;\n  }\n\n  // If the priority queue has entries in it when we modify any of the nodes'\n  // ranks, then we need to re-generate it to make sure it's up-to-date.\n  private checkRegen(): void\n  {\n    if (this.toRegen)\n    {\n      this.toRegen = false;\n      this.prioritizedQ.clear();\n      const es = this.entries.toArray();\n      for (let i: number = 0; i < es.length; i++)\n        this.prioritizedQ.enqueue(es[i]);\n    }\n  }\n\n  public isActive() : boolean\n  {\n    return Transaction.currentTransaction ? true : false;\n  }\n\n  close(): void\n  {\n    while(true)\n    {\n      while (true)\n      {\n        this.checkRegen();\n        if (this.prioritizedQ.isEmpty()) break;\n        const e = this.prioritizedQ.dequeue();\n        this.entries.remove(e);\n        e.action();\n      }\n\n      const sq = this.sampleQ;\n      this.sampleQ = [];\n      for (let i = 0; i < sq.length; i++)\n        sq[i]();\n\n      if(this.prioritizedQ.isEmpty() && this.sampleQ.length < 1) break;\n    }\n\n    for (let i = 0; i < this.lastQ.length; i++)\n      this.lastQ[i]();\n    this.lastQ = [];\n    if (this.postQ != null)\n    {\n      for (let i = 0; i < this.postQ.length; i++)\n      {\n        if (this.postQ[i] != null)\n        {\n          const parent = Transaction.currentTransaction;\n          try\n          {\n            if (i > 0)\n            {\n              Transaction.currentTransaction = new Transaction();\n              try\n              {\n                this.postQ[i]();\n                Transaction.currentTransaction.close();\n              }\n              catch (err)\n              {\n                Transaction.currentTransaction.close();\n                throw err;\n              }\n            }\n            else\n            {\n              Transaction.currentTransaction = null;\n              this.postQ[i]();\n            }\n            Transaction.currentTransaction = parent;\n          }\n          catch (err)\n          {\n            Transaction.currentTransaction = parent;\n            throw err;\n          }\n        }\n      }\n      this.postQ = null;\n    }\n  }\n\n  /**\n   * Add a runnable that will be executed whenever a transaction is started.\n   * That runnable may start transactions itself, which will not cause the\n   * hooks to be run recursively.\n   *\n   * The main use case of this is the implementation of a time/alarm system.\n   */\n  static onStart(r: () => void): void\n  {\n    Transaction.onStartHooks.push(r);\n  }\n\n  public static run<A>(f: () => A): A\n  {\n    const transWas: Transaction = Transaction.currentTransaction;\n    if (transWas === null)\n    {\n      if (!Transaction.runningOnStartHooks)\n      {\n        Transaction.runningOnStartHooks = true;\n        try\n        {\n          for (let i = 0; i < Transaction.onStartHooks.length; i++)\n            Transaction.onStartHooks[i]();\n        }\n        finally\n        {\n          Transaction.runningOnStartHooks = false;\n        }\n      }\n      Transaction.currentTransaction = new Transaction();\n    }\n    try\n    {\n      const a: A = f();\n      if (transWas === null)\n      {\n        Transaction.currentTransaction.close();\n        Transaction.currentTransaction = null;\n      }\n      return a;\n    }\n    catch (err)\n    {\n      if (transWas === null)\n      {\n        Transaction.currentTransaction.close();\n        Transaction.currentTransaction = null;\n      }\n      throw err;\n    }\n  }\n}\n\n\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         toSources } from \"./Lambda\";\nimport { Transaction } from \"./Transaction\";\nimport { StreamWithSend } from \"./Stream\";\nimport { Vertex } from \"./Vertex\";\n\nexport class CoalesceHandler<A>\n{\n\tconstructor(f : ((l : A, r : A) => A) | Lambda2<A,A,A>, out : StreamWithSend<A>)\n\t{\n\t    this.f = Lambda2_toFunction(f);\n\t    this.out = out;\n        this.out.getVertex__().sources = this.out.getVertex__().sources.concat(\n            toSources(Lambda2_deps(f)));\n        this.accumValid = false;\n    }\n\tprivate f : (l : A, r : A) => A;\n\tprivate out : StreamWithSend<A>;\n\tprivate accumValid : boolean;\n    private accum : A;\n    private verbose : boolean;\n    send_(a : A) {\n        if (this.accumValid)\n            this.accum = this.f(this.accum, a);\n        else {\n            Transaction.currentTransaction.prioritized(this.out.getVertex__(), () => {\n                this.out.send_(this.accum);\n                this.accumValid = false;\n                this.accum = null;\n            });\n            this.accum = a;\n            this.accumValid = true;\n        }\n    }\n}\n","/**\n * A representation for a value that may not be available until the current\n * transaction is closed.\n */\nexport class Lazy<A> {\n    constructor(f : () => A) {\n        this.f = f;\n    }\n\n    private f : () => A;\n\n    /**\n     * Get the value if available, throwing an exception if not.\n     * In the general case this should only be used in subsequent transactions to\n     * when the Lazy was obtained.\n     */\n    get() : A {\n        return this.f();\n    }\n\n    /**\n     * Map the lazy value according to the specified function, so the returned Lazy reflects\n     * the value of the function applied to the input Lazy's value.\n     * @param f Function to apply to the contained value. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : (a : A) => B) {\n        return new Lazy<B>(() => { return f(this.f()); });\n    }\n\n\t/**\n\t * Lift a binary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift<B,C>(b : Lazy<B>, f : (a : A, b : B) => C) : Lazy<C> {\n        return new Lazy<C>(() => { return f(this.f(), b.f()); });\n    }\n\n\t/**\n\t * Lift a ternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift3<B,C,D>(b : Lazy<B>, c : Lazy<C>, f : (a : A, b : B, c : C) => D) : Lazy<D> {\n        return new Lazy<D>(() => { return f(this.f(), b.f(), c.f()); });\n    }\n\n\t/**\n\t * Lift a quaternary function into lazy values, so the returned Lazy reflects\n     * the value of the function applied to the input Lazys' values.\n\t */\n    lift4<B,C,D,E>(b : Lazy<B>, c : Lazy<C>, d : Lazy<D>, f : (a : A, b : B, c : C, d : D) => E) : Lazy<E> {\n        return new Lazy<E>(() => { return f(this.f(), b.f(), c.f(), d.f()); });\n    }\n}\n","export class Unit {\n    static UNIT : Unit = new Unit();\n    constructor() {}\n}\n","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Cell } from \"./Cell\";\nimport { Transaction } from \"./Transaction\";\nimport { Unit } from \"./Unit\";\nimport { Source, Vertex } from \"./Vertex\";\n\nexport class Operational {\n    /**\n     * A stream that gives the updates/steps for a {@link Cell}.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static updates<A>(c : Cell<A>) : Stream<A> {\n        /*  Don't think this is needed\n        const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"updates\", 0, [\n                new Source(\n                    c.getStream__().getVertex__(),\n                    () => {\n                        return c.getStream__().listen_(out.getVertex__(), (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                ),\n                new Source(\n                    c.getVertex__(),\n                    () => {\n                        return () => { };\n                    }\n                )\n            ]\n        ));\n        return out;\n        */\n        return c.getStream__();\n    }\n\n    /**\n     * A stream that is guaranteed to fire once in the transaction where value() is invoked, giving\n     * the current value of the cell, and thereafter behaves like {@link updates(Cell)},\n     * firing for each update/step of the cell's value.\n     * <P>\n     * This is an OPERATIONAL primitive, which is not part of the main Sodium\n     * API. It breaks the property of non-detectability of cell steps/updates.\n     * The rule with this primitive is that you should only use it in functions\n     * that do not allow the caller to detect the cell updates.\n     */\n    static value<A>(c : Cell<A>) : Stream<A> {\n        return Transaction.run(() => {\n            const sSpark = new StreamWithSend<Unit>();\n            Transaction.currentTransaction.prioritized(sSpark.getVertex__(), () => {\n                sSpark.send_(Unit.UNIT);\n            });\n            const sInitial = sSpark.snapshot1(c);\n            return Operational.updates(c).orElse(sInitial);\n        });\n    }\n\n\t/**\n\t * Push each event onto a new transaction guaranteed to come before the next externally\n\t * initiated transaction. Same as {@link split(Stream)} but it works on a single value.\n\t */\n\tstatic defer<A>(s : Stream<A>) : Stream<A> {\n\t    return Operational.split<A>(s.map((a : A) => {\n\t        return [a];\n\t    }));\n    }\n\n\t/**\n\t * Push each event in the list onto a newly created transaction guaranteed\n\t * to come before the next externally initiated transaction. Note that the semantics\n\t * are such that two different invocations of split() can put events into the same\n\t * new transaction, so the resulting stream's events could be simultaneous with\n\t * events output by split() or {@link defer(Stream)} invoked elsewhere in the code.\n\t */\n\tstatic split<A>(s : Stream<Array<A>>) : Stream<A> {\n\t    const out = new StreamWithSend<A>(null);\n        out.setVertex__(new Vertex(\"split\", 0, [\n                new Source(\n                    s.getVertex__(),\n                    () => {\n                        return s.listen_(out.getVertex__(), (as : Array<A>) => {\n                            for (let i = 0; i < as.length; i++) {\n                                Transaction.currentTransaction.post(i, () => {\n                                    Transaction.run(() => {\n                                        out.send_(as[i]);\n                                    });\n                                });\n                            }\n                        }, false);\n                    }\n                )\n            ]\n        ));\n        return out;\n    }\n}\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\nimport { Lazy } from \"./Lazy\";\nimport { Listener } from \"./Listener\";\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { Operational } from \"./Operational\";\n\nclass LazySample<A> {\n    constructor(cell : Cell<A>) {\n        this.cell = cell;\n    }\n    cell : Cell<A>;\n    hasValue : boolean = false;\n    value : A = null;\n}\n\nclass ApplyState<A,B> {\n    constructor() {}\n    f : (a : A) => B = null;\n    f_present : boolean = false;\n    a : A = null;\n    a_present : boolean = false;\n}\n\nexport class Cell<A> {\n\tprivate str : Stream<A>;\n\tprotected value : A;\n\tprotected valueUpdate : A;\n\tprivate cleanup : () => void;\n\tprotected lazyInitValue : Lazy<A>;  // Used by LazyCell\n\tprivate vertex : Vertex;\n\n    constructor(initValue : A, str? : Stream<A>) {\n        this.value = initValue;\n        if (!str) {\n            this.str = new Stream<A>();\n            this.vertex = new Vertex(\"ConstCell\", 0, []);\n        }\n        else\n            Transaction.run(() => this.setStream(str));\n    }\n\n    protected setStream(str : Stream<A>) {\n        this.str = str;\n        const me = this,\n              src = new Source(\n                str.getVertex__(),\n                () => {\n                    return str.listen_(me.vertex, (a : A) => {\n                        if (me.valueUpdate == null) {\n                            Transaction.currentTransaction.last(() => {\n                                me.value = me.valueUpdate;\n                                me.lazyInitValue = null;\n                                me.valueUpdate = null;\n                            });\n                        }\n                        me.valueUpdate = a;\n                    }, false);\n                }\n            );\n        this.vertex = new Vertex(\"Cell\", 0, [src]);\n        // We do a trick here of registering the source for the duration of the current\n        // transaction so that we are guaranteed to catch any stream events that\n        // occur in the same transaction.\n        this.vertex.register(Vertex.NULL);\n        Transaction.currentTransaction.last(() => {\n            this.vertex.deregister(Vertex.NULL);\n        });\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    getStream__() : Stream<A> {  // TO DO: Figure out how to hide this\n        return this.str;\n    }\n\n    /**\n     * Sample the cell's current value.\n     * <p>\n     * It should generally be avoided in favour of {@link listen(Handler)} so you don't\n     * miss any updates, but in many circumstances it makes sense.\n     * <p>\n     * NOTE: In the Java and other versions of Sodium, using sample() inside map(), filter() and\n     * merge() is encouraged. In the Javascript/Typescript version, not so much, for the\n     * following reason: The memory management is different in the Javascript version, and this\n     * requires us to track all dependencies. In order for the use of sample() inside\n     * a closure to be correct, the cell that was sample()d inside the closure would have to be\n     * declared explicitly using the helpers lambda1(), lambda2(), etc. Because this is\n     * something that can be got wrong, we don't encourage this kind of use of sample() in\n     * Javascript. Better and simpler to use snapshot().\n     * <p>\n     * NOTE: If you need to sample() a cell, you have to make sure it's \"alive\" in terms of\n     * memory management or it will ignore updates. To make a cell work correctly\n     * with sample(), you have to ensure that it's being used. One way to guarantee this is\n     * to register a dummy listener on the cell. It will also work to have it referenced\n     * by something that is ultimately being listened to.\n     */\n    sample() : A {\n        return Transaction.run(() => { return this.sampleNoTrans__(); });\n    }\n\n    sampleNoTrans__() : A {  // TO DO figure out how to hide this\n        return this.value;\n    }\n\n    /**\n     * A variant of {@link sample()} that works with {@link CellLoop}s when they haven't been looped yet.\n     * It should be used in any code that's general enough that it could be passed a {@link CellLoop}.\n     * @see Stream#holdLazy(Lazy) Stream.holdLazy()\n     */\n    sampleLazy() : Lazy<A> {\n        const me = this;\n        return Transaction.run(() => me.sampleLazyNoTrans__());\n    }\n\n    sampleLazyNoTrans__() : Lazy<A> {  // TO DO figure out how to hide this\n        const me = this,\n            s = new LazySample<A>(me);\n        Transaction.currentTransaction.sample(() => {\n            s.value = me.valueUpdate != null ? me.valueUpdate : me.sampleNoTrans__();\n            s.hasValue = true;\n            s.cell = null;\n        });\n        return new Lazy<A>(() => {\n            if (s.hasValue)\n                return s.value;\n            else\n                return s.cell.sample();\n        });\n    }\n\n    /**\n     * Transform the cell's value according to the supplied function, so the returned Cell\n     * always reflects the value of the function applied to the input Cell's value.\n     * @param f Function to apply to convert the values. It must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Cell<B> {\n        const c = this;\n        return Transaction.run(() =>\n            Operational.updates(c).map(f).holdLazy(c.sampleLazy().map(Lambda1_toFunction(f)))\n        );\n    }\n\n\t/**\n\t * Lift a binary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift<B,C>(b : Cell<B>,\n\t          fn0 : ((a : A, b : B) => C) |\n\t                Lambda2<A,B,C>) : Cell<C> {\n        const fn = Lambda2_toFunction(fn0),\n            cf = this.map((aa : A) => (bb : B) => fn(aa, bb));\n        return Cell.apply(cf, b,\n            toSources(Lambda2_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a ternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift3<B,C,D>(b : Cell<B>, c : Cell<C>,\n\t             fn0 : ((a : A, b : B, c : C) => D) |\n\t                   Lambda3<A,B,C,D>) : Cell<D> {\n        const fn = Lambda3_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => D =\n                 (aa : A) => (bb : B) => (cc : C) => fn(aa, bb, cc),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply<B, (c : C) => D>(cf, b),\n                   c,\n                   toSources(Lambda3_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a quaternary function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\n\t               fn0 : ((a : A, b : B, c : C, d : D) => E) |\n\t                     Lambda4<A,B,C,D,E>) : Cell<E> {\n        const fn = Lambda4_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => E =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => fn(aa, bb, cc, dd),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply<B, (c : C) => (d : D) => E>(cf, b),\n                       c),\n                   d,\n                   toSources(Lambda4_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 5-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\n\t                 fn0 : ((a : A, b : B, c : C, d : D, e : E) => F) |\n\t                       Lambda5<A,B,C,D,E,F>) : Cell<F> {\n        const fn = Lambda5_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => F =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => fn(aa, bb, cc, dd, ee),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply<B, (c : C) => (d : D) => (e : E) => F>(cf, b),\n                           c),\n                       d),\n                   e,\n                   toSources(Lambda5_deps(fn0)));\n\t}\n\n\t/**\n\t * Lift a 6-argument function into cells, so the returned Cell always reflects the specified\n\t * function applied to the input cells' values.\n\t * @param fn Function to apply. It must be <em>referentially transparent</em>.\n\t */\n\tlift6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\n\t                   fn0 : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) |\n\t                         Lambda6<A,B,C,D,E,F,G>) : Cell<G> {\n        const fn = Lambda6_toFunction(fn0),\n            mf : (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => G =\n                 (aa : A) => (bb : B) => (cc : C) => (dd : D) => (ee : E) => (ff : F) => fn(aa, bb, cc, dd, ee, ff),\n            cf = this.map(mf);\n        return Cell.apply(\n                   Cell.apply(\n                       Cell.apply(\n                           Cell.apply(\n                               Cell.apply<B, (c : C) => (d : D) => (e : E) => (f : F) => G>(cf, b),\n                               c),\n                           d),\n                       e),\n                   f,\n                   toSources(Lambda6_deps(fn0)));\n\t}\n\n\t/**\n\t * Apply a value inside a cell to a function inside a cell. This is the\n\t * primitive for all function lifting.\n\t */\n\tstatic apply<A,B>(cf : Cell<(a : A) => B>, ca : Cell<A>, sources? : Source[]) : Cell<B> {\n    \treturn Transaction.run(() => {\n    \t    const state = new ApplyState<A,B>(),\n                out = new StreamWithSend<B>(),\n                cf_value = Operational.value(cf),\n                ca_value = Operational.value(ca),\n                src1 = new Source(\n                        cf_value.getVertex__(),\n                        () => {\n                            return cf_value.listen_(out.getVertex__(), (f : (a : A) => B) => {\n                                state.f = f;\n                                state.f_present = true;\n                                if (state.a_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    ),\n                src2 = new Source(\n                        ca_value.getVertex__(),\n                        () => {\n                            return ca_value.listen_(out.getVertex__(), (a : A) => {\n                                state.a = a;\n                                state.a_present = true;\n                                if (state.f_present)\n                                    out.send_(state.f(state.a));\n                            }, false);\n                        }\n                    );\n            out.setVertex__(new Vertex(\"apply\", 0,\n                [src1, src2].concat(sources ? sources : [])\n            ));\n            return out.coalesce__((l, r) => r).holdLazy(new Lazy<B>(() =>\n                    cf.sampleNoTrans__()(ca.sampleNoTrans__())\n                ));\n        });\n\t}\n\n\t/**\n\t * Unwrap a cell inside another cell to give a time-varying cell implementation.\n\t */\n    static switchC<A>(cca : Cell<Cell<A>>) : Cell<A> {\n\t    return Transaction.run(() => {\n            const za = cca.sampleLazy().map((ba : Cell<A>) => ba.sample()),\n                out = new StreamWithSend<A>();\n            let last_ca : Cell<A> = null;\n            const cca_value = Operational.value(cca),\n                  src = new Source(\n                        cca_value.getVertex__(),\n                        () => {\n                            let kill2 : () => void = last_ca === null ? null :\n                                    Operational.value(last_ca).listen_(out.getVertex__(),\n                                        (a : A) => out.send_(a), false);\n                            const kill1 = cca_value.listen_(out.getVertex__(), (ca : Cell<A>) => {\n                                // Note: If any switch takes place during a transaction, then the\n                                // coalesce__() below will always cause a sample to be fetched\n                                // from the one we just switched to. So anything from the old input cell\n                                // that might have happened during this transaction will be suppressed.\n                                last_ca = ca;\n                                if (kill2 !== null)\n                                    kill2();\n                                kill2 = Operational.value(ca).listen_(out.getVertex__(),\n                                    (a : A) => out.send_(a), false);\n                            }, false);\n                            return () => { kill1(); kill2(); };\n                        }\n                    );\n            out.setVertex__(new Vertex(\"switchC\", 0, [src]));\n            return out.coalesce__((l, r) => r).holdLazy(za);\n        });\n\t}\n\n\t/**\n\t * Unwrap a stream inside a cell to give a time-varying stream implementation.\n\t */\n\tstatic switchS<A>(csa : Cell<Stream<A>>) : Stream<A> {\n\t    return Transaction.run(() => {\n            const out = new StreamWithSend<A>(),\n                  h2 = (a : A) => {\n                          out.send_(a);\n                      },\n                  src = new Source(\n                      csa.getVertex__(),\n                      () => {\n                          let kill2 = csa.sampleNoTrans__().listen_(out.getVertex__(), h2, false);\n                          const kill1 = csa.getStream__().listen_(out.getVertex__(), (sa : Stream<A>) => {\n                              kill2();\n                              kill2 = sa.listen_(out.getVertex__(), h2, true);\n                          }, false);\n                          return () => { kill1(); kill2(); };\n                      }\n                  );\n\t        out.setVertex__(new Vertex(\"switchS\", 0, [src]));\n\t        return out;\n\t    });\n    }\n\n\t/**\n\t * Listen for updates to the value of this cell. This is the observer pattern. The\n\t * returned {@link Listener} has a {@link Listener#unlisten()} method to cause the\n\t * listener to be removed. This is an OPERATIONAL mechanism is for interfacing between\n\t * the world of I/O and for FRP.\n\t * @param h The handler to execute when there's a new value.\n\t *   You should make no assumptions about what thread you are called on, and the\n\t *   handler should not block. You are not allowed to use {@link CellSink#send(Object)}\n\t *   or {@link StreamSink#send(Object)} in the handler.\n\t *   An exception will be thrown, because you are not meant to use this to create\n\t *   your own primitives.\n     */\n    listen(h : (a : A) => void) : () => void {\n        return Transaction.run(() => {\n            return Operational.value(this).listen(h);\n        });\n    }\n\n    /**\n     * Fantasy-land Algebraic Data Type Compatability.\n     * Cell satisfies the Monad and Comonad Categories (and hence Functor, Apply, Applicative, and Extend as well)\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\n     */\n\n    //of :: Applicative f => a -> f a\n    static 'fantasy-land/of'<A>(a:A):Cell<A> {\n      return new Cell<A>(a);\n    }\n\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Cell<B> {\n      return this.map(f);\n    }\n\n    //ap :: Apply f => f a ~> f (a -> b) -> f b\n    'fantasy-land/ap'<B>(cf: Cell<(a : A) => B>):Cell<B> {\n        return Cell.apply(cf, this);\n    }\n\n    //chain :: Chain m => m a ~> (a -> m b) -> m b\n    'fantasy-land/chain'<B>(f: ((a:A) => Cell<B>)):Cell<B> {\n      return Cell.switchC(this.map(f));\n    }\n\n    //extend :: Extend w => w a ~> (w a -> b) -> w b\n    'fantasy-land/extend'<B>(f: ((a:Cell<A>) => B)):Cell<B> {\n      return new Cell<B>(f(this));\n    }\n\n    //extract :: Comonad w => w a ~> () -> a\n    'fantasy-land/extract'():A {\n      return this.sample();\n    }\n}\n","import { Source, Vertex } from \"./Vertex\";\n\nexport class Listener<A> {\n    constructor(h : (a : A) => void, target : Vertex) {\n        this.h = h;\n        this.target = target;\n    }\n    h : (a : A) => void;\n    target : Vertex;\n}\n","import { Lazy } from \"./Lazy\";\nimport { Cell } from \"./Cell\";\nimport { Stream } from \"./Stream\";\nimport { Transaction } from \"./Transaction\";\n\nexport class LazyCell<A> extends Cell<A> {\n    constructor(lazyInitValue : Lazy<A>, str? : Stream<A>) {\n        super(null, null);\n        Transaction.run(() => {\n            if (str)\n                this.setStream(str);\n            this.lazyInitValue = lazyInitValue;\n        });\n    }\n\n    sampleNoTrans__() : A {  // Override\n        if (this.value == null && this.lazyInitValue != null) {\n            this.value = this.lazyInitValue.get();\n            this.lazyInitValue = null;\n        }\n        return this.value;\n    }\n}\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction,\n         Lambda3, Lambda3_deps, Lambda3_toFunction,\n         Lambda4, Lambda4_deps, Lambda4_toFunction,\n         Lambda5, Lambda5_deps, Lambda5_toFunction,\n         Lambda6, Lambda6_deps, Lambda6_toFunction,\n         toSources } from \"./Lambda\";\nimport { Source, Vertex } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { Cell } from \"./Cell\";\n//import { StreamLoop } from \"./StreamLoop\";\nimport { Listener } from \"./Listener\";\nimport { Tuple2 } from \"./Tuple2\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\nimport * as Z from \"sanctuary-type-classes\";\n\nexport class Stream<A> {\n    constructor(vertex? : Vertex) {\n        this.vertex = vertex ? vertex : new Vertex(\"Stream\", 0, []);\n    }\n\n    getVertex__() : Vertex {\n        return this.vertex;\n    }\n\n    protected vertex : Vertex;\n    protected listeners : Array<Listener<A>> = [];\n    protected firings : A[] = [];\n\n    /**\n     * Transform the stream's event values according to the supplied function, so the returned\n     * Stream's event values reflect the value of the function applied to the input\n     * Stream's event values.\n     * @param f Function to apply to convert the values. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    map<B>(f : ((a : A) => B) | Lambda1<A,B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"map\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a));\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Transform the stream's event values into the specified constant value.\n     * @param b Constant value.\n     */\n    mapTo<B>(b : B) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"mapTo\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(b);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Variant of {@link Stream#merge(Stream, Lambda2)} that merges two streams and will drop an event\n     * in the simultaneous case.\n     * <p>\n     * In the case where two events are simultaneous (i.e. both\n     * within the same transaction), the event from <em>this</em> will take precedence, and\n     * the event from <em>s</em> will be dropped.\n     * If you want to specify your own combining function, use {@link Stream#merge(Stream, Lambda2)}.\n     * s1.orElse(s2) is equivalent to s1.merge(s2, (l, r) -&gt; l).\n     * <p>\n     * The name orElse() is used instead of merge() to make it really clear that care should\n     * be taken, because events can be dropped.\n     */\n    orElse(s : Stream<A>) : Stream<A> {\n        return this.merge(s, (left : A, right: A) => {\n            return left;\n        });\n    }\n\n    private merge_(s : Stream<A>) : Stream<A> {\n        const out = new StreamWithSend<A>();\n        const left = new Vertex(\"merge\", 0, []);\n        left.sources.push(new Source(this.vertex, () => {\n            return this.listen_(left, (a : A) => {\n                    out.send_(a);\n                }, false);\n        }));\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    left,\n                    () => {\n                        left.register(out.vertex);\n                        return () => { left.deregister(out.vertex); }\n                    }\n                ),\n                new Source(\n                    s.vertex,\n                    () => {\n                        return s.listen_(out.vertex, (a : A) => {\n                            out.send_(a);\n                        }, false);\n                    }\n                )\n            ]);\n        return out;\n    }\n\n    coalesce__(f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {  // TO DO figure out how to hide this\n        const out = new StreamWithSend<A>();\n        const coalescer = new CoalesceHandler<A>(f, out);\n        out.vertex.sources = out.vertex.sources.concat([\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            coalescer.send_(a);\n                        }, false);\n                    }\n                )\n            ]).concat(toSources(Lambda2_deps(f)));\n        return out;\n    }\n\n    /**\n     * Merge two streams of the same type into one, so that events on either input appear\n     * on the returned stream.\n     * <p>\n     * If the events are simultaneous (that is, one event from this and one from <em>s</em>\n     * occurring in the same transaction), combine them into one using the specified combining function\n     * so that the returned stream is guaranteed only ever to have one event per transaction.\n     * The event from <em>this</em> will appear at the left input of the combining function, and\n     * the event from <em>s</em> will appear at the right.\n     * @param f Function to combine the values. It may construct FRP logic or use\n     *    {@link Cell#sample()}. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    merge(s : Stream<A>, f : ((left : A, right : A) => A) | Lambda2<A,A,A>) : Stream<A> {\n        return Transaction.run<Stream<A>>(() => {\n            return this.merge_(s).coalesce__(f);\n        });\n    }\n\n    /**\n     * Return a stream that only outputs events for which the predicate returns true.\n     */\n    filter(f : ((a : A) => boolean) | Lambda1<A,boolean>) : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        const ff = Lambda1_toFunction(f);\n        out.vertex = new Vertex(\"filter\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (ff(a))\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ].concat(toSources(Lambda1_deps(f)))\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events that have present\n     * values, discarding null values.\n     */\n    filterNotNull() : Stream<A> {\n        const out = new StreamWithSend<A>(null);\n        out.vertex = new Vertex(\"filterNotNull\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            if (a !== null)\n                                out.send_(a);\n                        }, false);\n                    }\n                )\n            ]\n        );\n        return out;\n    }\n\n    /**\n     * Return a stream that only outputs events from the input stream\n     * when the specified cell's value is true.\n     */\n    gate(c : Cell<boolean>) : Stream<A> {\n        return this.snapshot(c, (a : A, pred : boolean) => {\n            return pred ? a : null;\n        }).filterNotNull();\n    }\n\n\t/**\n\t * Variant of {@link snapshot(Cell, Lambda2)} that captures the cell's value\n\t * at the time of the event firing, ignoring the stream's value.\n\t */\n\tsnapshot1<B>(c : Cell<B>) : Stream<B> {\n        const out = new StreamWithSend<B>(null);\n        out.vertex = new Vertex(\"snapshot1\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(c.sampleNoTrans__());\n                        }, false);\n                    }\n                ),\n                new Source(c.getVertex__(), null)\n            ]\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cell at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, {@link Stream#snapshot(Cell, Lambda2)}\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot<B,C>(b : Cell<B>, f_ : ((a : A, b : B) => C) | Lambda2<A,B,C>) : Stream<C>\n\t{\n        const out = new StreamWithSend<C>(null);\n        const ff = Lambda2_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null)\n            ].concat(toSources(Lambda2_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot3<B,C,D>(b : Cell<B>, c : Cell<C>, f_ : ((a : A, b : B, c : C) => D) | Lambda3<A,B,C,D>) : Stream<D>\n\t{\n        const out = new StreamWithSend<D>(null);\n        const ff = Lambda3_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null)\n            ].concat(toSources(Lambda3_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot4<B,C,D,E>(b : Cell<B>, c : Cell<C>, d : Cell<D>,\n\t    f_ : ((a : A, b : B, c : C, d : D) => E) | Lambda4<A,B,C,D,E>) : Stream<E>\n\t{\n        const out = new StreamWithSend<E>(null);\n        const ff = Lambda4_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null)\n            ].concat(toSources(Lambda4_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot5<B,C,D,E,F>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>,\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E) => F) | Lambda5<A,B,C,D,E,F>) : Stream<F>\n\t{\n        const out = new StreamWithSend<F>(null);\n        const ff = Lambda5_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__(), e.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null),\n                new Source(e.getVertex__(), null)\n            ].concat(toSources(Lambda5_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Return a stream whose events are the result of the combination using the specified\n\t * function of the input stream's event value and the value of the cells at that time.\n     * <P>\n     * There is an implicit delay: State updates caused by event firings being held with\n     * {@link Stream#hold(Object)} don't become visible as the cell's current value until\n     * the following transaction. To put this another way, snapshot()\n     * always sees the value of a cell as it was before any state changes from the current\n     * transaction.\n     */\n\tsnapshot6<B,C,D,E,F,G>(b : Cell<B>, c : Cell<C>, d : Cell<D>, e : Cell<E>, f : Cell<F>,\n\t    f_ : ((a : A, b : B, c : C, d : D, e : E, f : F) => G) | Lambda6<A,B,C,D,E,F,G>) : Stream<G>\n\t{\n        const out = new StreamWithSend<G>(null);\n        const ff = Lambda6_toFunction(f_);\n        out.vertex = new Vertex(\"snapshot\", 0, [\n                new Source(\n                    this.vertex,\n                    () => {\n                        return this.listen_(out.vertex, (a : A) => {\n                            out.send_(ff(a, b.sampleNoTrans__(), c.sampleNoTrans__(),\n                                            d.sampleNoTrans__(), e.sampleNoTrans__(),\n                                            f.sampleNoTrans__()));\n                        }, false);\n                    }\n                ),\n                new Source(b.getVertex__(), null),\n                new Source(c.getVertex__(), null),\n                new Source(d.getVertex__(), null),\n                new Source(e.getVertex__(), null),\n                new Source(f.getVertex__(), null)\n            ].concat(toSources(Lambda6_deps(f_)))\n        );\n        return out;\n\t}\n\n\t/**\n\t * Create a {@link Cell} with the specified initial value, that is updated\n     * by this stream's event values.\n     * <p>\n     * There is an implicit delay: State updates caused by event firings don't become\n     * visible as the cell's current value as viewed by {@link Stream#snapshot(Cell, Lambda2)}\n     * until the following transaction. To put this another way,\n     * {@link Stream#snapshot(Cell, Lambda2)} always sees the value of a cell as it was before\n     * any state changes from the current transaction.\n     */\n    hold(initValue : A) : Cell<A> {\n        return new Cell<A>(initValue, this);\n\t}\n\n\t/**\n\t * A variant of {@link hold(Object)} with an initial value captured by {@link Cell#sampleLazy()}.\n\t */\n\tholdLazy(initValue : Lazy<A>) : Cell<A> {\n\t    return new LazyCell<A>(initValue, this);\n\t}\n\n    /**\n     * Transform an event with a generalized state loop (a Mealy machine). The function\n     * is passed the input and the old state and returns the new state and output value.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    collect<B,S>(initState : S, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        return this.collectLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link collect(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    collectLazy<B,S>(initState : Lazy<S>, f : ((a : A, s : S) => Tuple2<B,S>) | Lambda2<A,S,Tuple2<B,S>>) : Stream<B> {\n        const ea = this;\n        return Transaction.run(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                ebs = ea.snapshot(s, f),\n                eb = ebs.map((bs : Tuple2<B,S>) => { return bs.a; }),\n                es_out = ebs.map((bs : Tuple2<B,S>) => { return bs.b; });\n            es.loop(es_out);\n            return eb;\n        });\n    }\n\n    /**\n     * Accumulate on input event, outputting the new state each time.\n     * @param f Function to apply to update the state. It may construct FRP logic or use\n     *    {@link Cell#sample()} in which case it is equivalent to {@link Stream#snapshot(Cell)}ing the\n     *    cell. Apart from this the function must be <em>referentially transparent</em>.\n     */\n    accum<S>(initState : S, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        return this.accumLazy(new Lazy<S>(() => { return initState; }), f);\n    }\n\n    /**\n     * A variant of {@link accum(Object, Lambda2)} that takes an initial state returned by\n     * {@link Cell#sampleLazy()}.\n     */\n    accumLazy<S>(initState : Lazy<S>, f : ((a : A, s : S) => S) | Lambda2<A,S,S>) : Cell<S> {\n        const ea = this;\n        return Transaction.run(() => {\n            const es = new StreamLoop<S>(),\n                s = es.holdLazy(initState),\n                es_out = ea.snapshot(s, f);\n            es.loop(es_out);\n            return es_out.holdLazy(initState);\n        });\n    }\n\n    /**\n     * Return a stream that outputs only one value: the next event of the\n     * input stream, starting from the transaction in which once() was invoked.\n     */\n    once() : Stream<A> {\n    /*\n        return Transaction.run(() => {\n            const ev = this,\n                out = new StreamWithSend<A>();\n            let la : () => void = null;\n            la = ev.listen_(out.vertex, (a : A) => {\n                if (la !== null) {\n                    out.send_(a);\n                    la();\n                    la = null;\n                }\n            }, false);\n            return out;\n        });\n        */\n        // We can't use the implementation above, beacuse deregistering\n        // listeners triggers the exception\n        // \"send() was invoked before listeners were registered\"\n        // We can revisit this another time. For now we will use the less\n        // efficient implementation below.\n        const me = this;\n        return Transaction.run(() => me.gate(me.mapTo(false).hold(true)));\n    }\n\n    listen(h : (a : A) => void) : () => void {\n        return Transaction.run<() => void>(() => {\n            return this.listen_(Vertex.NULL, h, false);\n        });\n    }\n\n    listen_(target : Vertex,\n            h : (a : A) => void,\n            suppressEarlierFirings : boolean) : () => void {\n        if (this.vertex.register(target))\n            Transaction.currentTransaction.requestRegen();\n        const listener = new Listener<A>(h, target);\n        this.listeners.push(listener);\n        if (!suppressEarlierFirings && this.firings.length != 0) {\n            const firings = this.firings.slice();\n            Transaction.currentTransaction.prioritized(target, () => {\n                // Anything sent already in this transaction must be sent now so that\n                // there's no order dependency between send and listen.\n                for (let i = 0; i < firings.length; i++)\n                    h(firings[i]);\n            });\n        }\n        return () => {\n            let removed = false;\n            for (let i = 0; i < this.listeners.length; i++) {\n                if (this.listeners[i] == listener) {\n                    this.listeners.splice(i, 1);\n                    removed = true;\n                    break;\n                }\n            }\n            if (removed)\n                this.vertex.deregister(target);\n        };\n    }\n\n\n    /**\n     * Fantasy-land Algebraic Data Type Compatability.\n     * Stream satisfies the Functor and Monoid Categories (and hence Semigroup)\n     * @see {@link https://github.com/fantasyland/fantasy-land} for more info\n     */\n\n    //map :: Functor f => f a ~> (a -> b) -> f b\n    'fantasy-land/map'<B>(f : ((a : A) => B)) : Stream<B> {\n      return this.map(f);\n    }\n\n    //concat :: Semigroup a => a ~> a -> a\n    'fantasy-land/concat'(a:Stream<A>) : Stream<A> {\n      return this.merge(a, (left:any, right) => {\n        return (Z.Semigroup.test(left)) ? Z.concat(left, right) : left;\n      });\n    }\n\n    //empty :: Monoid m => () -> m\n    'fantasy-land/empty'() : Stream<A> {\n      return new Stream<A>();\n    }\n}\n\nexport class StreamWithSend<A> extends Stream<A> {\n    constructor(vertex? : Vertex) {\n        super(vertex);\n    }\n\n    setVertex__(vertex : Vertex) {  // TO DO figure out how to hide this\n        this.vertex = vertex;\n    }\n\n    send_(a : A) : void {\n        // We throw this error if we send into FRP logic that has been constructed\n        // but nothing is listening to it yet. We need to do it this way because\n        // it's the only way to manage memory in a language with no finalizers.\n        if (this.vertex.refCount() == 0)\n            throw new Error(\"send() was invoked before listeners were registered\");\n\t\tif (this.firings.length == 0)\n\t\t\tTransaction.currentTransaction.last(() => {\n\t\t\t    this.firings = [];\n            });\n\t\tthis.firings.push(a);\n\t\tconst listeners = this.listeners.slice();\n        for (let i = 0; i < listeners.length; i++) {\n            const h = listeners[i].h;\n            Transaction.currentTransaction.prioritized(listeners[i].target, () => {\n                Transaction.currentTransaction.inCallback++;\n                try {\n                    h(a);\n                    Transaction.currentTransaction.inCallback--;\n                }\n                catch (err) {\n                    Transaction.currentTransaction.inCallback--;\n                    throw err;\n                }\n            });\n        }\n    }\n}\n\n/**\n * A forward reference for a {@link Stream} equivalent to the Stream that is referenced.\n */\nexport class StreamLoop<A> extends StreamWithSend<A> {\n    assigned__ : boolean = false;  // to do: Figure out how to hide this\n\n    constructor()\n    {\n        super();\n        this.vertex.name = \"StreamLoop\";\n    \tif (Transaction.currentTransaction === null)\n    \t    throw new Error(\"StreamLoop/CellLoop must be used within an explicit transaction\");\n    }\n\n    /**\n     * Resolve the loop to specify what the StreamLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the StreamLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(sa_out : Stream<A>) : void {\n        if (this.assigned__)\n            throw new Error(\"StreamLoop looped more than once\");\n        this.assigned__ = true;\n        this.vertex.addSource(\n            new Source(\n                sa_out.getVertex__(),\n                () => {\n                    return sa_out.listen_(this.vertex, (a : A) => {\n                        this.send_(a);\n                    }, false);\n                }\n            )\n        );\n    }\n}\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { StreamWithSend } from \"./Stream\";\nimport { CoalesceHandler } from \"./CoalesceHandler\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * A stream that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports StreamSinks for read-only use\n * should downcast to {@link Stream}.\n */\nexport class StreamSink<A> extends StreamWithSend<A> {\n    constructor(f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n        super();\n        if (!f)\n            f = <(l : A, r : A) => A>((l : A, r : A) => {\n                throw new Error(\"send() called more than once per transaction, which isn't allowed. Did you want to combine the events? Then pass a combining function to your StreamSink constructor.\");\n            });\n        this.coalescer = new CoalesceHandler<A>(f, this);\n    }\n\n    private coalescer : CoalesceHandler<A>;\n\n    send(a : A) : void {\n        Transaction.run<void>(\n            () => {\n                if (Transaction.currentTransaction.inCallback > 0)\n                    throw new Error(\"You are not allowed to use send() inside a Sodium callback\");\n                this.coalescer.send_(a);\n            }\n        )\n    }\n}\n","import { Cell } from \"./Cell\";\nimport { Lazy } from \"./Lazy\";\nimport { LazyCell } from \"./LazyCell\";\nimport { Transaction } from \"./Transaction\";\nimport { StreamLoop } from \"./Stream\";\n\n/**\n * A forward reference for a {@link Cell} equivalent to the Cell that is referenced.\n */\nexport class CellLoop<A> extends LazyCell<A> {\n    constructor() {\n    \tsuper(null, new StreamLoop<A>());\n    }\n\n    /**\n     * Resolve the loop to specify what the CellLoop was a forward reference to. It\n     * must be invoked inside the same transaction as the place where the CellLoop is used.\n     * This requires you to create an explicit transaction with {@link Transaction#run(Lambda0)}\n     * or {@link Transaction#runVoid(Runnable)}.\n     */\n    loop(a_out : Cell<A>) : void {\n        const me = this;\n        Transaction.run(() => {\n            (<StreamLoop<A>>me.getStream__()).loop(a_out.getStream__());\n            me.lazyInitValue = a_out.sampleLazy();\n        });\n    }\n\n    sampleNoTrans__() : A\n    {\n        if (!(<StreamLoop<A>>this.getStream__()).assigned__)\n            throw new Error(\"CellLoop sampled before it was looped\");\n        return super.sampleNoTrans__();\n    }\n}\n","import { Lambda1, Lambda1_deps, Lambda1_toFunction,\n         Lambda2, Lambda2_deps, Lambda2_toFunction } from \"./Lambda\";\nimport { Cell } from \"./Cell\";\nimport { StreamSink } from \"./StreamSink\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * A cell that allows values to be pushed into it, acting as an interface between the\n * world of I/O and the world of FRP. Code that exports CellSinks for read-only use\n * should downcast to {@link Cell}.\n */\nexport class CellSink<A> extends Cell<A> {\n    /**\n     * Construct a writable cell with the specified initial value. If multiple values are\n     * sent in the same transaction, the specified function is used to combine them.\n     *\n     * If the function is not supplied, then an exception will be thrown in this case.\n     */\n    constructor(initValue : A, f? : ((l : A, r : A) => A) | Lambda2<A, A, A>) {\n    \tsuper(initValue, new StreamSink<A>(f));\n    }\n\n    /**\n     * Send a value, modifying the value of the cell. send(A) may not be used inside\n     * handlers registered with {@link Stream#listen(Handler)} or {@link Cell#listen(Handler)}.\n     * An exception will be thrown, because CellSink is for interfacing I/O to FRP only.\n     * You are not meant to use this to define your own primitives.\n     * @param a Value to push into the cell.\n     */\n    send(a : A) : void {\n        (<StreamSink<A>>this.getStream__()).send(a);\n    }\n}\n","export class Tuple2<A,B> {\n    constructor(a : A, b : B) {\n        this.a = a;\n        this.b = b;\n    }\n    a : A;\n    b : B;\n}\n","import { Vertex, Source } from \"./Vertex\";\nimport * as Collections from 'typescript-collections';\nimport { Stream, StreamWithSend } from \"./Stream\";\nimport { StreamSink } from \"./StreamSink\";\nimport { Cell } from \"./Cell\";\nimport { CellSink } from \"./CellSink\";\nimport { Transaction } from \"./Transaction\";\n\n/**\n * An interface for implementations of FRP timer systems.\n */\nexport abstract class TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    abstract setTimer(t : number, callback : () => void) : () => void;\n\n    /**\n     * Return the current clock time.\n     */\n    abstract now() : number;\n}\n\nlet nextSeq : number = 0;\n\nclass Event {\n    constructor(t : number, sAlarm : StreamWithSend<number>) {\n        this.t = t;\n        this.sAlarm = sAlarm;\n        this.seq = ++nextSeq;\n    }\n    t : number;\n    sAlarm : StreamWithSend<number>;\n    seq : number;  // Used to guarantee uniqueness\n}\n\nexport class TimerSystem {\n    constructor(impl : TimerSystemImpl) {\n        Transaction.run(() => {\n            this.impl = impl;\n            this.tMinimum = 0;\n            const timeSnk = new CellSink<number>(impl.now());\n            this.time = timeSnk;\n            // A dummy listener to time to keep it alive even when there are no other listeners.\n            this.time.listen((t : number) => { });\n            Transaction.onStart(() => {\n                // Ensure the time is always increasing from the FRP's point of view.\n                const t = this.tMinimum = Math.max(this.tMinimum, impl.now());\n                // Pop and execute all events earlier than or equal to t (the current time).\n                while (true) {\n                    let ev : Event = null;\n                    if (!this.eventQueue.isEmpty()) {\n                        let mev = this.eventQueue.minimum();\n                        if (mev.t <= t) {\n                            ev = mev;\n                            // TO DO: Detect infinite loops!\n                        }\n                    }\n                    if (ev != null) {\n                        timeSnk.send(ev.t);\n                        Transaction.run(() => ev.sAlarm.send_(ev.t));\n                    }\n                    else\n                        break;\n                }\n                timeSnk.send(t);\n            });\n        });\n    }\n\n    private impl : TimerSystemImpl;\n    private tMinimum : number;  // A guard to allow us to guarantee that the time as\n                                // seen by the FRP is always increasing.\n\n    /**\n     * A cell giving the current clock time.\n     */\n    time : Cell<number>;\n\n    private eventQueue : Collections.BSTree<Event> = new Collections.BSTree<Event>((a, b) => {\n        if (a.t < b.t) return -1;\n        if (a.t > b.t) return 1;\n        if (a.seq < b.seq) return -1;\n        if (a.seq > b.seq) return 1;\n        return 0;\n    });\n\n    /**\n     * A timer that fires at the specified time, which can be null, meaning\n     * that the alarm is not set.\n     */\n    at(tAlarm : Cell<number>) : Stream<number> {\n        let current : Event = null,\n            cancelCurrent : () => void = null,\n            active : boolean = false,\n            tAl : number = null,\n            sampled : boolean = false;\n        const sAlarm = new StreamWithSend<number>(null),\n            updateTimer = () => {\n                if (cancelCurrent !== null) {\n                    cancelCurrent();\n                    this.eventQueue.remove(current);\n                }\n                cancelCurrent = null;\n                current = null;\n                if (active) {\n                    if (!sampled) {\n                        sampled = true;\n                        tAl = tAlarm.sampleNoTrans__();\n                    }\n                    if (tAl !== null) {\n                        current = new Event(tAl, sAlarm);\n                        this.eventQueue.add(current);\n                        cancelCurrent = this.impl.setTimer(tAl, () => {\n                                    // Correction to ensure the clock time appears to be >= the\n                                    // alarm time. It can be a few milliseconds early, and\n                                    // this breaks things otherwise, because it doesn't think\n                                    // it's time to fire the alarm yet.\n                                    this.tMinimum = Math.max(this.tMinimum, tAl);\n                                    // Open and close a transaction to trigger queued\n                                    // events to run.\n                                    Transaction.run(() => {});\n                                });\n                    }\n                }\n            };\n        sAlarm.setVertex__(new Vertex(\"at\", 0, [\n                new Source(\n                    tAlarm.getVertex__(),\n                    () => {\n                        active = true;\n                        sampled = false;\n                        Transaction.currentTransaction.prioritized(sAlarm.getVertex__(), updateTimer);\n                        const kill = tAlarm.getStream__().listen_(sAlarm.getVertex__(), (oAlarm : number) => {\n                            tAl = oAlarm;\n                            sampled = true;\n                            updateTimer();\n                        }, false);\n                        return () => {\n                            active = false;\n                            updateTimer();\n                            kill();\n                        };\n                    }\n                )\n            ]\n        ));\n        return sAlarm;\n    }\n}\n\n","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using seconds as the time unit.\n */\nexport class SecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new SecondsTimerSystemImpl());\n    }\n}\n\nclass SecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, Math.max((t - this.now()) * 1000, 0));\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now() * 0.001;\n    }\n}\n","import { TimerSystem, TimerSystemImpl } from \"./TimerSystem\";\n\n/**\n * A timer system implementation using milliseconds as the time unit.\n */\nexport class MillisecondsTimerSystem extends TimerSystem {\n    constructor() {\n        super(new MillisecondsTimerSystemImpl());\n    }\n}\n\nclass MillisecondsTimerSystemImpl extends TimerSystemImpl {\n    /**\n     * Set a timer that will execute the specified callback at the specified time.\n     * @return A function that can be used to cancel the timer.\n     */\n    setTimer(t : number, callback : () => void) : () => void\n    {\n        let timeout = setTimeout(callback, Math.max(t - this.now(), 0));\n        return () => { clearTimeout(timeout); }\n    }\n\n    /**\n     * Return the current clock time.\n     */\n    now() : number\n    {\n        return Date.now();\n    }\n}\n","import { Stream, StreamWithSend } from \"./Stream\";\nimport { Vertex, Source } from \"./Vertex\";\nimport { Transaction } from \"./Transaction\";\n\nexport class IOAction {\n    /*!\n     * Convert a function that performs asynchronous I/O taking input A\n     * and returning a value of type B into an I/O action of type\n     * (sa : Stream<A>) => Stream<B>\n     */\n    static fromAsync<A,B>(performIO : (a : A, result : (b : B) => void) => void)\n            : (sa : Stream<A>) => Stream<B> {\n        return (sa : Stream<A>) => {\n            const out = new StreamWithSend<B>(null);\n            out.setVertex__(new Vertex(\"map\", 0, [\n                    new Source(\n                        sa.getVertex__(),\n                        () => {\n                            return sa.listen_(out.getVertex__(), (a : A) => {\n                                performIO(a, (b : B) => {\n                                    Transaction.run(() => {\n                                        out.send_(b);\n                                    });\n                                });\n                            }, false);\n                        }\n                    )\n                ]\n            ));\n            return out;\n        }\n    }\n}\n"],"names":["Collections.PriorityQueue","Collections.Set","tslib_1.__extends","Z.Semigroup","Z.concat","Collections.BSTree"],"mappings":"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"}